[{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/manual/build/","title":"build at PSI","tags":[],"description":"","content":" These instructions only work at PSI!\n Build at PSI, using driver.makefile by default this module is only build for RHEL7 and Epics \u0026gt;=R7.0.5\nbuild on login cluster make [LIBVERSION] [clean] [uninstall] install check a particular version check the module loads for version dev, Epics R7+ and ECMC version dev, note MASTER_ID=-1 which runs ECMC in master-less mode. Make proper adjustments to match your needs in terms of versions.\niocsh -7 -r \u0026#34;ecmccfg,dev \u0026#39;ECMC_VER=dev,MASTER_ID=-1\u0026#39;\u0026#34; "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/manual/","title":"manual","tags":[],"description":"","content":"ecmccfg A configuration framework for ECMC Motion Control Module for EPICS.\nPurpose The configuration framework contains the necessary files to configure an EPICS IOC for EtherCAT based motion control and DAQ.\n Topics  build at PSI   introduction   axis   PLC    provided common user commands  addAxis.cmd addDataStorage.cmd addMaster.cmd addSlave.cmd addSlaveKL.cmd addVirtualAxis.cmd applyAxisSynchronization.cmd applyConfig.cmd applySlaveConfig.cmd configureAxis.cmd configureSlave.cmd configureVirtualAxis.cmd loadPLCFile.cmd loadPlugin.cmd setAppMode.cmd setDiagnostics.cmd  Example IOC  require the configuration module with optional version  require ecmccfg \u0026lt;VERSION\u0026gt; add a coupler and slave  # slave 0 {ecmcEK1100} ${SCRIPTEXEC} ${ECMC_CONFIG_ROOT}addSlave.cmd, \u0026#34;HW_DESC=EK1100\u0026#34; # SLAVE_ID is automatically incremented # slave 1 {ecmcEL1018} ${SCRIPTEXEC} ${ECMC_CONFIG_ROOT}addSlave.cmd, \u0026#34;HW_DESC=EL1018\u0026#34; # skip slaves 2..6 # slave 7 {ecmcEL2008}, with optional SLAVE_ID ${SCRIPTEXEC} ${ECMC_CONFIG_ROOT}addSlave.cmd, \u0026#34;HW_DESC=E2008, SLAVE_ID=7\u0026#34; #-- ATTENTION, this only work for certain slaves, as the EPICS templates have to be migrated before # slave 9 {ecmcEL2008}, with optional SLAVE_ID and P_SCRIPT ${SCRIPTEXEC} ${ECMC_CONFIG_ROOT}addSlave.cmd, \u0026#34;HW_DESC=E2008, SLAVE_ID=7, P_SCRIPT=mXsXXX\u0026#34; add more slaves and apply configuration to the slaves  # slave 8 {ecmcEL7037}, configure slave with optional SLAVE_ID ${SCRIPTEXEC} ${ECMC_CONFIG_ROOT}configureSlave.cmd, \u0026#34;HW_DESC=EL7037, CONFIG=-Motor-Nanotec-ST4118L1804-B, SLAVE_ID=8\u0026#34; # slave 9 {ecmcEL7037}, addSlave, with immediate call off applySlaveConfig # slave with global configuration ${SCRIPTEXEC} ${ECMC_CONFIG_ROOT}addSlave.cmd, \u0026#34;HW_DESC=EL7037\u0026#34; ${SCRIPTEXEC} ${ECMC_CONFIG_ROOT}applySlaveConfig, \u0026#34;CONFIG=-Motor-Nanotec-ST4118L1804-B\u0026#34; # slave with local configuration, in this case provided by the module `ECMC_AGIR` epicsEnvSet(\u0026#34;CFG_ROOT\u0026#34;, \u0026#34;${ECMC_AGIR_DIR}/\u0026#34;) ${SCRIPTEXEC} ${ECMC_CONFIG_ROOT}addSlave.cmd, \u0026#34;HW_DESC=EP7211-0034_ALL\u0026#34; ${SCRIPTEXEC} ${ECMC_CONFIG_ROOT}applySlaveConfig.cmd, \u0026#34;LOCAL_CONFIG=${CFG_ROOT}AM8211_AGIR.cfg\u0026#34; apply the configuration  ${SCRIPTEXEC} ${ECMC_CONFIG_ROOT}applyConfig.cmd additional configuration  manually set binaryOutput01 to 1\necmcConfigOrDie \u0026#34;Cfg.WriteEcEntryIDString(${ECMC_EC_SLAVE_NUM_DIG_OUT},binaryOutput01,1)\u0026#34; adding a physical motor axis   classic config  epicsEnvSet(\u0026#34;DEV\u0026#34;, \u0026#34;STEST-MYDEVICE\u0026#34;) ${SCRIPTEXEC} ${ECMC_CONFIG_ROOT}configureAxis.cmd, \u0026#34;CONFIG=./cfg/axis_1\u0026#34;  yaml config  ${SCRIPTEXEC} ${ECMC_CONFIG_ROOT}addAxisYaml.cmd, \u0026#34;FILE=./AM8111_CSV_minimum.yaml, ECMC_TMPDIR=/tmp/\u0026#34; adding a virtual motor axis  ${SCRIPTEXEC} ${ecmccfg_DIR}configureVirtualAxis.cmd, \u0026#34;CONFIG=./cfg/axis_11_virt\u0026#34; adding synchronization  ${SCRIPTEXEC} ${ecmccfg_DIR}applyAxisSynchronization.cmd, \u0026#34;CONFIG=./cfg/axis_1_sync\u0026#34; ${SCRIPTEXEC} ${ecmccfg_DIR}applyAxisSynchronization.cmd, \u0026#34;CONFIG=./cfg/axis_11_sync\u0026#34; loading a PLC from file   classic PLC-file  ${SCRIPTEXEC} ${ecmccfg_DIR}loadPLCFile.cmd, \u0026#34;PLC_ID=0, FILE=./plc/homeSlit.plc, SAMPLE_RATE_MS=100\u0026#34;  pure yaml based PLC  ${SCRIPTEXEC} \u0026#34;${ECMC_CONFIG_ROOT}loadYamlPlc.cmd\u0026#34; \u0026#34;FILE=./plc1.yaml, ECMC_TMPDIR=/tmp/\u0026#34;  yaml definition, with classic PLC-file, Note: file key in yaml config will overwrite anything in the code key!  ${SCRIPTEXEC} \u0026#34;${ECMC_CONFIG_ROOT}loadYamlPlc.cmd\u0026#34; \u0026#34;FILE=./plc1File.yaml, ECMC_TMPDIR=/tmp/\u0026#34; go active  ${SCRIPTEXEC} ${ecmccfg_DIR}setAppMode.cmd "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/scripts/addaxis/","title":"addAxis.cmd","tags":[],"description":"","content":"author Niko Kivel\n "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/scripts/jinja2/addaxisyaml/","title":"addAxisYaml.cmd","tags":[],"description":"","content":"description Script for loading PLC from yaml file via jinja2\ndetails adds a PLC, line by line, from a yaml-file, parsed by jinja2\nauthor Niko Kivel\n paramters FILE the yaml-file containing the PLC definition\n Example calls:\n call  ${SCRIPTEXEC} \u0026#34;./loadYamlPlc.cmd\u0026#34; \u0026#34;FILE=./plc1.yaml\u0026#34; "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/scripts/adddatastorage/","title":"addDataStorage.cmd","tags":[],"description":"","content":"description Script for adding dataStorage.\ndetails Adds dataStorage buffer.\nauthor Anders Sandstroem\n paramters DS_SIZE Size of data buffer.\nDS_ID (optional), default 0, buffer ID\nDS_TYPE (optional), default 0, 0: Normal Buffer, 1: Ring Buffer, 2: FIFO Buffer\nSAMPLE_RATE_MS (optional), default 1\nDS_DEBUG (optional), default 0, 0: No debug printouts, 1: Debug printouts\n Example calls:\n call for 1000 elements at 10 Hz  ${SCRIPTEXEC} ${ecmccfg_DIR}addDataStorage.cmd \u0026#34;DS_ID=1, DS_SIZE=1000, SAMPLE_RATE_MS=100\u0026#34; "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/scripts/addmaster/","title":"addMaster.cmd","tags":[],"description":"","content":"author Niko Kivel\n paramters MASTER_ID (optional) master ID as shown by ethercat master.\n Example calls:\n call w/o MASTER_ID  ${SCRIPTEXEC} ${ecmccfg_DIR}addMaster.cmd  call w/ MASTER_ID, which claims the 4th master.  ${SCRIPTEXEC} ${ecmccfg_DIR}addMaster.cmd, \u0026#34;MASTER_ID=3\u0026#34; "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/scripts/addslave/","title":"addSlave.cmd","tags":[],"description":"","content":"description Script for adding a slave to the EtherCAT bus configuration.\ndetails Adds the respective hardware to the bus configuration, adds specific and default PV to the EPICS database. For some/most slaves also a default\nauthor Niko Kivel\n paramters HW_DESC Hardware descriptor, i.e. EL1008\nSLAVE_ID (optional) bus position\nSUBST_FILE (optional) substitution file\nP_SCRIPT (optional) naming convention prefix script\nNELM (optional) Used for oversampling cards. Defaults to 1\nDEFAULT_SUBS (optional) option to disble default PVs for mapped PDOs\nDEFAULT_SLAVE_PVS (optional, caution!) basic slave PVs, i.e. ${ECMC_P}-Operational will be suppressed\n Example calls:\n call w/o SLAVE_ID  ${SCRIPTEXEC} ${ecmccfg_DIR}addSlave.cmd, \u0026#34;HW_DESC=EL7037\u0026#34;  call w/ SLAVE_ID  ${SCRIPTEXEC} ${ecmccfg_DIR}addSlave.cmd, \u0026#34;HW_DESC=EL1018, SLAVE_ID=1\u0026#34;  call w/ SLAVE_ID and P_SCRIPT  ${SCRIPTEXEC} ${ecmccfg_DIR}addSlave.cmd, \u0026#34;HW_DESC=EL1018, SLAVE_ID=1, P_SCRIPT=mXsXXX\u0026#34;  call w/ default PDO PVs disabled  ${SCRIPTEXEC} ${ecmccfg_DIR}addSlave.cmd, \u0026#34;HW_DESC=EL3204, DEFAULT_SUBS=false, DEFAULT_SLAVE_PVS=true\u0026#34; "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/scripts/addslavekl/","title":"addSlaveKL.cmd","tags":[],"description":"","content":"description Script for adding a slave to the EtherCAT bus configuration of KL type.\ndetails Adds the respective hardware to the bus configuration, adds specific and default PV to the EPICS database. For some/most slaves also a default\nauthor Anders Sandstrom\n paramters HW_DESC Hardware descriptor, i.e. KL2032\nSLAVE_ID EtherCAT bus position of the BK1250 (or similar terminal)\nSLAVE_ID_KL KL-Bus index in two digit hex starting at zero for the first slave after BK1250 (or similar terminal)\nSUBST_FILE (optional) substitution file\n Example calls:\n${SCRIPTEXEC} ${ecmccfg_DIR}addSlave.cmd, \u0026#34;HW_DESC=EL1018, SLAVE_ID=1, SLAVE_ID_KL=0A\u0026#34; "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/scripts/addvirtualaxis/","title":"addVirtualAxis.cmd","tags":[],"description":"","content":"author Niko Kivel\n "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/scripts/applyaxissynchronization/","title":"applyAxisSynchronization.cmd","tags":[],"description":"","content":"description Script for applying axis synchronization\ndetails Adds synchronization parameters to an axis provided by CONFIG.\nauthor Niko Kivel\n paramters CONFIG configuration file, i.e. ./cfg/linear_1.sax\nCLEAR_VARS_CMD (optional) Set to \u0026ldquo;empty\u0026rdquo; for not clear env vars (if needed vars for later use).\n Example call:\n${SCRIPTEXEC} ${ecmccfg_DIR}applyAxisSynchronization.cmd, \u0026#34;CONFIG=./cfg/linear_1.sax\u0026#34; "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/scripts/applyconfig/","title":"applyConfig.cmd","tags":[],"description":"","content":"author Niko Kivel\n Example call:\n${SCRIPTEXEC} ${ecmccfg_DIR}applyConfig.cfg "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/scripts/applyslaveconfig/","title":"applySlaveConfig.cmd","tags":[],"description":"","content":"author Niko Kivel\n Example call:\ncall applySlaveConfig with CONFIG\n${SCRIPTEXEC} ${ecmccfg_DIR}applySlaveConfig.cmd, \u0026#34;CONFIG=-Motor-Nanotec-ST4118L1804-B\u0026#34; call applySlaveConfig with LOCAL_CONFIG\n${SCRIPTEXEC} ${ecmccfg_DIR}applySlaveConfig.cmd, \u0026#34;LOCAL_CONFIG=./myFancyServoConfig.cfg\u0026#34; "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/scripts/applyslavedcconfig/","title":"applySlaveDCconfig.cmd","tags":[],"description":"","content":"author Anders Sandstroem\n "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/scripts/applysubstitutions/","title":"applySubstitutions.cmd","tags":[],"description":"","content":"description Script for applying substitution file\ndetails Applies substitution from ${SUBST_FILE} with ${P_SCRIPT}\nauthor Niko Kivel\n paramters SUBST_FILE (optional) substitution file\nECMC_P PV prefix\nP_SCRIPT (optional) naming convention prefix script\nNELM (optional) Used for oversampling cards. Defaults to 1\n Example calls:\n call w/o SLAVE_ID  ${SCRIPTEXEC} \u0026#34;${ECMC_CONFIG_ROOT}applySubstitutions.cmd\u0026#34; \u0026#34;SUBST_FILE=${SUBST_FILE=ecmc${ECMC_EC_HWTYPE}.substitutions},ECMC_P=${ECMC_P}\u0026#34; "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/scripts/applytemplate/","title":"applyTemplate.cmd","tags":[],"description":"","content":"description Script for applying a template\ndetails Applies template from ${TEMPLATE_FILE} with ${P_SCRIPT}, PARAMS can be passed\nauthor Niko Kivel\n paramters TEMPLATE_FILE template file\nECMC_P PV prefix\nPARAMS (optional) additional parameters\n Example calls:\n call w/o SLAVE_ID  ${SCRIPTEXEC} \u0026#34;${ECMC_CONFIG_ROOT}applyTemplate.cmd\u0026#34; \u0026#34;TEMPLATE_FILE=ecmcEcSlave.template,ECMC_P=${ECMC_P}\u0026#34; "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/general/chkoversampfactordie/","title":"chkOverSampFactOrDie.cmd","tags":[],"description":"","content":"author Anders Sandstroem\n "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/general/chkoversamptimeordie/","title":"chkOverSampTimeOrDie.cmd","tags":[],"description":"","content":"author Anders Sandstroem\n "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/general/chkvalidcurrentsetordie/","title":"chkValidCurrentSetOrDie.cmd","tags":[],"description":"","content":"author Anders Sandstroem\n "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/scripts/configureaxis/","title":"configureAxis.cmd","tags":[],"description":"","content":"description Script for adding an axis with configuration.\ndetails Adds an axis to the configuration and applies parameters provided by CONFIG.\nauthor Niko Kivel\n paramters CONFIG configuration file, i.e. ./cfg/linear_1.pax\nDEV (optional) device name, i.e. MOTOR1\nCLEAR_VARS_CMD (optional) Set to \u0026ldquo;empty\u0026rdquo; for not clear env vars (if vars needed for later use).\nCFG_MACROS (optional) Substitution macros for config file\n Example call:\n${SCRIPTEXEC} ${ecmccfg_DIR}configureAxis.cmd, \u0026#34;CONFIG=./cfg/linear_1.pax\u0026#34; "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/scripts/configureslave/","title":"configureSlave.cmd","tags":[],"description":"","content":"description Script for adding a slave with dedicated slave configuration to the EtherCAT bus configuration.\ndetails Adds the respective hardware to the bus configuration, adds specific and default PV to the EPICS database. Applies a specific slave configuration.\nauthor Niko Kivel\n paramters HW_DESC Hardware descriptor, i.e. EL7037\nCONFIG configuration file, i.e. -Motor-Nanotec-ST4118L1804-B\n The CONFIG together with the HW_DESC form the full filename which by definition is ecmc${HW_DESC}${CONFIG}.cmd, i.e.: ecmcEL7037-Motor-Nanotec-ST4118L1804-B.cmd\nparamters SLAVE_ID (optional) bus position\nCFG_MACROS (optional) Substitution macros for config file\nNELM (optional) Used for oversampling cards. Defaults to 1\n Example calls:\n call w/o SLAVE_ID  ${SCRIPTEXEC} ${ecmccfg_DIR}configureSlave.cmd, \u0026#34;HW_DESC=EL7037, CONFIG=-Motor-Nanotec-ST4118L1804-B\u0026#34;  call w/ SLAVE_ID  ${SCRIPTEXEC} ${ecmccfg_DIR}configureSlave.cmd, \u0026#34;HW_DESC=EL7037, CONFIG=-Motor-Nanotec-ST4118L1804-B, SLAVE_ID=8\u0026#34; "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/scripts/configurevirtualaxis/","title":"configureVirtualAxis.cmd","tags":[],"description":"","content":"description Script for adding a virtual axis with configuration.\ndetails Adds a virtual axis to the configuration and applies parameters provided by CONFIG.\nauthor Niko Kivel\n paramters CONFIG configuration file, i.e. ./cfg/linear_11.vax\nDEV (optional) device name, i.e. GAP\nCLEAR_VARS_CMD (optional) Set to \u0026ldquo;empty\u0026rdquo; for not clear env vars (if needed vars for later use).\n Example call:\n${SCRIPTEXEC} ${ecmccfg_DIR}configureVirtualAxis.cmd, \u0026#34;CONFIG=./cfg/linear_11.vax\u0026#34; "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/motion/ecmc_axis-records/","title":"ecmc_axis-records.cmd","tags":[],"description":"","content":"description Script for adding axis related EPICS PVs.\ndetails Adds motorRecord to the IOC.\nauthor Anders Sandstroem\n This script is typically called by \\b addAxis.cmd\n"},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/motion/ecmc_axis/","title":"ecmc_axis.cmd","tags":[],"description":"","content":"description Script for configuring a physical axis.\ndetails Configures a physical axis in ECMC, based on previously set environment variables.\nauthor Anders Sandstroem\n This script is typically called by \\b addAxis.cmd, often via \\b ecmc_axis-records.cmd\n"},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/motion/ecmc_axis_diag/","title":"ecmc_axis_diag.cmd","tags":[],"description":"","content":"description Script for adding axis diagnostic EPICS PVs.\ndetails Adds diagnostic PVs to the IOC.\nauthor Anders Sandstroem\n "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/motion/ecmc_axis_mr/","title":"ecmc_axis_mr.cmd","tags":[],"description":"","content":"author Anders Sandstroem\n This script is typically called by \\b ecmc_axis.cmd, often via \\b ecmc_axis-records.cmd\n"},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/motion/ecmc_axis_sync/","title":"ecmc_axis_sync.cmd","tags":[],"description":"","content":"description Script for configuring axis synchronization\ndetails Configures ECMC for axis synchronization, based on previously set environment variables.\nauthor Anders Sandstroem\n This script is typically called by \\b applyAxisSynchronization.cmd\n"},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/motion/ecmc_virt_axis-records/","title":"ecmc_virt_axis-records.cmd","tags":[],"description":"","content":"description Script for adding axis related EPICS PVs.\ndetails Adds motorRecord to the IOC.\nauthor Anders Sandstroem\n This script is typically called by \\b addVirtualAxis.cmd\n"},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/motion/ecmc_virt_axis/","title":"ecmc_virt_axis.cmd","tags":[],"description":"","content":"description Script for configuring a virtual axis.\ndetails Configures a virtual axis in ECMC, based on previously set environment variables.\nauthor Anders Sandstroem\n This script is typically called by \\b addVirtualAxis.cmd, often via \\b ecmc_virt_axis-records.cmd\n"},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/","title":"ecmccfg","tags":[],"description":"","content":"ecmccfg A configuration framework for ECMC Motion Control Module for EPICS.\nLicense  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 3 of the License, or (at your option) any later version.\nThis program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.\nYou should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\nLatest release \nDownload \n"},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/naming/ecmcclassicnaming/","title":"ecmcClassicNaming.cmd","tags":[],"description":"","content":"description Script for defining ${ECMC_PREFIX}\ndetails Gathers relevant information about MasterID, SlaveID, \u0026hellip; to create naming convention compliant PREFIX\nauthor Niko Kivel\n "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/naming/ecmcmxsxxx/","title":"ecmcmXsXXX.cmd","tags":[],"description":"","content":"description Script for defining ${ECMC_P}\ndetails Gathers relevant information about MasterID, SlaveID, \u0026hellip; to create naming convention compliant PREFIX\nauthor Niko Kivel\n "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/general/","title":"general","tags":[],"description":"","content":"  chkOverSampFactOrDie.cmd   chkOverSampTimeOrDie.cmd   chkValidCurrentSetOrDie.cmd   general.cmd   generalDiagnostics.cmd   init.cmd   initAll.cmd   initAxis.cmd   issueWarning.cmd   verifyOrDie.cmd   "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/general/general/","title":"general.cmd","tags":[],"description":"","content":"author Niko Kivel, Anders Sandstroem\n "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/general/generaldiagnostics/","title":"generalDiagnostics.cmd","tags":[],"description":"","content":"author Niko Kivel, Anders Sandstroem\n "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/general/init/","title":"init.cmd","tags":[],"description":"","content":"author Niko Kivel, Anders Sandstroem\n "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/general/initall/","title":"initAll.cmd","tags":[],"description":"","content":"author Niko Kivel, Anders Sandstroem\n "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/general/initaxis/","title":"initAxis.cmd","tags":[],"description":"","content":"author Niko Kivel, Anders Sandstroem\n "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/general/issuewarning/","title":"issueWarning.cmd","tags":[],"description":"","content":"author Anders Sandstroem\n "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/scripts/jinja2/","title":"jinja2","tags":[],"description":"","content":"  addAxisYaml.cmd   loadYamlPlc.cmd   "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/scripts/loadplcfile/","title":"loadPLCFile.cmd","tags":[],"description":"","content":"description Script for adding a PLC from file.\ndetails Adds a PLC defined in FILE. Also adds PLC specific EPICS PVs, i.e. for enable/disable.\nauthor Niko Kivel\n paramters FILE PLC definition file, i.e. ./plc/homeSlit.plc\nPLC_ID (optional) PLC number, default 0\nSAMPLE_RATE_MS (optional) excecution rate, default 1000/EC_RATE\nPLC_MACROS (optional) Substitution macros for PLC code\nTMP_PATH (optional) directory to dump the temporary plc file after macro substitution\nPRINT_PLC_FILE (optional) 1/0, printout msi parsed plc file (default enable(1)).\nSUBST_FILE (optional) custom substitution file otherwise ecmccfg default will be loaded\n Example call:\n${SCRIPTEXEC} ${ecmccfg_DIR}loadPLCFile.cmd, \u0026#34;PLC_ID=0, FILE=./plc/homeSlit.plc, SAMPLE_RATE_MS=100\u0026#34; "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/scripts/loadplugin/","title":"loadPlugin.cmd","tags":[],"description":"","content":"author Anders Sandstr√∂m\n paramters FILE Filename of plugin shared lib (./ecmcPlugin_Advanced.so)\nPLUGIN_ID Id of plugin to load\nCONFIG (optional) Configuration string sent to plugin at construct\nREPORT (optional) Printout information of loaded plugin if set to \u0026ldquo;1\u0026rdquo;\n Example call:\n${SCRIPTEXEC} ${ecmccfg_DIR}loadPlugin.cmd, \u0026#34;PLUGIN_ID=0,FILE=./ecmcPlugin_Advanced.so,CONFIG=\u0026#39;PLUGIN CONFIGS GO HERE \u0026#39; "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/scripts/jinja2/loadyamlplc/","title":"loadYamlPlc.cmd","tags":[],"description":"","content":"description Script for loading PLC from yaml file via jinja2\ndetails adds a PLC, line by line, from a yaml-file, parsed by jinja2\nauthor Niko Kivel\n paramters FILE the yaml-file containing the PLC definition\n Example calls:\n call  ${SCRIPTEXEC} \u0026#34;./loadYamlPlc.cmd\u0026#34; \u0026#34;FILE=./plc1.yaml\u0026#34; "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/motion/","title":"motion","tags":[],"description":"","content":"  ecmc_axis-records.cmd   ecmc_axis.cmd   ecmc_axis_diag.cmd   ecmc_axis_mr.cmd   ecmc_axis_sync.cmd   ecmc_virt_axis-records.cmd   ecmc_virt_axis.cmd            "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/naming/","title":"naming","tags":[],"description":"","content":"  ecmcClassicNaming.cmd   ecmcmXsXXX.cmd   "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/scripts/","title":"scripts","tags":[],"description":"","content":"  addAxis.cmd   addDataStorage.cmd   addMaster.cmd   addSlave.cmd   addSlaveKL.cmd   addVirtualAxis.cmd   applyAxisSynchronization.cmd   applyConfig.cmd   applySlaveConfig.cmd   applySlaveDCconfig.cmd   applySubstitutions.cmd   applyTemplate.cmd   configureAxis.cmd   configureSlave.cmd   configureVirtualAxis.cmd   jinja2   loadPLCFile.cmd   loadPlugin.cmd   setAppMode.cmd   setDiagnostics.cmd   slaveVerify.cmd      "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/scripts/setappmode/","title":"setAppMode.cmd","tags":[],"description":"","content":"author Niko Kivel\n "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/scripts/setdiagnostics/","title":"setDiagnostics.cmd","tags":[],"description":"","content":"author Niko Kivel\n "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/scripts/slaveverify/","title":"slaveVerify.cmd","tags":[],"description":"","content":"description ** script for slave verification and optional reset**\ndetails will verify the slave identity and reset by writing to 0x1011\nauthor Niko Kivel\n Macros\n"},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/","title":"source","tags":[],"description":"","content":"  general   motion   naming   scripts      "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/general/verifyordie/","title":"verifyOrDie.cmd","tags":[],"description":"","content":"author Anders Sandstroem\n "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/manual/introduction/","title":"introduction","tags":[],"description":"","content":"principle EtherCAT requires the field bus components (slaves) to be configured on the master. The master must know about the data exchanges with the slaves, this is referred to as process image.\nIOC structure The startup script has several steps:\n require ecmccfg configure the slaves on the EtherCAT bus  additional configuration adding a physical motor axis adding a virtual motor axis adding synchronization loading a PLC from file   apply the configuration go active  require ecmccfg require ecmccfg \u0026lt;VERSION\u0026gt; slave configuration Each slave on the field bus must be configured for use with ECMC. For this purpose scripts can be called for:\n adding slaves with default configuration adding and configure while adding applying a configuration to the previously added slaves  examples The addSlave is used for simple slaves, a default configuration is automatically applied. In addition default PVs will created for the basic slave features, i.e. status. Most slaves also have PVs created matching the purpose, i.e. inputs will have bi records, outputs will have bo records for each channel. This behaviour can be modified by arguments.\n  add a coupler and slaves\n# slave 0 {ecmcEK1100} ${SCRIPTEXEC} ${ECMC_CONFIG_ROOT}addSlave.cmd, \u0026#34;HW_DESC=EK1100\u0026#34; # SLAVE_ID is automatically incremented # slave 1 {ecmcEL1018} ${SCRIPTEXEC} ${ECMC_CONFIG_ROOT}addSlave.cmd, \u0026#34;HW_DESC=EL1018\u0026#34; # skip slaves 2..6 # slave 7 {ecmcEL2008}, with optional SLAVE_ID ${SCRIPTEXEC} ${ECMC_CONFIG_ROOT}addSlave.cmd, \u0026#34;HW_DESC=EL2008, SLAVE_ID=7\u0026#34; # slave 9 {ecmcEL2008}, with optional SLAVE_ID and P_SCRIPT ${SCRIPTEXEC} ${ECMC_CONFIG_ROOT}addSlave.cmd, \u0026#34;HW_DESC=EL2008, SLAVE_ID=7, P_SCRIPT=mXsXXX\u0026#34; # slave 10 {ecmcEL3204}, without any of the default PVs ${SCRIPTEXEC} ${ECMC_CONFIG_ROOT}addSlave.cmd, \u0026#34;HW_DESC=EL3204, DEFAULT_SUBS=false, DEFAULT_SLAVE_PVS=true\u0026#34;   add more slaves and apply configuration to the slaves\n# slave 8 {ecmcEL7037}, configure slave with optional SLAVE_ID ${SCRIPTEXEC} ${ECMC_CONFIG_ROOT}configureSlave.cmd, \u0026#34;HW_DESC=EL7037, CONFIG=-Motor-Nanotec-ST4118L1804-B, SLAVE_ID=8\u0026#34; # slave 9 {ecmcEL7037}, addSlave, with immediate call off applySlaveConfig # slave with global configuration ${SCRIPTEXEC} ${ECMC_CONFIG_ROOT}addSlave.cmd, \u0026#34;HW_DESC=EL7037\u0026#34; ${SCRIPTEXEC} ${ECMC_CONFIG_ROOT}applySlaveConfig, \u0026#34;CONFIG=-Motor-Nanotec-ST4118L1804-B\u0026#34; # slave with local configuration, in this case provided by the module `ECMC_AGIR` epicsEnvSet(\u0026#34;CFG_ROOT\u0026#34;, \u0026#34;${ECMC_AGIR_DIR}/\u0026#34;) ${SCRIPTEXEC} ${ECMC_CONFIG_ROOT}addSlave.cmd, \u0026#34;HW_DESC=EP7211-0034_ALL\u0026#34; ${SCRIPTEXEC} ${ECMC_CONFIG_ROOT}applySlaveConfig.cmd, \u0026#34;LOCAL_CONFIG=${CFG_ROOT}AM8211_AGIR.cfg\u0026#34;   apply the configuration The configured process image is applied to the master\n${SCRIPTEXEC} ${ECMC_CONFIG_ROOT}applyConfig.cmd additional configuration Optionally, manual modifications can be made to the default configuration.\nIn order to manually set binaryOutput01 to 1 at startup, the following can be added to the startup script.\necmcConfigOrDie \u0026#34;Cfg.WriteEcEntryIDString(${ECMC_EC_SLAVE_NUM_DIG_OUT},binaryOutput01,1)\u0026#34; adding a physical motor axis Axis configuration will is explained in details here.\n classic config  epicsEnvSet(\u0026#34;DEV\u0026#34;, \u0026#34;STEST-MYDEVICE\u0026#34;) ${SCRIPTEXEC} ${ECMC_CONFIG_ROOT}configureAxis.cmd, \u0026#34;CONFIG=./cfg/axis_1\u0026#34;  yaml config  ${SCRIPTEXEC} ${ECMC_CONFIG_ROOT}addAxisYaml.cmd, \u0026#34;FILE=./AM8111_CSV_minimum.yaml, ECMC_TMPDIR=/tmp/\u0026#34; adding a virtual motor axis ${SCRIPTEXEC} ${ecmccfg_DIR}configureVirtualAxis.cmd, \u0026#34;CONFIG=./cfg/axis_11_virt\u0026#34; adding synchronization ${SCRIPTEXEC} ${ecmccfg_DIR}applyAxisSynchronization.cmd, \u0026#34;CONFIG=./cfg/axis_1_sync\u0026#34; ${SCRIPTEXEC} ${ecmccfg_DIR}applyAxisSynchronization.cmd, \u0026#34;CONFIG=./cfg/axis_11_sync\u0026#34; loading a PLC from file The PLC functionionality is exmplained in detail here. ECMC PLCs can be loaded from classical PLC files, from pure yaml files or from a yaml/PLC hybrid.\n classic PLC-file  ${SCRIPTEXEC} ${ecmccfg_DIR}loadPLCFile.cmd, \u0026#34;PLC_ID=0, FILE=./plc/homeSlit.plc, SAMPLE_RATE_MS=100\u0026#34;  pure yaml based PLC  ${SCRIPTEXEC} \u0026#34;${ECMC_CONFIG_ROOT}loadYamlPlc.cmd\u0026#34; \u0026#34;FILE=./plc1.yaml, ECMC_TMPDIR=/tmp/\u0026#34;  yaml definition, with classic PLC-file, Note: file key in yaml config will overwrite anything in the code key!  ${SCRIPTEXEC} \u0026#34;${ECMC_CONFIG_ROOT}loadYamlPlc.cmd\u0026#34; \u0026#34;FILE=./plc1File.yaml, ECMC_TMPDIR=/tmp/\u0026#34; go active ${SCRIPTEXEC} ${ecmccfg_DIR}setAppMode.cmd "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/manual/axis/","title":"axis","tags":[],"description":"","content":"axis ECMC has two types of axes, (1) physical axes, aka joints, and (2) virtual axes, aka end effector. Both types are classes in ECMC, the physical axis is a super-set of the virtual axes, as the latter lacks the hardware.\nYAML config Since v7, axes can be configured with yaml-files. This is a huge improvement over the classic configuration based on EPICS environment variables. For backward compatibility the classical configuration is still supported.\n"},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/manual/axis/axisyaml/","title":"axis yaml configuration","tags":[],"description":"","content":"Since ecmccfg v7, the axis configuration is based on yaml files. Backwards compatibility for classic EPICS environment variable based configuration is assured for legacy systems.\n yaml is - like python - indentation sensitive!\n Indent with 2 spaces.\n introduction The config is processed by jinja2, the processor will complain if mandatory keys are missing. Likewise, missing optional keys are populated with default values.\nThe scripts invoking the jinja2 processor will create a python virtual environment and install the required libraries.\n The configuration is separated into the following mandatory sections:\n axis motorRecord drive encoder controller trajectory input  in addition the following optional sections are available.\n output homing monitoring  Each sections provides an example, the optional keys are commented.\n axis mandatory\n id: unique numeric identifier of the axis  optional\n type: for future used mode: operating mode of the drive; default CSV parameters: additional parameters  axis: id: 1 # type: joint # this is for future selection of axis type # mode: CSV # supported mode, CSV and CSP; WIP # parameters: powerAutoOnOff=2;powerOnDelay=6.0;powerOffDelay=1.0; motorRecord Epics motorRecord field configuration.\nmandatory\n name: name of the PV  optional\n precision: PREC field; default 3 description: DESC field; default '' unit: EGU field; optional default mm fieldInit: string with additional field initial values; default ''  motorRecord: name: M1 # precision: 3 # description: AM8111 CSV # unit: deg # fieldInit: RRES=1.0,RTRY=2,RMOD=1,UEIP=0,RDBD=0.1,URIP=1,RDBL=$(IOC):$(ECMC_MOTOR_NAME)-PosActSim drive mandatory\n numerator: scaling numerator denominator: scaling denominator type: type of drive: 0=stepper, 1=DS402, aka servo or complex stepper control: control word entry status: status word entry setpoint: setpoint entry, position or velocity, depending on mode  optional\n reduceTorque: control word bit to set for reduced torque mode brake  openDelay: number of cycles to wait after enable to disengage the brake closeAhead: number of cycles to wait after the brake was engaged   reset: control word bit to set in order to reset the drive warning: status word bit for drive warning error: list of status bits for drive errors  drive: numerator: 2880000 # Fastest speed in engineering units denominator: 2147483648 # I/O range for ECMC_EC_ALIAS_DRV_VELO_SET type: 1 # Stepper: 0, DS402: 1 (DS402 = servos and advanced stepper drives) control: ec0.s$(DRV_SLAVE).driveControl01 status: ec0.s$(DRV_SLAVE).driveStatus01 setpoint: ec0.s$(DRV_SLAVE).velocitySetpoint01 # reduceTorque: 2 # Reduce torque bit in drive control word # brake: # openDelay: 0 # Brake timing parameter in EtherCAT cycles # closeAhead: 0 # Brake timing parameter in EtherCAT cycles # reset: 1 # Reset bit in control word # warning: 2 # Warning bit of status word # error: # max 3 # - 3 # Error 0 bit of status word # - 7 # Error 1 bit of status word # - 14 # Error 2 bit of status word encoder mandatory\n numerator: scaling numerator denominator: scaling denominator type: type of encoder: 0=incremental, 1=absolute bits: raw data bit count absBits: 25 # Absolute bit count (for absolute encoders) always least significant part of \u0026lsquo;bits\u0026rsquo; absOffset: 0 # Encoder offset in engineering units (for absolute encoders) position: position entry  optional\n control: control word entry; mandatory when reset is set. status: status word entry; mandatory when error or warning are set reset: control word bit to set in order to reset the encoder warning: status word bit for encoder warning error: list of status bits for encoder errors velocityFilterSize: size of the velocity filter (cycles) positionFilterSize: size of the position filter (cycles) positionFilterEnable: position filter enable latch:  position: '' control: '' status: ''    encoder: numerator: 360 denominator: 1048576 type: 1 # Type: 0=Incremental, 1=Absolute bits: 32 # Total bit count of encoder raw data absBits: 25 # Absolute bit count (for absolute encoders) always least significant part of \u0026#39;bits\u0026#39; absOffset: 0 # Encoder offset in eng units (for absolute encoders) position: ec0.s$(DRV_SLAVE).positionActual01  # Ethercat entry for actual position input (encoder) # control: ec0.s$(ENC_SLAVE).encoderControl01 # mandatory only if \u0026#39;reset\u0026#39; is used # status: ec0.s$(DRV_SLAVE).encoderStatus01 # mandatory only if \u0026#39;warning\u0026#39; or \u0026#39;error\u0026#39; are used # reset: 1 # Reset (optional) # warning: 2 # Warning (optional) # error: # max 3 (optional) # - 5 # Error 0 # - 9 # Error 1 # - 11 # Error 2 # velocityFilterSize: 100 # positionFilterSize: 1 # positionFilterEnable: false # latch: # position: \u0026#39;\u0026#39; # control: \u0026#39;\u0026#39; # status: \u0026#39;\u0026#39; controller PID controller parameters\nmandatory\n Kp: proportional  optional\n Ki: integral; default 0 Kd: differential; default 0 Kff: feed forward; default 1  controller: Kp: 90 # Ki: 0.1 # Kd: 0 # Kff: 1 trajectory settings for the trajectory planning.\nmandatory\n axis  velocity: velocity setpoint the axis will be initialized to acceleration: acceleration setpoint for initialization emergencyDeceleration: deceleration setpoint for emergencies. Defaults to acceleration setpoint if not specified.    optional\n jog  velocity: velocity setpoint the axis will be initialized to for jogging acceleration: acceleration setpoint for initialization, for jogging   modulo  range: modulo range type: modulo type    trajectory: axis: velocity: 180 acceleration: 0.1 # emergencyDeceleration: 0.05 # jog: # velocity: 90 # acceleration: 0.1 # modulo: # range: 0 # type: 0 input Links to the binary input sensors for limit switches, home sensor and external interlock. All four inputs must be provided. If an input is not used, set it to the ONE.0 entry of a slave. See the example for details.\nmandatory\n limit  forward: limit switch sensor input in the forward direction. backward: limit switch sensor input in the backward direction.   home: binary input for the home sensor extinterlock: binary input for external interlock.  input: limit: forward: ec0.s$(DRV_SLAVE).ONE.0  # Ethercat entry for low limit switch input backward: ec0.s$(DRV_SLAVE).ONE.0  # Ethercat entry for high limit switch input home: ec0.s$(DRV_SLAVE).ONE.0  # Ethercat entry for home switch input interlock: ec0.s$(DRV_SLAVE).ONE.0  # Ethercat entry for interlock switch input output Two outputs can be utilizes with ECMC.\noptional\n health: sum parameter for axis health brake: brake output  # output: # health: \u0026#39;\u0026#39; # Ethercat entry for health output # brake: \u0026#39;ec0.s42.binaryOutput07\u0026#39; # Ethercat entry for brake output homing This section is should be obsolete at PSI, as for all new installation using EtherCAT, absoulte encoders are mandatory. In case a legacy system or temporary installation requires a incremental encoder, or even open loop operation, several procedures for referencing are available.\noptional\n type: referencing procedure position: position of the refernce mark in engineering units velocity: velocities  to: to the cam from: off the cam   acceleration: acceleration time in s deceleration: deceleration time in s  # homing: # type: 3 # position: 0 # velocity: # to: 2.72 # from: 3.14 # acceleration: 2 # deceleration: 5 softlimits Soft limits to propagate to the motorRecord.\noptional\n enable: enable soft limits. forward: soft limit in the forward direction backward: soft limit in the backward direction  # softlimits: # enable: false # forward: \u0026#39;\u0026#39; # backward: \u0026#39;\u0026#39; monitoring Three entities can be monitored, (1) lag, aka following error, (2) target, aka in position, (3) velocity.\noptional\n lag  enable: enable lag monitoring tollerance: tollerance in engineering units time: time for the condition to be true in ms   target  enable: enable target monitoring tollerance: tollerance in engineering units time: time for the condition to be true in ms   velocity  enable: enable velocity monitoring max: upper limit for velocity time  trajectory: time for the condition to be in violation in ms drive: time for the condition to be in violation in ms      monitoring: # lag: # enable: false # tollerance: 5 # time: 100 # target: # enable: true # tollerance: 0.125 # time: 100 # velocity: # enable: false # max: 100 # time: # trajectory: 100 # drive: 200 "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/manual/plc/","title":"PLC","tags":[],"description":"","content":"In ECMC, PLCs are a very powerful tool to handle EtherCAT data in real-time.\nSince ecmccfg v7, the PLCs can be instantiated from:\n pure yaml files or text files, with yaml header.  Backwards compatibility for classic, text based PLCs is assured.\n yaml is - like python - indentation sensitive!\n Indent with 2 spaces.\n pure yaml All keys are mandatory.\n id: PLC id, unique uint enable: PLC enabled at start rateMilliseconds: execution rate in ms. To execute every cycle, independant of cycle rate, use -1. code: dictionary of code lines.  Line terminator is still a pipe |, this is subject to change!\n For more complex PLCs, it is highly advisable to use text based PLC definitions with a yaml header.\n plc: id: 1 enable: no rateMilliseconds: 10 code: - \u0026#39;ec0.s2.binaryOutput07:=global.test|\u0026#39; - \u0026#39;${PLC_ID}.enable:=plc0.enable|\u0026#39; - \u0026#39;ec0.s2.binaryOutput05:=not(ec0.s2.binaryOutput05)|\u0026#39; - \u0026#39;plc1.error:=12345|\u0026#39; yaml header Instead of the code dictionary, the file key can be used to load the PLC from a text file. The syntax of the text PLCs is kept from earlier versions.\nAll keys are mandatory.\n id: PLC id, unique uint enable: PLC enabled at start rateMilliseconds: execution rate in ms. To execute every cycle, independant of cycle rate, use -1. file: PLC text file to load.  If the file key is set, all definitions in the code dictionary are overwritten.\n  yaml header\n plc: id: 1 enable: yes rateMilliseconds: 10 file: plc1.plc  PLC file\n # this is a comment println(\u0026#39;plc1 from file\u0026#39;); println(\u0026#39;plc1 from file # hash with inline comment\u0026#39;); # inline test static.i:=static.i+1; # counter println(\u0026#39;i = # + - * / \u0026#39;, static.i); # println  iocsh call\n ${SCRIPTEXEC} \u0026#34;${ECMC_CONFIG_ROOT}loadYamlPlc.cmd\u0026#34; \u0026#34;FILE=./plc1File.yaml, ECMC_TMPDIR=/tmp/\u0026#34; "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/manual/plc/plcsyntax/","title":"PLC syntax help","tags":[],"description":"","content":"In ECMC, PLCs are based on the exprtk expression evaluation library. For detailed syntax help please visit the exprtk website\ncommon errors, misconceptions and info operators  :=: assignment = or ==: equal comparison  functions PLC do not immediately write to the bus! The PLC will excecute synchronous to the cycle, or at an integer fraction of it. The prcessed data will be send to the bus with the next cycle. PLCs do not delay the bus!\nstatement terminator Statements are terminated by a semicolon ;\nvariables All variables are initiated to 0\ncomments The hash charactoer # is reserved for comments. Everything after this char will be removed before compile. println('########'); will be seen by the compiler as println(' !\n macros So far macro substitution is not implemented for yaml!\n If macro substitution is needed, please use the traditional approach using loadPLCFile.cmd, with the PLC_MACROS variable.\n examples PLC can access:\n variables process data axis PLCs data storage  Function examples are given at the end.\ngeneral # # 1. Assignment: # ec0.s1.VALUE:=100; # # 2. if-else (note the equl sign): # if(ec0.s1.VALUE=100) { # # code # } # else { # # code # }; # # 3. for loop: # for (static.i := 0; static.i \u0026lt; static.elements; static.i += 1) { # # code # }; # # 4. printouts (minimize printouts or use only for debug): # print(\u0026#34;The value of ec0.s1.VALUE is: \u0026#34;,ec0.s1.VALUE); # Without line feed # println(\u0026#34;The value of ec0.s1.VALUE is: \u0026#34;,ec0.s1.VALUE); # With line feed # # Also see the \u0026#34;ec_print_bin()\u0026#34; and \u0026#34;ec_print_hex()\u0026#34; below. variables Below the ECMC specific accessible variables and functions are listed:\n# 1. static.\u0026lt;varname\u0026gt; Static variable. Initiated to 0. (rw)  # Access only in the PLC where defined. # Will keep value between execution # loops. # 2. global.\u0026lt;varname\u0026gt; Global variable. Initiated to 0. (rw) # Access from all PLCs. # Will keep value between execution # loops. # 3. var \u0026lt;varname\u0026gt; Local variable (exprtk syntax) (rw) # Will NOT keep value between # execution loops. process data # EtherCAT data: # 1. ec\u0026lt;ecid\u0026gt;.s\u0026lt;sid\u0026gt;.\u0026lt;alias\u0026gt; ethetcat data (rw) # ecid: ethercat master index # sid: ethercat slave bus position # alias: entry name as defined in # \u0026#34;Cfg.EcAddEntryComplete() # 2. ec\u0026lt;ecid\u0026gt;.masterstatus Status of master (1=OK) axis # Motion variables: # 1. ax\u0026lt;id\u0026gt;.id axis id (ro) # 2. ax\u0026lt;id\u0026gt;.reset reset axis error (rw) # 3. ax\u0026lt;id\u0026gt;.counter execution counter (ro) # 4. ax\u0026lt;id\u0026gt;.error error (ro) # 5. ax\u0026lt;id\u0026gt;.allowplccmd Allow writes to axis from PLC (rw) # 6. ax\u0026lt;id\u0026gt;.enc.actpos actual position (ro) # 7. ax\u0026lt;id\u0026gt;.enc.extactpos actual position from plc sync. # expression (ro) # 8. ax\u0026lt;id\u0026gt;.enc.actvel actual velocity (ro) # 9. ax\u0026lt;id\u0026gt;.enc.rawpos actual raw position (ro) # 10. ax\u0026lt;id\u0026gt;.enc.source internal source or expressions (rw) # source = 0: internal encoder # source \u0026gt; 0: actual pos from expr # 11. ax\u0026lt;id\u0026gt;.enc.homed encoder homed (rw) # 12. ax\u0026lt;id\u0026gt;.enc.homepos homing position (rw) # 13. ax\u0026lt;id\u0026gt;.traj.setpos curent trajectory setpoint (rw) # 14. ax\u0026lt;id\u0026gt;.traj.extsetpos current trajecrory setpoint from # plc sync. expression (ro) # 15. ax\u0026lt;id\u0026gt;.traj.targetpos target position (rw) # 16. ax\u0026lt;id\u0026gt;.traj.targetvel target velocity setpoint (rw) # 17. ax\u0026lt;id\u0026gt;.traj.targetacc target acceleration setpoint (rw) # 18. ax\u0026lt;id\u0026gt;.traj.targetdec target deceleration setpoint (rw) # 19. ax\u0026lt;id\u0026gt;.traj.setvel current velocity setpoint (ro) # 20. ax\u0026lt;id\u0026gt;.traj.setvelffraw feed forward raw velocity (ro) # 21. ax\u0026lt;id\u0026gt;.traj.command command (rw) # command=1: move velocity  # command=2: move rel. pos # command=3: move abs. pos # command=10: homing # 22. ax\u0026lt;id\u0026gt;.traj.cmddata cmddat. Homing procedure # only valid if ax\u0026lt;id\u0026gt;.traj.command=10 # cmddata=1 : ref low limit # cmddata=2 : ref high limit # cmddata=3 : ref home sensor # (via low limit) # cmddata=4 : ref home sensor # (via high limit) # cmddata=5 : ref center of home sensor # (via low limit) # cmddata=6 : ref center of home sensor # (via high limit) # cmddata=15 : direct homing # cmddata=21 : ref partly abs. encoder # (via low limit). # ref at abs bits. # over/under-flow.. # cmddata=22 : ref partly abs. encoder # (via high limit). # ref at abs bits. # over/under-flow.. # 23. ax\u0026lt;id\u0026gt;.traj.source internal source or expressions (rw) # source = 0: internal traj # source \u0026gt; 0: setpoints from expr # 24. ax\u0026lt;id\u0026gt;.traj.execute execute motion command (rw) # 25. ax\u0026lt;id\u0026gt;.traj.busy axis busy (ro) # 26. ax\u0026lt;id\u0026gt;.traj.dir axis setpoint direction (ro) # ax\u0026lt;id\u0026gt;.traj.dir\u0026gt;0: forward # ax\u0026lt;id\u0026gt;.traj.dir\u0026lt;0: backward # ax\u0026lt;id\u0026gt;.traj.dir=0: standstill # 27. ax\u0026lt;id\u0026gt;.cntrl.error actual controller error (ro) # 28. ax\u0026lt;id\u0026gt;.cntrl.poserror actual position error (ro) # 29. ax\u0026lt;id\u0026gt;.cntrl.output actual controller output (ro) # 30. ax\u0026lt;id\u0026gt;.drv.setvelraw actual raw velocity setpoint (ro) # 31. ax\u0026lt;id\u0026gt;.drv.enable enable drive command (rw) # 32. ax\u0026lt;id\u0026gt;.drv.enabled drive enabled (ro) # 33. ax\u0026lt;id\u0026gt;.seq.state sequence state (homing) (ro) # 34. ax\u0026lt;id\u0026gt;.mon.ilock motion interlock (both dir) (rw) # ax\u0026lt;id\u0026gt;.mon.ilock=1: motion allowed # ax\u0026lt;id\u0026gt;.mon.ilock=0: motion not allowed  # 35. ax\u0026lt;id\u0026gt;.mon.ilockbwd motion interlock bwd dir (rw) # ax\u0026lt;id\u0026gt;.mon.ilockbwd=1: motion allowed # ax\u0026lt;id\u0026gt;.mon.ilockbwd=0: motion not allowed  # 36. ax\u0026lt;id\u0026gt;.mon.ilockfwd motion interlock fwd dir (rw) # ax\u0026lt;id\u0026gt;.mon.ilockfwd=1: motion allowed # ax\u0026lt;id\u0026gt;.mon.ilockfwd=0: motion not allowed  # 37. ax\u0026lt;id\u0026gt;.mon.attarget axis at taget (ro) # 38. ax\u0026lt;id\u0026gt;.mon.lowlim low limit switch (ro) # 39. ax\u0026lt;id\u0026gt;.mon.highlim high limit switch (ro) # 40. ax\u0026lt;id\u0026gt;.mon.homesensor home sensor (ro) # 41. ax\u0026lt;id\u0026gt;.mon.lowsoftlim low soft limit (rw) # 42. ax\u0026lt;id\u0026gt;.mon.highsoftlim high soft limit (rw) # 43. ax\u0026lt;id\u0026gt;.mon.lowsoftlimenable low soft limit enable (rw) # 44. ax\u0026lt;id\u0026gt;.mon.highsoftlimenable high soft limit enable (rw) # 45. ax\u0026lt;id\u0026gt;.blockcom Enables/disables \u0026#34;set\u0026#34; commands (rw) # via command parser (ascii commands) # Statuses can still be read. # Exceptions (\u0026#34;set\u0026#34;-commands) that # will work: # - \u0026#34;StopMotion(axid)\u0026#34; # - \u0026#34;Cfg.SetAxisBlockCom(axid,block)\u0026#34; PLC # PLC variables: # 1. plc\u0026lt;id\u0026gt;.enable plc enable (rw) # (end exe with \u0026#34;plc\u0026lt;id\u0026gt;.enable:=0#\u0026#34; # Could be usefull for startup # sequences) # 2. plc\u0026lt;id\u0026gt;.error plc error (rw) # Will be forwarded to user as # controller error. # 3. plc\u0026lt;id\u0026gt;.scantime plc sample time in seconds (ro) # 4. plc\u0026lt;id\u0026gt;.firstscan true during first plc scan only (ro) # usefull for initiations of variables # 5. ax\u0026lt;id\u0026gt;.plc.enable Same as plc\u0026lt;id\u0026gt;.enable but for # axis \u0026lt;id\u0026gt; sync plc. # 6. ax\u0026lt;id\u0026gt;.plc.error Same as plc\u0026lt;id\u0026gt;.error but for # axis \u0026lt;id\u0026gt; sync plc. # 7. ax\u0026lt;id\u0026gt;.plc.scantime Same as plc\u0026lt;id\u0026gt;.scantime but for # axis\u0026lt;id\u0026gt; sync plc. # 8. ax\u0026lt;id\u0026gt;.plc.firstscan Same as plc\u0026lt;id\u0026gt;.firstscan but for # axis \u0026lt;id\u0026gt; sync plc. data storage # Data Storage variables: # 1. ds\u0026lt;id\u0026gt;.size Set/get size of data storage (rw) # Set will clear the data storage # 2. ds\u0026lt;id\u0026gt;.append Add new data at end (rw) # Current position index will be # increased # 3. ds\u0026lt;id\u0026gt;.data Set/get data ar current position (rw) # 4. ds\u0026lt;id\u0026gt;.index Set/get current position index (rw) # 5. ds\u0026lt;id\u0026gt;.error Data storage class error (ro) # 6. ds\u0026lt;id\u0026gt;.clear Data buffer clear (set to zero) (ro) # 7. ds\u0026lt;id\u0026gt;.full True if data storage is full (ro) functions # Function Lib: EtherCAT # 1. retvalue = ec_set_bit( # \u0026lt;value\u0026gt;, : Value to change # \u0026lt;bitindex\u0026gt; : Bit index # ); # Sets bit at bitindex position of value. Returns the new value. # # 2. retvalue = ec_wrt_bit( # \u0026lt;value\u0026gt;, : Value to change # \u0026lt;wrtValue\u0026gt;, : Value of bit to write # \u0026lt;bitindex\u0026gt; : Bit index # ); # Write wrtValue to a bit at bitindex position of value. Returns the new value. # # 3. retvalue = ec_wrt_bits( # \u0026lt;value\u0026gt;, : Value to change # \u0026lt;wrtValue\u0026gt;, : Value of bit to write # \u0026lt;startBit\u0026gt; : Start bit index (lsb is bit 0) # \u0026lt;stopBit\u0026gt; : Stop bit index # ); # Write wrtValue to a range of bits (statBit..stopBit) of value. Returns the new value. # # 4. retvalue = ec_clr_bit( # \u0026lt;value\u0026gt;, : Value to change # \u0026lt;bitindex\u0026gt; : Bit index # ); # Clears bit at bitindex position of value. Returns the new value. # # 5. retvalue = ec_flp_bit( # \u0026lt;value\u0026gt;, : Value to change # \u0026lt;bitindex\u0026gt; : Bit index # ); # Flips bit at bitindex position of value. Returns the new value. # # 6. retvalue = ec_chk_bit( # \u0026lt;value\u0026gt;, : Value to change # \u0026lt;bitindex\u0026gt; : Bit index # ); # Checks bit at bitindex position of value. Returns the value of bit. # # 7. retvalue = ec_chk_bits( # \u0026lt;value\u0026gt;, : Value to change # \u0026lt;startBit\u0026gt; : Start bit index (lsb is bit 0) # \u0026lt;stopBit\u0026gt; : Stop bit index # ); # Checks range of bits (startBit..stopBit) of value. Returns the value of bits. # # 8. retvalue = ec_print_hex( # \u0026lt;value\u0026gt;, : Value to print # \u0026lt;startBit\u0026gt; : Start bit index # \u0026lt;stopBit\u0026gt; : Stop bit index # ); # Prints \u0026lt;startBit\u0026gt; to \u0026lt;stopBit\u0026gt; of \u0026lt;value\u0026gt; in hex format # Returns error code or 0 if success.# # # 9. retvalue = ec_print_bin( # \u0026lt;value\u0026gt;, : Value to print # \u0026lt;startBit\u0026gt; : Start bit index # \u0026lt;stopBit\u0026gt; : Stop bit index # ); # Prints \u0026lt;startBit\u0026gt; to \u0026lt;stopBit\u0026gt; of \u0026lt;value\u0026gt; in bin format # Returns error code or 0 if success. # # 10. retvalue = ec_mm_cp( # \u0026lt;srcId\u0026gt;, : Source memmap index # \u0026lt;sdestId\u0026gt; : Dest memmap index # ); # Copies data from source memmap to dest memmap. The memmap ids are defined by the # order they are created (starting at 0). The smallest memmap size will define the # amout of data copied. Returns 0 for success or an error code. # # 11. retvalue = ec_get_mm_type( # \u0026lt;srcId\u0026gt;, : Source memmap index # ); # # Returns data type of memmap: # 0 = Not defined (Use \u0026#34;Cfg.EcAddMemMapDT()\u0026#34; instead of \u0026#34;Cfg.EcAddMemMap()\u0026#34;) # 1 = (Not valid for memmap) # 2 = (Not valid for memmap) # 3 = (Not valid for memmap) # 4 = (Not valid for memmap) # 5 = U8 # 6 = S8 # 7 = U16 # 8 = S16 # 9 = U32 # 10 = S32 # 11 = U64 # 12 = S64 # 13 = F32 # 14 = F64 # # 12. retvalue = ec_get_mm_data( # \u0026lt;srcId\u0026gt;, : Source memmap index # \u0026lt;index\u0026gt; : Index of data element # ); # # Reads data element at index from memmap with srcId and returns value. # # 13. retvalue = ec_set_mm_data( # \u0026lt;srcId\u0026gt;, : Source memmap index # \u0026lt;index\u0026gt; : Index of data element # \u0026lt;data\u0026gt; : Data to write # ); # # Writes data element at index from memmap with srcId. Returns 0 for success or an error code. # # 14. retvalue = ec_get_mm_size( # \u0026lt;srcId\u0026gt;, : Source memmap index # ); # # Returns number of elements (of type \u0026#34;ec_get_mm_type()\u0026#34;)in memmap with srcId. # If return value is less than zero it should be considered to be an error code. # # 14. retvalue = ec_mm_ds_append( # \u0026lt;mmId\u0026gt;, : Source memmap index # \u0026lt;dsId\u0026gt;); : Destination data storage index # # Returns Error code or zero if success # # 15. retvalue = ec_mm_append_to_ds_scale_offset( # \u0026lt;mmId\u0026gt;, : Source memmap index # \u0026lt;dsId\u0026gt; : Destination data storage index # \u0026lt;scale\u0026gt; : Scale # \u0026lt;offset\u0026gt;); : Offset # # 16. retvalue = ec_mm_push_asyn( # \u0026lt;mmId\u0026gt;) : Source memmap index. # # push memap to epics (can be used if T_SMP_MS=-1 for the param) # The mmId can be retrived by the bellow ecmc command (and feed into plc via macro): # ecmcConfig \u0026#34;EcGetMemMapId(ec0.s11.mm.CH1_ARRAY_IN)\u0026#34; # epicsEnvSet(MM_CH_1_IN,${ECMC_CONFIG_RETURN_VAL}) # # 17. retvalue = ec_get_time(); # # Returns current time in nano seconds (from 1 Jan 2000, same as EtherCAT DC:s). # If return value is less than zero it should be considered to be an error code. # # # 18. retvalue = ec_get_time_l32(); # # Returns lower 32 bits of current time in nano seconds (from 1 Jan 2000, same as EtherCAT DC:s). # If return value is less than zero it should be considered to be an error code. # # 19. retvalue = ec_get_time_u32(); # # Returns upper 32 bits of current time in nano seconds (from 1 Jan 2000, same as EtherCAT DC:s). # If return value is less than zero it should be considered to be an error code. # # 20. retvalue=ec_get_err(): # # Returns error code from last lib call. # # 21. retvalue=ec_err_rst(): # # Resets error code for ec_lib. # # Function Lib: Motion # 1. retvalue = mc_move_abs( # \u0026lt;axIndex\u0026gt;, : Axis index # \u0026lt;execute\u0026gt;, : Trigger # \u0026lt;pos\u0026gt;, : Target position # \u0026lt;vel\u0026gt;, : Target velocity # \u0026lt;acc\u0026gt;, : Acceleration # \u0026lt;dec\u0026gt; : Deceleration # ): # Absolute motion of axis. # Motion is triggerd with a positive edge on \u0026lt;execute\u0026gt; input. # returns 0 if success or error code. #  # 2. retvalue = mc_move_rel( # \u0026lt;axIndex\u0026gt;, : Axis index # \u0026lt;execute\u0026gt;, : Trigger # \u0026lt;pos\u0026gt;, : Target position # \u0026lt;vel\u0026gt;, : Target velocity # \u0026lt;acc\u0026gt;, : Acceleration # \u0026lt;dec\u0026gt; : Deceleration # ); # # Relative motion of axis \u0026lt;axIndex\u0026gt;. # Motion is triggerd with a positive edge on \u0026lt;execute\u0026gt; input. # returns 0 if success or error code. # # 3. retvalue = mc_move_ext_pos( # \u0026lt;axIndex\u0026gt;, : Axis index # \u0026lt;execute\u0026gt;, : Trigger # \u0026lt;vel\u0026gt;, : Target velocity # \u0026lt;acc\u0026gt;, : Acceleration # \u0026lt;dec\u0026gt; : Deceleration # ); # Move to current external plc position. Functions intended use is to # move to the start position for syncronized axes. This command is exactly # the same as issueing \u0026#34;mc_move_pos()\u0026#34; with the target postion ax\u0026lt;id\u0026gt;.traj.extsetpos. # Motion is triggerd with a positive edge on \u0026lt;execute\u0026gt; input. # returns 0 if success or error code. # # 4. retvalue = mc_move_vel( # \u0026lt;axIndex\u0026gt;, : Axis index # \u0026lt;execute\u0026gt;, : Trigger # \u0026lt;vel\u0026gt;, : Target velocity # \u0026lt;acc\u0026gt;, : Acceleration # \u0026lt;dec\u0026gt; : Deceleration # ); # Constant velocity motion of axis \u0026lt;axIndex\u0026gt;. # Motion is triggerd with a positive edge on \u0026lt;execute\u0026gt; input. # returns 0 if success or error code. # # 5. retvalue = mc_home( # \u0026lt;axIndex\u0026gt;, : Axis index # \u0026lt;execute\u0026gt;, : Trigger # \u0026lt;seqId\u0026gt;, : Motion sequence # \u0026lt;velTwoardsCam\u0026gt;, : Target Velocity twords cam # \u0026lt;velOffCam\u0026gt; : Target velocity off cam # ); # Perform a homing sequence of axis \u0026lt;axIndex\u0026gt;. # Motion is triggerd with a positive edge on \u0026lt;execute\u0026gt; input. # returns 0 if success or error code. # # 6. retvalue = mc_home_pos( # \u0026lt;axIndex\u0026gt;, : Axis index # \u0026lt;execute\u0026gt;, : Trigger # \u0026lt;seqId\u0026gt;, : Motion sequence # \u0026lt;velTwoardsCam\u0026gt;, : Target Velocity twords cam # \u0026lt;velOffCam\u0026gt; : Target velocity off cam # \u0026lt;homePos\u0026gt; : Homing position # ); # Perform a homing sequence of axis \u0026lt;axIndex\u0026gt; # Motion is triggerd with a positive edge on \u0026lt;execute\u0026gt; input. # returns 0 if success or error code. # # 7. retvalue = mc_halt( # \u0026lt;axIndex\u0026gt;, : Axis index # \u0026lt;execute\u0026gt;, : Trigger # ); # Stop motion of axis \u0026lt;axIndex\u0026gt;. # Motion is triggerd with a positive edge on \u0026lt;execute\u0026gt; input. # returns 0 if success or error code. # Note/Warning: This function will not stop a syncronized motion. # # 8. retvalue = mc_power( # \u0026lt;axIndex\u0026gt;, : Axis index # \u0026lt;enable\u0026gt;, : Enable power # ); # Enable power of axis \u0026lt;axIndex\u0026gt;. # Motion is triggerd with a positive edge on \u0026lt;execute\u0026gt; input. # returns 0 if success or error code. # # 9. retvalue = mc_get_busy( # \u0026lt;axIndex\u0026gt;, : Axis index#  # ); # Check if axis is busy. # # returns busy state of axis (1 if busy and 0 if not busy). # # 10. retvalue = mc_get_homed( # \u0026lt;axIndex\u0026gt;, : Axis index#  # ); # Check if axis is homed. # # returns state of homed flag of axis (1 if homed and 0 if not homed). # # 11. retvalue = mc_get_err(); # Returns error code for last lib call. #  # 12. retvalue = mc_reset(\u0026lt;axIndex\u0026gt;); # Resets error of motion axis. #  # 13. retvalue = mc_get_axis_err(\u0026lt;axIndex\u0026gt;); # Returns motion axis error code. #  # 14. retvalue = mc_set_enable_motion_funcs( # \u0026lt;axIndex\u0026gt;, : Axis index # \u0026lt;enablePos\u0026gt;, : Enable positioning # \u0026lt;enableVelo\u0026gt;, : Enable const velo # \u0026lt;enableHome\u0026gt;, : Enable const homing # );  # Enables/disables motion functionalities. Returns error code. # # Function Lib: Data Storage # 1. retvalue = ds_append_data( # \u0026lt;dsIndex\u0026gt;, : Data storage index # \u0026lt;data\u0026gt;, : Data # ); # Append data to data storage. # returns 0 if success or error code. # # 2. retvalue = ds_clear_data( # \u0026lt;dsIndex\u0026gt;, : Data storage index # ); # Clear data to data storage. # returns 0 if success or error code. # # 3. retvalue = ds_get_data( # \u0026lt;dsIndex\u0026gt;, : Data storage index # \u0026lt;bufferIndex\u0026gt;, : Buffer index # ); # Returns data from buffer. # # 4. retvalue = ds_set_data( # \u0026lt;dsIndex\u0026gt;, : Data storage index # \u0026lt;bufferIndex\u0026gt;, : Buffer index # ); # Sets data in data storage buffer. # returns 0 if success or error code. # # 5. retvalue = ds_get_buff_id( # \u0026lt;dsIndex\u0026gt;, : Data storage index # ); # Returns current buffer index. # # 6. retvalue = ds_set_buff_id( # \u0026lt;dsIndex\u0026gt;, : Data storage index # \u0026lt;bufferIndex\u0026gt;, : Buffer index # ); # Sets current buffer index in data storage buffer. # returns 0 if success or error code. # # 7. retvalue = ds_is_full( # \u0026lt;dsIndex\u0026gt;, : Data storage index # ); # Returns true if buffer is full. # # 8. retvalue = ds_get_size( # \u0026lt;dsIndex\u0026gt;, : Data storage index # ); # Returns buffer size of data storage. # # 9. retvalue = ds_get_err() # Returns error code for last lib call. #  # 10. retvalue = ds_push_asyn( # \u0026lt;dsIndex\u0026gt;, : Data storage index # ); # Triggers push of all asyn parameters in ds to EPICS (including data). # # 11. retvalue = ds_get_avg( # \u0026lt;dsIndex\u0026gt;, : Data storage index\\n # ); # Returns average of the values in the data storage.\\n # # 12. retvalue = ds_get_min( # \u0026lt;dsIndex\u0026gt;, : Data storage index\\n # ); # Returns minimum of the values in the data storage.\\n # # 13. retvalue = ds_get_max( # \u0026lt;dsIndex\u0026gt;, : Data storage index\\n # ); # Returns maximum of the values in the data storage.\\n # # 14. retvalue=ds_append_to_ds( # \u0026lt;dsFromId\u0026gt;, : Source data storage index\\n # \u0026lt;dsFromDataId\u0026gt;, : Source data element index\\n # \u0026lt;elements\u0026gt;, : Number of elements to copy \\n # \u0026lt;dsToId\u0026gt; : Destination data storage index\\n # ); # Appends data at the current position of the destination data storage (dsToId). The data source is defined by (dsFromId) and the selected position (dsFromDataId) and element count (elements) . # # 15. retvalue=ds_err_rst(): # Resets error code for ds_lib. # "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/motion/ecmc_axis_sync_unset/","title":"","tags":[],"description":"","content":""},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/motion/ecmc_axis_unset/","title":"","tags":[],"description":"","content":""},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/motion/ecmc_virt_axis_unset/","title":"","tags":[],"description":"","content":""},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/scripts/empty/","title":"","tags":[],"description":"","content":""},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/startup/","title":"","tags":[],"description":"","content":""},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/categories/","title":"Categories","tags":[],"description":"","content":""},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/tags/","title":"Tags","tags":[],"description":"","content":""}]