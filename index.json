[{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/manual/build/","title":"build at PSI","tags":[],"description":"","content":" These instructions only work at PSI!\n Build at PSI, using driver.makefile by default this module is only build for RHEL7 and Epics \u0026gt;=R7.0.5\nbuild on login cluster make [LIBVERSION] [clean] [uninstall] install check a particular version check the module loads for version dev, Epics R7+ and ECMC version dev, note MASTER_ID=-1 which runs ECMC in master-less mode. Make proper adjustments to match your needs in terms of versions.\niocsh -7 -r \u0026#34;ecmccfg,dev \u0026#39;ECMC_VER=dev,MASTER_ID=-1\u0026#39;\u0026#34; "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/manual/","title":"manual","tags":[],"description":"","content":"ecmccfg A configuration framework for ECMC Motion Control Module for EPICS.\nPurpose The configuration framework contains the necessary files to configure an EPICS IOC for EtherCAT based motion control and DAQ.\n Topics  build at PSI   introduction   axis   troubleshooting   PLC    provided common user commands  addAxis.cmd addDataStorage.cmd addMaster.cmd addSlave.cmd addSlaveKL.cmd addVirtualAxis.cmd applyAxisSynchronization.cmd applyConfig.cmd applySlaveConfig.cmd configureAxis.cmd configureSlave.cmd configureVirtualAxis.cmd loadPLCFile.cmd loadPlugin.cmd setAppMode.cmd setDiagnostics.cmd  Example IOC  require the configuration module with optional version  require ecmccfg \u0026lt;VERSION\u0026gt; add a coupler and slave  # slave 0 {ecmcEK1100} ${SCRIPTEXEC} ${ECMC_CONFIG_ROOT}addSlave.cmd, \u0026#34;HW_DESC=EK1100\u0026#34; # SLAVE_ID is automatically incremented # slave 1 {ecmcEL1018} ${SCRIPTEXEC} ${ECMC_CONFIG_ROOT}addSlave.cmd, \u0026#34;HW_DESC=EL1018\u0026#34; # skip slaves 2..6 # slave 7 {ecmcEL2008}, with optional SLAVE_ID ${SCRIPTEXEC} ${ECMC_CONFIG_ROOT}addSlave.cmd, \u0026#34;HW_DESC=E2008, SLAVE_ID=7\u0026#34; #-- ATTENTION, this only work for certain slaves, as the EPICS templates have to be migrated before # slave 9 {ecmcEL2008}, with optional SLAVE_ID and P_SCRIPT ${SCRIPTEXEC} ${ECMC_CONFIG_ROOT}addSlave.cmd, \u0026#34;HW_DESC=E2008, SLAVE_ID=7, P_SCRIPT=mXsXXX\u0026#34; add more slaves and apply configuration to the slaves  # slave 8 {ecmcEL7037}, configure slave with optional SLAVE_ID ${SCRIPTEXEC} ${ECMC_CONFIG_ROOT}configureSlave.cmd, \u0026#34;HW_DESC=EL7037, CONFIG=-Motor-Nanotec-ST4118L1804-B, SLAVE_ID=8\u0026#34; # slave 9 {ecmcEL7037}, addSlave, with immediate call off applySlaveConfig # slave with global configuration ${SCRIPTEXEC} ${ECMC_CONFIG_ROOT}addSlave.cmd, \u0026#34;HW_DESC=EL7037\u0026#34; ${SCRIPTEXEC} ${ECMC_CONFIG_ROOT}applySlaveConfig, \u0026#34;CONFIG=-Motor-Nanotec-ST4118L1804-B\u0026#34; # slave with local configuration, in this case provided by the module `ECMC_AGIR` epicsEnvSet(\u0026#34;CFG_ROOT\u0026#34;, \u0026#34;${ECMC_AGIR_DIR}/\u0026#34;) ${SCRIPTEXEC} ${ECMC_CONFIG_ROOT}addSlave.cmd, \u0026#34;HW_DESC=EP7211-0034_ALL\u0026#34; ${SCRIPTEXEC} ${ECMC_CONFIG_ROOT}applySlaveConfig.cmd, \u0026#34;LOCAL_CONFIG=${CFG_ROOT}AM8211_AGIR.cfg\u0026#34; apply the configuration  ${SCRIPTEXEC} ${ECMC_CONFIG_ROOT}applyConfig.cmd additional configuration  manually set binaryOutput01 to 1\necmcConfigOrDie \u0026#34;Cfg.WriteEcEntryIDString(${ECMC_EC_SLAVE_NUM_DIG_OUT},binaryOutput01,1)\u0026#34; adding a physical motor axis   classic config  epicsEnvSet(\u0026#34;DEV\u0026#34;, \u0026#34;STEST-MYDEVICE\u0026#34;) ${SCRIPTEXEC} ${ECMC_CONFIG_ROOT}configureAxis.cmd, \u0026#34;CONFIG=./cfg/axis_1\u0026#34;  yaml config  ${SCRIPTEXEC} ${ECMC_CONFIG_ROOT}addAxisYaml.cmd, \u0026#34;FILE=./AM8111_CSV_minimum.yaml, ECMC_TMPDIR=/tmp/\u0026#34; adding a virtual motor axis  ${SCRIPTEXEC} ${ecmccfg_DIR}configureVirtualAxis.cmd, \u0026#34;CONFIG=./cfg/axis_11_virt\u0026#34; adding synchronization  ${SCRIPTEXEC} ${ecmccfg_DIR}applyAxisSynchronization.cmd, \u0026#34;CONFIG=./cfg/axis_1_sync\u0026#34; ${SCRIPTEXEC} ${ecmccfg_DIR}applyAxisSynchronization.cmd, \u0026#34;CONFIG=./cfg/axis_11_sync\u0026#34; loading a PLC from file   classic PLC-file  ${SCRIPTEXEC} ${ecmccfg_DIR}loadPLCFile.cmd, \u0026#34;PLC_ID=0, FILE=./plc/homeSlit.plc, SAMPLE_RATE_MS=100\u0026#34;  pure yaml based PLC  ${SCRIPTEXEC} \u0026#34;${ECMC_CONFIG_ROOT}loadYamlPlc.cmd\u0026#34; \u0026#34;FILE=./plc1.yaml, ECMC_TMPDIR=/tmp/\u0026#34;  yaml definition, with classic PLC-file, Note: file key in yaml config will overwrite anything in the code key!  ${SCRIPTEXEC} \u0026#34;${ECMC_CONFIG_ROOT}loadYamlPlc.cmd\u0026#34; \u0026#34;FILE=./plc1File.yaml, ECMC_TMPDIR=/tmp/\u0026#34; go active  ${SCRIPTEXEC} ${ecmccfg_DIR}setAppMode.cmd "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/scripts/addaxis/","title":"addAxis.cmd","tags":[],"description":"","content":"author Niko Kivel\n "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/scripts/adddatastorage/","title":"addDataStorage.cmd","tags":[],"description":"","content":"description Script for adding dataStorage.\ndetails Adds dataStorage buffer.\nauthor Anders Sandstroem\n paramters DS_SIZE Size of data buffer.\nDS_ID (optional), default 0, buffer ID\nDS_TYPE (optional), default 0, 0: Normal Buffer, 1: Ring Buffer, 2: FIFO Buffer\nSAMPLE_RATE_MS (optional), default 1\nDS_DEBUG (optional), default 0, 0: No debug printouts, 1: Debug printouts\n Example calls:\n call for 1000 elements at 10 Hz  ${SCRIPTEXEC} ${ecmccfg_DIR}addDataStorage.cmd \u0026#34;DS_ID=1, DS_SIZE=1000, SAMPLE_RATE_MS=100\u0026#34; "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/scripts/addmaster/","title":"addMaster.cmd","tags":[],"description":"","content":"author Niko Kivel\n paramters MASTER_ID (optional) master ID as shown by ethercat master.\n Example calls:\n call w/o MASTER_ID  ${SCRIPTEXEC} ${ecmccfg_DIR}addMaster.cmd  call w/ MASTER_ID, which claims the 4th master.  ${SCRIPTEXEC} ${ecmccfg_DIR}addMaster.cmd, \u0026#34;MASTER_ID=3\u0026#34; "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/scripts/addslave/","title":"addSlave.cmd","tags":[],"description":"","content":"description Script for adding a slave to the EtherCAT bus configuration.\ndetails Adds the respective hardware to the bus configuration, adds specific and default PV to the EPICS database. For some/most slaves also a default\nauthor Niko Kivel\n paramters HW_DESC Hardware descriptor, i.e. EL1008\nSLAVE_ID (optional) bus position\nSUBST_FILE (optional) substitution file\nP_SCRIPT (optional) naming convention prefix script\nNELM (optional) Used for oversampling cards. Defaults to 1\nDEFAULT_SUBS (optional) option to disble default PVs for mapped PDOs\nDEFAULT_SLAVE_PVS (optional, caution!) basic slave PVs, i.e. ${ECMC_P}-Operational will be suppressed\n Example calls:\n call w/o SLAVE_ID  ${SCRIPTEXEC} ${ecmccfg_DIR}addSlave.cmd, \u0026#34;HW_DESC=EL7037\u0026#34;  call w/ SLAVE_ID  ${SCRIPTEXEC} ${ecmccfg_DIR}addSlave.cmd, \u0026#34;HW_DESC=EL1018, SLAVE_ID=1\u0026#34;  call w/ SLAVE_ID and P_SCRIPT  ${SCRIPTEXEC} ${ecmccfg_DIR}addSlave.cmd, \u0026#34;HW_DESC=EL1018, SLAVE_ID=1, P_SCRIPT=mXsXXX\u0026#34;  call w/ default PDO PVs disabled  ${SCRIPTEXEC} ${ecmccfg_DIR}addSlave.cmd, \u0026#34;HW_DESC=EL3204, DEFAULT_SUBS=false, DEFAULT_SLAVE_PVS=true\u0026#34; "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/scripts/addslavekl/","title":"addSlaveKL.cmd","tags":[],"description":"","content":"description Script for adding a slave to the EtherCAT bus configuration of KL type.\ndetails Adds the respective hardware to the bus configuration, adds specific and default PV to the EPICS database. For some/most slaves also a default\nauthor Anders Sandstrom\n paramters HW_DESC Hardware descriptor, i.e. KL2032\nSLAVE_ID EtherCAT bus position of the BK1250 (or similar terminal)\nSLAVE_ID_KL KL-Bus index in two digit hex starting at zero for the first slave after BK1250 (or similar terminal)\nSUBST_FILE (optional) substitution file\n Example calls:\n${SCRIPTEXEC} ${ecmccfg_DIR}addSlave.cmd, \u0026#34;HW_DESC=EL1018, SLAVE_ID=1, SLAVE_ID_KL=0A\u0026#34; "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/scripts/addvirtualaxis/","title":"addVirtualAxis.cmd","tags":[],"description":"","content":"author Niko Kivel\n "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/scripts/applyaxissynchronization/","title":"applyAxisSynchronization.cmd","tags":[],"description":"","content":"description Script for applying axis synchronization\ndetails Adds synchronization parameters to an axis provided by CONFIG.\nauthor Niko Kivel\n paramters CONFIG configuration file, i.e. ./cfg/linear_1.sax\nCLEAR_VARS_CMD (optional) Set to \u0026ldquo;empty\u0026rdquo; for not clear env vars (if needed vars for later use).\n Example call:\n${SCRIPTEXEC} ${ecmccfg_DIR}applyAxisSynchronization.cmd, \u0026#34;CONFIG=./cfg/linear_1.sax\u0026#34; "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/scripts/applyconfig/","title":"applyConfig.cmd","tags":[],"description":"","content":"author Niko Kivel\n Example call:\n${SCRIPTEXEC} ${ecmccfg_DIR}applyConfig.cfg "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/scripts/applyslaveconfig/","title":"applySlaveConfig.cmd","tags":[],"description":"","content":"author Niko Kivel\n Example call:\ncall applySlaveConfig with CONFIG\n${SCRIPTEXEC} ${ecmccfg_DIR}applySlaveConfig.cmd, \u0026#34;CONFIG=-Motor-Nanotec-ST4118L1804-B\u0026#34; call applySlaveConfig with LOCAL_CONFIG\n${SCRIPTEXEC} ${ecmccfg_DIR}applySlaveConfig.cmd, \u0026#34;LOCAL_CONFIG=./myFancyServoConfig.cfg\u0026#34; "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/scripts/applyslavedcconfig/","title":"applySlaveDCconfig.cmd","tags":[],"description":"","content":"author Anders Sandstroem\n "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/scripts/applysubstitutions/","title":"applySubstitutions.cmd","tags":[],"description":"","content":"description Script for applying substitution file\ndetails Applies substitution from ${SUBST_FILE} with ${P_SCRIPT}\nauthor Niko Kivel\n paramters SUBST_FILE (optional) substitution file\nECMC_P PV prefix\nP_SCRIPT (optional) naming convention prefix script\nNELM (optional) Used for oversampling cards. Defaults to 1\n Example calls:\n call w/o SLAVE_ID  ${SCRIPTEXEC} \u0026#34;${ECMC_CONFIG_ROOT}applySubstitutions.cmd\u0026#34; \u0026#34;SUBST_FILE=${SUBST_FILE=ecmc${ECMC_EC_HWTYPE}.substitutions},ECMC_P=${ECMC_P}\u0026#34; "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/scripts/applytemplate/","title":"applyTemplate.cmd","tags":[],"description":"","content":"description Script for applying a template\ndetails Applies template from ${TEMPLATE_FILE} with ${P_SCRIPT}, PARAMS can be passed\nauthor Niko Kivel\n paramters TEMPLATE_FILE template file\nECMC_P PV prefix\nPARAMS (optional) additional parameters\n Example calls:\n call w/o SLAVE_ID  ${SCRIPTEXEC} \u0026#34;${ECMC_CONFIG_ROOT}applyTemplate.cmd\u0026#34; \u0026#34;TEMPLATE_FILE=ecmcEcSlave.template,ECMC_P=${ECMC_P}\u0026#34; "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/general/chkoversampfactordie/","title":"chkOverSampFactOrDie.cmd","tags":[],"description":"","content":"author Anders Sandstroem\n "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/general/chkoversamptimeordie/","title":"chkOverSampTimeOrDie.cmd","tags":[],"description":"","content":"author Anders Sandstroem\n "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/general/chkvalidcurrentsetordie/","title":"chkValidCurrentSetOrDie.cmd","tags":[],"description":"","content":"author Anders Sandstroem\n "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/scripts/configureaxis/","title":"configureAxis.cmd","tags":[],"description":"","content":"description Script for adding an axis with configuration.\ndetails Adds an axis to the configuration and applies parameters provided by CONFIG.\nauthor Niko Kivel\n paramters CONFIG configuration file, i.e. ./cfg/linear_1.pax\nDEV (optional) device name, i.e. MOTOR1\nCLEAR_VARS_CMD (optional) Set to \u0026ldquo;empty\u0026rdquo; for not clear env vars (if vars needed for later use).\nCFG_MACROS (optional) Substitution macros for config file\n Example call:\n${SCRIPTEXEC} ${ecmccfg_DIR}configureAxis.cmd, \u0026#34;CONFIG=./cfg/linear_1.pax\u0026#34; "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/scripts/configureslave/","title":"configureSlave.cmd","tags":[],"description":"","content":"description Script for adding a slave with dedicated slave configuration to the EtherCAT bus configuration.\ndetails Adds the respective hardware to the bus configuration, adds specific and default PV to the EPICS database. Applies a specific slave configuration.\nauthor Niko Kivel\n paramters HW_DESC Hardware descriptor, i.e. EL7037\nCONFIG configuration file, i.e. -Motor-Nanotec-ST4118L1804-B\n The CONFIG together with the HW_DESC form the full filename which by definition is ecmc${HW_DESC}${CONFIG}.cmd, i.e.: ecmcEL7037-Motor-Nanotec-ST4118L1804-B.cmd\nparamters SLAVE_ID (optional) bus position\nCFG_MACROS (optional) Substitution macros for config file\nNELM (optional) Used for oversampling cards. Defaults to 1\n Example calls:\n call w/o SLAVE_ID  ${SCRIPTEXEC} ${ecmccfg_DIR}configureSlave.cmd, \u0026#34;HW_DESC=EL7037, CONFIG=-Motor-Nanotec-ST4118L1804-B\u0026#34;  call w/ SLAVE_ID  ${SCRIPTEXEC} ${ecmccfg_DIR}configureSlave.cmd, \u0026#34;HW_DESC=EL7037, CONFIG=-Motor-Nanotec-ST4118L1804-B, SLAVE_ID=8\u0026#34; "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/scripts/configurevirtualaxis/","title":"configureVirtualAxis.cmd","tags":[],"description":"","content":"description Script for adding a virtual axis with configuration.\ndetails Adds a virtual axis to the configuration and applies parameters provided by CONFIG.\nauthor Niko Kivel\n paramters CONFIG configuration file, i.e. ./cfg/linear_11.vax\nDEV (optional) device name, i.e. GAP\nCLEAR_VARS_CMD (optional) Set to \u0026ldquo;empty\u0026rdquo; for not clear env vars (if needed vars for later use).\n Example call:\n${SCRIPTEXEC} ${ecmccfg_DIR}configureVirtualAxis.cmd, \u0026#34;CONFIG=./cfg/linear_11.vax\u0026#34; "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/motion/ecmc_axis-records/","title":"ecmc_axis-records.cmd","tags":[],"description":"","content":"description Script for adding axis related EPICS PVs.\ndetails Adds motorRecord to the IOC.\nauthor Anders Sandstroem\n This script is typically called by \\b addAxis.cmd\n"},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/motion/ecmc_axis/","title":"ecmc_axis.cmd","tags":[],"description":"","content":"description Script for configuring a physical axis.\ndetails Configures a physical axis in ECMC, based on previously set environment variables.\nauthor Anders Sandstroem\n This script is typically called by \\b addAxis.cmd, often via \\b ecmc_axis-records.cmd\n"},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/motion/ecmc_axis_diag/","title":"ecmc_axis_diag.cmd","tags":[],"description":"","content":"description Script for adding axis diagnostic EPICS PVs.\ndetails Adds diagnostic PVs to the IOC.\nauthor Anders Sandstroem\n "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/motion/ecmc_axis_mr/","title":"ecmc_axis_mr.cmd","tags":[],"description":"","content":"author Anders Sandstroem\n This script is typically called by \\b ecmc_axis.cmd, often via \\b ecmc_axis-records.cmd\n"},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/motion/ecmc_axis_sync/","title":"ecmc_axis_sync.cmd","tags":[],"description":"","content":"description Script for configuring axis synchronization\ndetails Configures ECMC for axis synchronization, based on previously set environment variables.\nauthor Anders Sandstroem\n This script is typically called by \\b applyAxisSynchronization.cmd\n"},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/motion/ecmc_virt_axis-records/","title":"ecmc_virt_axis-records.cmd","tags":[],"description":"","content":"description Script for adding axis related EPICS PVs.\ndetails Adds motorRecord to the IOC.\nauthor Anders Sandstroem\n This script is typically called by \\b addVirtualAxis.cmd\n"},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/motion/ecmc_virt_axis/","title":"ecmc_virt_axis.cmd","tags":[],"description":"","content":"description Script for configuring a virtual axis.\ndetails Configures a virtual axis in ECMC, based on previously set environment variables.\nauthor Anders Sandstroem\n This script is typically called by \\b addVirtualAxis.cmd, often via \\b ecmc_virt_axis-records.cmd\n"},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/","title":"ecmccfg","tags":[],"description":"","content":"ecmccfg A configuration framework for ECMC Motion Control Module for EPICS.\nLicense  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 3 of the License, or (at your option) any later version.\nThis program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.\nYou should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\nLatest release \nDownload \n"},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/naming/ecmcclassicnaming/","title":"ecmcClassicNaming.cmd","tags":[],"description":"","content":"description Script for defining ${ECMC_PREFIX}\ndetails Gathers relevant information about MasterID, SlaveID, \u0026hellip; to create naming convention compliant PREFIX\nauthor Niko Kivel\n "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/naming/ecmcessnaming/","title":"ecmcESSnaming.cmd","tags":[],"description":"","content":"description Script for defining ${ECMC_P}\ndetails Gathers relevant information about MasterID, SlaveID, \u0026hellip; to create naming convention compliant PREFIX\nauthor Niko Kivel\n "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/naming/ecmcmxsxxx/","title":"ecmcmXsXXX.cmd","tags":[],"description":"","content":"description Script for defining ${ECMC_P}\ndetails Gathers relevant information about MasterID, SlaveID, \u0026hellip; to create naming convention compliant PREFIX\nauthor Niko Kivel\n "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/general/","title":"general","tags":[],"description":"","content":"  chkOverSampFactOrDie.cmd   chkOverSampTimeOrDie.cmd   chkValidCurrentSetOrDie.cmd   general.cmd   generalDiagnostics.cmd   init.cmd   initAll.cmd   initAxis.cmd   issueWarning.cmd   verifyOrDie.cmd   "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/general/general/","title":"general.cmd","tags":[],"description":"","content":"author Niko Kivel, Anders Sandstroem\n "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/general/generaldiagnostics/","title":"generalDiagnostics.cmd","tags":[],"description":"","content":"author Niko Kivel, Anders Sandstroem\n "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/general/init/","title":"init.cmd","tags":[],"description":"","content":"author Niko Kivel, Anders Sandstroem\n "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/general/initall/","title":"initAll.cmd","tags":[],"description":"","content":"author Niko Kivel, Anders Sandstroem\n "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/general/initaxis/","title":"initAxis.cmd","tags":[],"description":"","content":"author Niko Kivel, Anders Sandstroem\n "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/general/issuewarning/","title":"issueWarning.cmd","tags":[],"description":"","content":"author Anders Sandstroem\n "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/scripts/jinja2/","title":"jinja2","tags":[],"description":"","content":"  loadYamlAxis.cmd   loadYamlPlc.cmd   "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/scripts/loadplcfile/","title":"loadPLCFile.cmd","tags":[],"description":"","content":"description Script for adding a PLC from file.\ndetails Adds a PLC defined in FILE. Also adds PLC specific EPICS PVs, i.e. for enable/disable.\nauthor Niko Kivel\n paramters FILE PLC definition file, i.e. ./plc/homeSlit.plc\nPLC_ID (optional) PLC number, default 0\nSAMPLE_RATE_MS (optional) excecution rate, default 1000/EC_RATE\nPLC_MACROS (optional) Substitution macros for PLC code\nTMP_PATH (optional) directory to dump the temporary plc file after macro substitution\nPRINT_PLC_FILE (optional) 1/0, printout msi parsed plc file (default enable(1)).\nSUBST_FILE (optional) custom substitution file otherwise ecmccfg default will be loaded\n Example call:\n${SCRIPTEXEC} ${ecmccfg_DIR}loadPLCFile.cmd, \u0026#34;PLC_ID=0, FILE=./plc/homeSlit.plc, SAMPLE_RATE_MS=100\u0026#34; "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/scripts/loadplugin/","title":"loadPlugin.cmd","tags":[],"description":"","content":"author Anders Sandström\n paramters FILE Filename of plugin shared lib (./ecmcPlugin_Advanced.so)\nPLUGIN_ID Id of plugin to load\nCONFIG (optional) Configuration string sent to plugin at construct\nREPORT (optional) Printout information of loaded plugin if set to \u0026ldquo;1\u0026rdquo;\n Example call:\n${SCRIPTEXEC} ${ecmccfg_DIR}loadPlugin.cmd, \u0026#34;PLUGIN_ID=0,FILE=./ecmcPlugin_Advanced.so,CONFIG=\u0026#39;PLUGIN CONFIGS GO HERE \u0026#39; "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/scripts/jinja2/loadyamlaxis/","title":"loadYamlAxis.cmd","tags":[],"description":"","content":"description Script for loading Axis from yaml file via jinja2\ndetails adds an Axis, based on a yaml config file\nauthor Niko Kivel\n paramters FILE the yaml-file containing the PLC definition\nDEV the device name (optional, defaults to ${IOC}\n Example calls:\n call  ${SCRIPTEXEC} \u0026#34;./loadYamlAxis.cmd\u0026#34; \u0026#34;FILE=./axis1.yaml\u0026#34; ${SCRIPTEXEC} \u0026#34;./loadYamlAxis.cmd\u0026#34; \u0026#34;FILE=./axis1.yaml, DEV=foobar\u0026#34; "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/scripts/jinja2/loadyamlplc/","title":"loadYamlPlc.cmd","tags":[],"description":"","content":"description Script for loading PLC from yaml file via jinja2\ndetails adds a PLC, line by line, from a yaml-file, parsed by jinja2\nauthor Niko Kivel\n paramters FILE the yaml-file containing the PLC definition\n Example calls:\n call  ${SCRIPTEXEC} \u0026#34;./loadYamlPlc.cmd\u0026#34; \u0026#34;FILE=./plc1.yaml\u0026#34; "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/motion/","title":"motion","tags":[],"description":"","content":"  ecmc_axis-records.cmd   ecmc_axis.cmd   ecmc_axis_diag.cmd   ecmc_axis_mr.cmd   ecmc_axis_sync.cmd   ecmc_virt_axis-records.cmd   ecmc_virt_axis.cmd            "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/naming/","title":"naming","tags":[],"description":"","content":"  ecmcClassicNaming.cmd   ecmcESSnaming.cmd   ecmcmXsXXX.cmd   "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/scripts/","title":"scripts","tags":[],"description":"","content":"  addAxis.cmd   addDataStorage.cmd   addMaster.cmd   addSlave.cmd   addSlaveKL.cmd   addVirtualAxis.cmd   applyAxisSynchronization.cmd   applyConfig.cmd   applySlaveConfig.cmd   applySlaveDCconfig.cmd   applySubstitutions.cmd   applyTemplate.cmd   configureAxis.cmd   configureSlave.cmd   configureVirtualAxis.cmd   jinja2   loadPLCFile.cmd   loadPlugin.cmd   setAppMode.cmd   setDiagnostics.cmd   slaveVerify.cmd      "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/scripts/setappmode/","title":"setAppMode.cmd","tags":[],"description":"","content":"author Niko Kivel\n "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/scripts/setdiagnostics/","title":"setDiagnostics.cmd","tags":[],"description":"","content":"author Niko Kivel\n "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/scripts/slaveverify/","title":"slaveVerify.cmd","tags":[],"description":"","content":"description ** script for slave verification and optional reset**\ndetails will verify the slave identity and reset by writing to 0x1011, optionally read firmwre version from 0x100a\nauthor Niko Kivel\n Macros\n"},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/","title":"source","tags":[],"description":"","content":"  general   motion   naming   scripts      "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/general/verifyordie/","title":"verifyOrDie.cmd","tags":[],"description":"","content":"author Anders Sandstroem\n "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/manual/introduction/","title":"introduction","tags":[],"description":"","content":"principle EtherCAT requires the field bus components (slaves) to be configured on the master. The master must know about the data exchanges with the slaves, this is referred to as process image.\nDuring IOC-startup, the requested configuration is validated against the actually present hardware on the bus. Mismatches will result in an error, the IOC will not start.\nBlindly restarting the IOC, with only partially working EtherCAT hardware, will results in an inoperable IOC! Refer to the troubleshooting guide for details.\n IOC structure The startup script has several steps:\n require ecmccfg configure the slaves on the EtherCAT bus  additional configuration adding a physical motor axis adding a virtual motor axis adding synchronization loading a PLC from file   apply the configuration go active  require ecmccfg require ecmccfg \u0026lt;VERSION\u0026gt; slave configuration Each slave on the field bus must be configured for use with ECMC. For this purpose scripts can be called for:\n adding slaves with default configuration adding and configure while adding applying a configuration to the previously added slaves  examples The addSlave is used for simple slaves, a default configuration is automatically applied. In addition default PVs will created for the basic slave features, i.e. status. Most slaves also have PVs created matching the purpose, i.e. inputs will have bi records, outputs will have bo records for each channel. This behaviour can be modified by arguments.\n  add a coupler and slaves\n# slave 0 {ecmcEK1100} ${SCRIPTEXEC} ${ECMC_CONFIG_ROOT}addSlave.cmd, \u0026#34;HW_DESC=EK1100\u0026#34; # SLAVE_ID is automatically incremented # slave 1 {ecmcEL1018} ${SCRIPTEXEC} ${ECMC_CONFIG_ROOT}addSlave.cmd, \u0026#34;HW_DESC=EL1018\u0026#34; # skip slaves 2..6 # slave 7 {ecmcEL2008}, with optional SLAVE_ID ${SCRIPTEXEC} ${ECMC_CONFIG_ROOT}addSlave.cmd, \u0026#34;HW_DESC=EL2008, SLAVE_ID=7\u0026#34; # slave 9 {ecmcEL2008}, with optional SLAVE_ID and P_SCRIPT ${SCRIPTEXEC} ${ECMC_CONFIG_ROOT}addSlave.cmd, \u0026#34;HW_DESC=EL2008, SLAVE_ID=7, P_SCRIPT=mXsXXX\u0026#34; # slave 10 {ecmcEL3204}, without any of the default PVs ${SCRIPTEXEC} ${ECMC_CONFIG_ROOT}addSlave.cmd, \u0026#34;HW_DESC=EL3204, DEFAULT_SUBS=false, DEFAULT_SLAVE_PVS=true\u0026#34;   add more slaves and apply configuration to the slaves\n# slave 8 {ecmcEL7037}, configure slave with optional SLAVE_ID ${SCRIPTEXEC} ${ECMC_CONFIG_ROOT}configureSlave.cmd, \u0026#34;HW_DESC=EL7037, CONFIG=-Motor-Nanotec-ST4118L1804-B, SLAVE_ID=8\u0026#34; # slave 9 {ecmcEL7037}, addSlave, with immediate call off applySlaveConfig # slave with global configuration ${SCRIPTEXEC} ${ECMC_CONFIG_ROOT}addSlave.cmd, \u0026#34;HW_DESC=EL7037\u0026#34; ${SCRIPTEXEC} ${ECMC_CONFIG_ROOT}applySlaveConfig, \u0026#34;CONFIG=-Motor-Nanotec-ST4118L1804-B\u0026#34; # slave with local configuration, in this case provided by the module `ECMC_AGIR` epicsEnvSet(\u0026#34;CFG_ROOT\u0026#34;, \u0026#34;${ECMC_AGIR_DIR}/\u0026#34;) ${SCRIPTEXEC} ${ECMC_CONFIG_ROOT}addSlave.cmd, \u0026#34;HW_DESC=EP7211-0034_ALL\u0026#34; ${SCRIPTEXEC} ${ECMC_CONFIG_ROOT}applySlaveConfig.cmd, \u0026#34;LOCAL_CONFIG=${CFG_ROOT}AM8211_AGIR.cfg\u0026#34;   apply the configuration The configured process image is applied to the master\n${SCRIPTEXEC} ${ECMC_CONFIG_ROOT}applyConfig.cmd additional configuration Optionally, manual modifications can be made to the default configuration.\nIn order to manually set binaryOutput01 to 1 at startup, the following can be added to the startup script.\necmcConfigOrDie \u0026#34;Cfg.WriteEcEntryIDString(${ECMC_EC_SLAVE_NUM_DIG_OUT},binaryOutput01,1)\u0026#34; adding a physical motor axis Axis configuration will is explained in details here.\n classic config  epicsEnvSet(\u0026#34;DEV\u0026#34;, \u0026#34;STEST-MYDEVICE\u0026#34;) ${SCRIPTEXEC} ${ECMC_CONFIG_ROOT}configureAxis.cmd, \u0026#34;CONFIG=./cfg/axis_1\u0026#34;  yaml config  ${SCRIPTEXEC} ${ECMC_CONFIG_ROOT}addAxisYaml.cmd, \u0026#34;FILE=./AM8111_CSV_minimum.yaml, ECMC_TMPDIR=/tmp/\u0026#34; adding a virtual motor axis ${SCRIPTEXEC} ${ecmccfg_DIR}configureVirtualAxis.cmd, \u0026#34;CONFIG=./cfg/axis_11_virt\u0026#34; adding synchronization ${SCRIPTEXEC} ${ecmccfg_DIR}applyAxisSynchronization.cmd, \u0026#34;CONFIG=./cfg/axis_1_sync\u0026#34; ${SCRIPTEXEC} ${ecmccfg_DIR}applyAxisSynchronization.cmd, \u0026#34;CONFIG=./cfg/axis_11_sync\u0026#34; loading a PLC from file The PLC functionionality is exmplained in detail here. ECMC PLCs can be loaded from classical PLC files, from pure yaml files or from a yaml/PLC hybrid.\n classic PLC-file  ${SCRIPTEXEC} ${ecmccfg_DIR}loadPLCFile.cmd, \u0026#34;PLC_ID=0, FILE=./plc/homeSlit.plc, SAMPLE_RATE_MS=100\u0026#34;  pure yaml based PLC  ${SCRIPTEXEC} \u0026#34;${ECMC_CONFIG_ROOT}loadYamlPlc.cmd\u0026#34; \u0026#34;FILE=./plc1.yaml, ECMC_TMPDIR=/tmp/\u0026#34;  yaml definition, with classic PLC-file, Note: file key in yaml config will overwrite anything in the code key!  ${SCRIPTEXEC} \u0026#34;${ECMC_CONFIG_ROOT}loadYamlPlc.cmd\u0026#34; \u0026#34;FILE=./plc1File.yaml, ECMC_TMPDIR=/tmp/\u0026#34; go active ${SCRIPTEXEC} ${ecmccfg_DIR}setAppMode.cmd "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/manual/axis/","title":"axis","tags":[],"description":"","content":"axis ECMC has two types of axes, (1) physical axes, aka joints, and (2) virtual axes, aka end effector. Both types are classes in ECMC, the physical axis is a super-set of the virtual axes, as the latter lacks the hardware.\nYAML config Since v7, axes can be configured with yaml-files. This is a huge improvement over the classic configuration based on EPICS environment variables. For backward compatibility the classical configuration is still supported.\nlinting and schema check From v8+ yaml files are linted for syntactic errors, observe the iocsh for warnings and errors. Additionally the schema of the yaml file is checked by Cerberus. This check will point out errors in the structure of the configuration as well as certain type errors.\n"},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/manual/troubleshooting/ethercatcli/","title":"ethercat command line interface","tags":[],"description":"","content":"ethercat CLI The IgH EtherCAT master provides a command line interface (CLI) which is a very powerful tool. The most common commands will be explained here.\nethercat master This will show the state of all masters on the respective host.\nThe command will show the state of all masters. To limit the command to a single master, make use of the -m parameter.\n The -m parameter is available to all ethercat commands, and is even require by some in case of multiple masters. Check the help by issuing ethercat -h for details.\n Example:\nethercat master Master0 Phase: Operation Active: yes Slaves: 38 Ethernet devices: Main: b4:7a:f1:30:7e:d5 (attached) Link: UP Tx frames: 133210322 Tx bytes: 11957093893 Rx frames: 133210320 Rx bytes: 11957093737 Tx errors: 0 Tx frame rate [1/s]: 500 500 500 Tx rate [KByte/s]: 43.4 43.4 43.3 Rx frame rate [1/s]: 500 500 500 Rx rate [KByte/s]: 43.4 43.4 43.3 Common: Tx frames: 737445202 Tx bytes: 114898987125 Rx frames: 737445184 Rx bytes: 114898984314 Lost frames: 18 Tx frame rate [1/s]: 500 500 500 Tx rate [KByte/s]: 43.4 43.4 43.3 Rx frame rate [1/s]: 500 500 500 Rx rate [KByte/s]: 43.4 43.4 43.3 Loss rate [1/s]: 0 0 0 Frame loss [%]: 0.0 0.0 0.0 Distributed clocks: Reference clock: Slave 0 DC reference time: 708164169043902491 Application time: 708427716430011969 2022-06-13 09:28:36.430011969 In case the numbers mostly zero, check the link state.\nEthernet devices: Main: b4:7a:f1:30:7e:d5 (attached) Link: UP \u0026lt;--- HERE If the link is DOWN, try bringing the network device up manually. This, can be done with ip link set \u0026lt;nameOfNetworkDevice\u0026gt; up\nIf the device name is unkown, check with ip link show and search for the MAC the EtherCAT master is bound to.\nethercat slaves As the command suggest, this will provide a list of the EtherCAT slaves.\nExample:\nethercat slaves 0 0:0 PREOP + EK1100 EtherCAT Coupler (2A E-Bus) 1 0:1 PREOP + EL9227-5500 ?berstromschutz 24V DC, 2K., max. 10A (Summe), eins 2 0:2 PREOP + EL1034 4K. Dig. Eingang 24V, potenzialfrei, 10?s 3 0:3 PREOP + EL5042 2Ch. BiSS-C Encoder 4 0:4 PREOP + EL5042 2Ch. BiSS-C Encoder 5 0:5 PREOP + EL9410 E-Bus Netzteilklemme (Diagnose) 6 0:6 PREOP + EL9576 Bremschopper Klemme 7 0:7 PREOP + EL7041 1Ch. Stepper motor output stage (50V, 5A) 8 0:8 PREOP + EL7041 1Ch. Stepper motor output stage (50V, 5A) 9 0:9 PREOP + EL7041 1Ch. Stepper motor output stage (50V, 5A) 10 0:10 PREOP + EL7041 1Ch. Stepper motor output stage (50V, 5A) 11 0:11 PREOP + EK1100 EtherCAT-Koppler (2A E-Bus) 12 0:12 PREOP + EL9227-5500 ?berstromschutz 24V DC, 2K., max. 10A (Summe), eins 13 0:13 PREOP + EL1034 4K. Dig. Eingang 24V, potenzialfrei, 10?s 14 0:14 PREOP + EL1034 4K. Dig. Eingang 24V, potenzialfrei, 10?s 15 0:15 PREOP + EL1034 4K. Dig. Eingang 24V, potenzialfrei, 10?s 16 0:16 PREOP + EL5042 2Ch. BiSS-C Encoder 17 0:17 PREOP + EL5042 2Ch. BiSS-C Encoder 18 0:18 PREOP + EL5042 2Ch. BiSS-C Encoder 19 0:19 PREOP + EL3314 4K. Ana. Eingang Thermoelement (TC) 20 0:20 PREOP + EL9410 E-Bus Netzteilklemme (Diagnose) 21 0:21 PREOP + EL9576 Bremschopper Klemme 22 0:22 PREOP + EL7041 1Ch. Stepper motor output stage (50V, 5A) 23 0:23 PREOP + EL7041 1Ch. Stepper motor output stage (50V, 5A) 24 0:24 PREOP + EL7041 1Ch. Stepper motor output stage (50V, 5A) 25 0:25 PREOP + EL7041 1Ch. Stepper motor output stage (50V, 5A) 26 0:26 PREOP + EL7041 1Ch. Stepper motor output stage (50V, 5A) 27 0:27 PREOP + EL7041 1Ch. Stepper motor output stage (50V, 5A) 28 0:28 PREOP + EKM1101 EtherCAT Coupler (2A E-Bus, ID switch, Diagnostics, is 29 0:29 PREOP + ELM3004-0000 4K. Ana. Eingang +/-30V, 24 bit, hochgenau 30 0:30 PREOP + ELM3146-0000 6Ch. Ana. Input +/-10V, +/-20mA, 24 bit, high prec 31 0:31 PREOP + ELM3602-0002 2Ch. IEPE Sensor, 24 bit, high precision 32 0:32 OP + EP7047-1032 1K. Schrittmotor-Endstufe (50V, 5A) 33 0:33 OP + EP5001-0002 1K. SSI Encoder 34 0:34 PREOP + EP7041-0002 1K. Schrittmotor-Endstufe (50V, 5A) 35 0:35 PREOP + EP7211-0034 1Ch. MDP742 Servo motor output stage with OCT (50V, 36 0:36 PREOP + EP7211-0034 1K. MDP742 Servo-Motor-Endstufe mit OCT (50V, 4,5A 37 0:37 PREOP + EP7211-0034 1K. MDP742 Servo-Motor-Endstufe mit OCT (50V, 4,5A ethercat sdos Download and display the service data objects.\nUse with caution as this command can take a long time to fetch all data. It is advised to limit the download to the specific slave in question, with the -p \u0026lt;slaveID\u0026gt; parameter.\n ethercat pdos Similar to the sdos counterpart, this command will fetch the currently applied process data objects. To avoid excessive output, it is advised to limit the command to a single slave.\nethercat upload With this command the value of a register can be fetched.\nIf the type is not explicitly given, first issue ethercat -p \u0026lt;slaveID\u0026gt; sdos. This will allow implicit type handling.\n Example: Fetch content of register 0x8020, sub-register 0x05 from slave 32.\nethercat upload -m0 -p32 0x8020 0x05 0x03e8 1000 ethercat download With this command the value of a register can be set on the slave.\nIf the type is not explicitly given, first issue ethercat -p \u0026lt;slaveID\u0026gt; sdos. This will allow implicit type handling.\n Example: Set value of register 0x8010, sub-register 0x07 from slave 7 to 314.\nethercat download -m0 -p7 0x8010 0x07 314 ethercat states With this command a specific state of a slave can be forced, or at least an attempt to enter the specific state is made.\nThis is helpful when a slave is stuck, e.g. with an error. Rather than cycle the power of the entire controller, the slave can be set to \u0026lsquo;REBOOT\u0026rsquo;. This might be enough to recover.\nAlternatively, cycling to \u0026lsquo;INIT\u0026rsquo; and back to \u0026lsquo;OP\u0026rsquo; might also be attempted.\nA power cycling of the of the EtherCAT components is the last resort!\n "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/manual/troubleshooting/","title":"troubleshooting","tags":[],"description":"","content":"troubleshooting Due to the complexity an EtherCAT bus topology can assume, troubleshooting can be challenging. This guide should provide the basic means to diagnose simple errors and is by no means complete!\ncommand line interface A very powerful tool is provided through the command line. See a summary, incl. some examples of what possible here.\ntroubles with motors For motion related issues, a very short troubleshooting guide is provided here.\n"},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/manual/troubleshooting/motion/","title":"motion","tags":[],"description":"","content":"culprit From experience, very few issues are related to the EtherCAT hardware itself. Mostly the cabling or the actual motor/encoder hardware is to blame.\nEven more likely is human error, such as:\n wrong scaling of the axis writing to the wrong hardware (forgot to select the right slave in the axis config) \u0026hellip;  check the status Before anything is restarted or power cycled, check the status of the slaves. Either from a dedicated shell, or from within the iocsh.\nIf all slaves are in \u0026lsquo;OP\u0026rsquo; state, at least data is exchanged between the hardware and the master.\nDepending on the integrator and overview panel might exist. Consult this panel for further details. Remember, red is not necessarily a bad sign! It can also indicate that certain channels are not connected. Whether those channels should be connected is beyond the scope of this guide.\nrestarting the IOC Blindly restarting the IOC, with only partially working EtherCAT hardware, WILL RESULT IN TOTAL FAILURE OF THE IOC!!!\n Check the hardware BEFORE restarting the IOC!\nforce manual motion  This procedure is for experst only. You run the risk of destroying expansive devices! Limit switches are not obeyed! YOU HAVE BEEN WARNED!\n In case the hardware is fine, the cables are checked, human error is mostly excluded, or the system used to work but doesn\u0026rsquo;t work any longer, directly writing to the drive is possible.\nFor this however, the IOC needs to be reconfigured to not link the hardware to an axis!\n Edit the startup script and comment out the axis, just leave the slave configuration. restart the IOC check the PVs for the drive in question (slave 7 in this case) dbgrep \u0026quot;*s007*\u0026quot; There should be two PVs ending with, -Drv01-Cmd and -Drv01-Spd Set -Drv01-Cmd to 1 and check the amplifier did enable, if you don\u0026rsquo;t know how to check for an enabled amplifier, you should not use this command! After the amplifier is engaged, write a small number to -Drv01-Spd. Dependinf on the scaling, the number might be in the range of 1..1000. Observe the encoder, or in case of open-loop, the device itself.  "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/manual/axis/axisyaml/","title":"axis yaml configuration","tags":[],"description":"","content":"Since ecmccfg v7, the axis configuration is based on yaml files. Backwards compatibility for classic EPICS environment variable based configuration is assured for legacy systems.\n yaml is - like python - indentation sensitive!\n Indent with 2 spaces.\n introduction  python 3.x is required\n The config is processed by a python script with a jinja2 backend. The processor will complain if mandatory keys are missing. Likewise, missing optional keys are populated with default values.\nThe script invokes a python script which subsequently uses a jinja2 processor to render the respective templates. The script will create a python virtual environment and install the required libraries automatically.\n The configuration is separated into the following mandatory sections:\n axis motorRecord drive encoder controller trajectory input  in addition the following optional sections are available.\n output homing monitoring  Each sections provides an example, the optional keys are commented.\n axis mandatory\n id: unique numeric identifier of the axis  optional\n type: for future used mode: operating mode of the drive; default CSV parameters: additional parameters  axis: id: 1 # type: joint # this is for future selection of axis type # mode: CSV # supported mode, CSV and CSP; WIP # parameters: powerAutoOnOff=2;powerOnDelay=6.0;powerOffDelay=1.0; epics Epics configuration.\nThe Epics motorRecord can now be disabled.\n mandatory\n name: name of the PV  optional\n precision: PREC field; default 3 unit: EGU field; optional default mm motorRecord  enable: set to false to disable motorRecord description: DESC field; default '' fieldInit: string with additional field initial values; default ''    epics: name: M1 # precision: 3 # unit: deg # motorRecord: # enable: false # fieldInit: \u0026#39;RRES=1.0,RTRY=2,RMOD=1,UEIP=0,RDBD=0.1,URIP=1,RDBL=$(IOC):$(ECMC_MOTOR_NAME)-PosActSim\u0026#39; # fieldInit: \u0026#39;NTM=1\u0026#39; # description: AM8111 CSV drive mandatory\n numerator: scaling numerator denominator: scaling denominator type: type of drive: 0=stepper, 1=DS402, aka servo or complex stepper control: control word entry status: status word entry setpoint: setpoint entry, position or velocity, depending on mode  optional\n reduceTorque: control word bit to set for reduced torque mode brake  openDelay: number of cycles to wait after enable to disengage the brake closeAhead: number of cycles to wait after the brake was engaged   reset: control word bit to set in order to reset the drive warning: status word bit for drive warning error: list of status bits for drive errors  drive: numerator: 2880000 # Fastest speed in engineering units denominator: 2147483648 # I/O range for ECMC_EC_ALIAS_DRV_VELO_SET type: 1 # Stepper: 0, DS402: 1 (DS402 = servos and advanced stepper drives) control: ec0.s$(DRV_SLAVE).driveControl01 status: ec0.s$(DRV_SLAVE).driveStatus01 setpoint: ec0.s$(DRV_SLAVE).velocitySetpoint01 # reduceTorque: 2 # Reduce torque bit in drive control word # brake: # openDelay: 0 # Brake timing parameter in EtherCAT cycles # closeAhead: 0 # Brake timing parameter in EtherCAT cycles # reset: 1 # Reset bit in control word # warning: 2 # Warning bit of status word # error: # max 3 # - 3 # Error 0 bit of status word # - 7 # Error 1 bit of status word # - 14 # Error 2 bit of status word encoder mandatory\n numerator: scaling numerator, equivalent distance to the maximum drive frequency (default: 2000 Hz i.e. 2000 full steps), also effectively absolute maximum velocity denominator: scaling denominator type: type of encoder: 0=incremental, 1=absolute bits: raw data bit count absBits: Absolute bit count (for absolute encoders) always least significant part of \u0026lsquo;bits\u0026rsquo; absOffset: Encoder offset in engineering units (for absolute encoders) position: position entry  optional\n control: control word entry; mandatory when reset is set. status: status word entry; mandatory when error or warning are set reset: control word bit to set in order to reset the encoder warning: status word bit for encoder warning error: list of status bits for encoder errors velocityFilterSize: size of the velocity filter (cycles) positionFilterSize: size of the position filter (cycles) positionFilterEnable: position filter enable latch:  position: '' control: '' status: ''    encoder: numerator: 360 denominator: 1048576 type: 1 # Type: 0=Incremental, 1=Absolute bits: 32 # Total bit count of encoder raw data absBits: 25 # Absolute bit count (for absolute encoders) always least significant part of \u0026#39;bits\u0026#39; absOffset: 0 # Encoder offset in eng units (for absolute encoders) position: ec0.s$(DRV_SLAVE).positionActual01  # Ethercat entry for actual position input (encoder) # control: ec0.s$(ENC_SLAVE).encoderControl01 # mandatory only if \u0026#39;reset\u0026#39; is used # status: ec0.s$(DRV_SLAVE).encoderStatus01 # mandatory only if \u0026#39;warning\u0026#39; or \u0026#39;error\u0026#39; are used # reset: 1 # Reset (optional) # warning: 2 # Warning (optional) # error: # max 3 (optional) # - 5 # Error 0 # - 9 # Error 1 # - 11 # Error 2 # velocityFilterSize: 100 # positionFilterSize: 1 # positionFilterEnable: false # latch: # position: \u0026#39;\u0026#39; # control: \u0026#39;\u0026#39; # status: \u0026#39;\u0026#39; optional\n velocityFilterSize: Add filtering if the encoder is too coarse to reliably determine velocity each PLC cycle  controller PID controller parameters\nmandatory\n Kp: proportional  optional\n Ki: integral; default 0 Kd: differential; default 0 Kff: feed forward; default 1  controller: Kp: 90 # Ki: 0.1 # Kd: 0 # Kff: 1 trajectory settings for the trajectory planning.\nAll accelerations are now defined in EGU s^{-2}\n mandatory\n axis  velocity: velocity setpoint the axis will be initialized to (in EGU/sec) acceleration: acceleration setpoint for initialization (in EGU/sec2) emergencyDeceleration: deceleration setpoint for emergencies. Defaults to acceleration setpoint if not specified.    optional\n jog  velocity: velocity setpoint the axis will be initialized to for jogging acceleration: acceleration setpoint for initialization, for jogging   modulo  range: modulo range type: modulo type    trajectory: axis: velocity: 180 acceleration: 180 deceleration: 360 # emergencyDeceleration: 0.05 # jog: # velocity: 90 # acceleration: 0.1 # modulo: # range: 0 # type: 0 input Links to the binary input sensors for limit switches, home sensor and external interlock. All four inputs must be provided. If an input is not used, set it to the ONE.0 entry of a slave. See the example for details.\nmandatory\n limit  forward: limit switch sensor input in the forward direction. backward: limit switch sensor input in the backward direction.   home: binary input for the home sensor extinterlock: binary input for external interlock.  input: limit: forward: ec0.s$(DRV_SLAVE).ONE.0  # Ethercat entry for low limit switch input backward: ec0.s$(DRV_SLAVE).ONE.0  # Ethercat entry for high limit switch input home: ec0.s$(DRV_SLAVE).ONE.0  # Ethercat entry for home switch input interlock: ec0.s$(DRV_SLAVE).ONE.0  # Ethercat entry for interlock switch input output Two outputs can be utilizes with ECMC.\noptional\n health: sum parameter for axis health brake: brake output  # output: # health: \u0026#39;\u0026#39; # Ethercat entry for health output # brake: \u0026#39;ec0.s42.binaryOutput07\u0026#39; # Ethercat entry for brake output homing This section is should be obsolete at PSI, as for all new installation using EtherCAT, absoulte encoders are mandatory. In case a legacy system or temporary installation requires a incremental encoder, or even open loop operation, several procedures for referencing are available.\noptional\n type: referencing procedure position: position of the reference mark in engineering units postMoveEnable: post homing move postMovePosition: post homing move target switchPolarity: home switch polarity, for NO switches latchCount: latch counter velocity: velocities  to: to the cam from: off the cam   acceleration: acceleration time in s deceleration: deceleration time in s  # homing: # type: 3 # position: 0 # postMoveEnable: false # postMovePosition: 0 # switchPolarity: 0 ## 0: NC, 1: NO # latchCount: 0 # velocity: # to: 2.72 # # from: 3.14 # # acceleration: 2 # # deceleration: 5 softlimits Soft limits to propagate to the motorRecord.\noptional\n enable: enable soft limits. forward: soft limit in the forward direction backward: soft limit in the backward direction  # softlimits: # enable: false # forward: \u0026#39;\u0026#39; # backward: \u0026#39;\u0026#39; monitoring Three entities can be monitored, (1) lag, aka following error, (2) target, aka in position, (3) velocity.\nIt is highly advisable to always use the lag and attarget monitoring fo closed-loop axis. Failure to do so, will most likely results in unexpected behaviour.\n optional\n lag  enable: enable lag monitoring tolerance: tolerance in engineering units time: time for the condition to be true in ms   target  enable: enable target monitoring tolerance: tolerance in engineering units time: time for the condition to be true in ms   velocity  enable: enable velocity monitoring max: upper limit for velocity time  trajectory: time for the condition to be in violation in ms drive: time for the condition to be in violation in ms      monitoring: # lag: # enable: false # tolerance: 5 # time: 100 # target: # enable: true # tolerance: 0.125 # time: 100 # velocity: # enable: false # max: 100 # time: # trajectory: 100 # drive: 200 "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/manual/plc/","title":"PLC","tags":[],"description":"","content":"In ECMC, PLCs are a very powerful tool to handle EtherCAT data in real-time.\nSince ecmccfg v7, the PLCs can be instantiated from:\n pure yaml files or text files, with yaml header.  Backwards compatibility for classic, text based PLCs is assured.\n yaml is - like python - indentation sensitive!\n Indent with 2 spaces.\n pure yaml All keys are mandatory.\n id: PLC id, unique uint enable: PLC enabled at start rateMilliseconds: execution rate in ms. To execute every cycle, independant of cycle rate, use -1. code: dictionary of code lines.  Line terminator is still a pipe |, this is subject to change!\n For more complex PLCs, it is highly advisable to use text based PLC definitions with a yaml header.\n plc: id: 1 enable: no rateMilliseconds: 10 code: - \u0026#39;ec0.s2.binaryOutput07:=global.test|\u0026#39; - \u0026#39;${PLC_ID}.enable:=plc0.enable|\u0026#39; - \u0026#39;ec0.s2.binaryOutput05:=not(ec0.s2.binaryOutput05)|\u0026#39; - \u0026#39;plc1.error:=12345|\u0026#39; yaml header Instead of the code dictionary, the file key can be used to load the PLC from a text file. The syntax of the text PLCs is kept from earlier versions.\nAll keys are mandatory.\n id: PLC id, unique uint enable: PLC enabled at start rateMilliseconds: execution rate in ms. To execute every cycle, independant of cycle rate, use -1. file: PLC text file to load.  If the file key is set, all definitions in the code dictionary are overwritten.\n  yaml header\n plc: id: 1 enable: yes rateMilliseconds: 10 file: plc1.plc  PLC file\n # this is a comment println(\u0026#39;plc1 from file\u0026#39;); println(\u0026#39;plc1 from file # hash with inline comment\u0026#39;); # inline test static.i:=static.i+1; # counter println(\u0026#39;i = # + - * / \u0026#39;, static.i); # println  iocsh call\n ${SCRIPTEXEC} \u0026#34;${ECMC_CONFIG_ROOT}loadYamlPlc.cmd\u0026#34; \u0026#34;FILE=./plc1File.yaml, ECMC_TMPDIR=/tmp/\u0026#34; "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/manual/plc/plcsyntax/","title":"PLC syntax help","tags":[],"description":"","content":"In ECMC, PLCs are based on the exprtk expression evaluation library. For detailed syntax help please visit the exprtk website\ncommon errors, misconceptions and info operators  :=: assignment = or ==: equal comparison  functions PLC do not immediately write to the bus! The PLC will excecute synchronous to the cycle, or at an integer fraction of it. The prcessed data will be send to the bus with the next cycle. PLCs do not delay the bus!\nstatement terminator Statements are terminated by a semicolon ;\nvariables All variables are initiated to 0\ncomments The hash charactoer # is reserved for comments. Everything after this char will be removed before compile. println('########'); will be seen by the compiler as println(' !\n macros So far macro substitution is not implemented for yaml!\n If macro substitution is needed, please use the traditional approach using loadPLCFile.cmd, with the PLC_MACROS variable.\n examples PLC can access:\n variables process data axis PLCs data storage  Function examples are given at the end.\ngeneral # # 1. Assignment: # ec0.s1.VALUE:=100; # # 2. if-else (note the equl sign): # if(ec0.s1.VALUE=100) { # # code # } # else { # # code # }; # # 3. for loop: # for (static.i := 0; static.i \u0026lt; static.elements; static.i += 1) { # # code # }; # # 4. printouts (minimize printouts or use only for debug): # print(\u0026#34;The value of ec0.s1.VALUE is: \u0026#34;,ec0.s1.VALUE); # Without line feed # println(\u0026#34;The value of ec0.s1.VALUE is: \u0026#34;,ec0.s1.VALUE); # With line feed # # Also see the \u0026#34;ec_print_bin()\u0026#34; and \u0026#34;ec_print_hex()\u0026#34; below. variables Below the ECMC specific accessible variables and functions are listed:\n# 1. static.\u0026lt;varname\u0026gt; Static variable. Initiated to 0. (rw)  # Access only in the PLC where defined. # Will keep value between execution # loops. # 2. global.\u0026lt;varname\u0026gt; Global variable. Initiated to 0. (rw) # Access from all PLCs. # Will keep value between execution # loops. # 3. var \u0026lt;varname\u0026gt; Local variable (exprtk syntax) (rw) # Will NOT keep value between # execution loops. process data # EtherCAT data: # 1. ec\u0026lt;ecid\u0026gt;.s\u0026lt;sid\u0026gt;.\u0026lt;alias\u0026gt; ethetcat data (rw) # ecid: ethercat master index # sid: ethercat slave bus position # alias: entry name as defined in # \u0026#34;Cfg.EcAddEntryComplete() # 2. ec\u0026lt;ecid\u0026gt;.masterstatus Status of master (1=OK) axis # Motion variables: # 1. ax\u0026lt;id\u0026gt;.id axis id (ro) # 2. ax\u0026lt;id\u0026gt;.reset reset axis error (rw) # 3. ax\u0026lt;id\u0026gt;.counter execution counter (ro) # 4. ax\u0026lt;id\u0026gt;.error error (ro) # 5. ax\u0026lt;id\u0026gt;.allowplccmd Allow writes to axis from PLC (rw) # 6. ax\u0026lt;id\u0026gt;.enc.actpos actual position (ro) # 7. ax\u0026lt;id\u0026gt;.enc.extactpos actual position from plc sync. # expression (ro) # 8. ax\u0026lt;id\u0026gt;.enc.actvel actual velocity (ro) # 9. ax\u0026lt;id\u0026gt;.enc.rawpos actual raw position (ro) # 10. ax\u0026lt;id\u0026gt;.enc.source internal source or expressions (rw) # source = 0: internal encoder # source \u0026gt; 0: actual pos from expr # 11. ax\u0026lt;id\u0026gt;.enc.homed encoder homed (rw) # 12. ax\u0026lt;id\u0026gt;.enc.homepos homing position (rw) # 13. ax\u0026lt;id\u0026gt;.traj.setpos curent trajectory setpoint (rw) # 14. ax\u0026lt;id\u0026gt;.traj.extsetpos current trajecrory setpoint from # plc sync. expression (ro) # 15. ax\u0026lt;id\u0026gt;.traj.targetpos target position (rw) # 16. ax\u0026lt;id\u0026gt;.traj.targetvel target velocity setpoint (rw) # 17. ax\u0026lt;id\u0026gt;.traj.targetacc target acceleration setpoint (rw) # 18. ax\u0026lt;id\u0026gt;.traj.targetdec target deceleration setpoint (rw) # 19. ax\u0026lt;id\u0026gt;.traj.setvel current velocity setpoint (ro) # 20. ax\u0026lt;id\u0026gt;.traj.setvelffraw feed forward raw velocity (ro) # 21. ax\u0026lt;id\u0026gt;.traj.command command (rw) # command=1: move velocity  # command=2: move rel. pos # command=3: move abs. pos # command=10: homing # 22. ax\u0026lt;id\u0026gt;.traj.cmddata cmddat. Homing procedure # only valid if ax\u0026lt;id\u0026gt;.traj.command=10 # cmddata=1 : ref low limit # cmddata=2 : ref high limit # cmddata=3 : ref home sensor # (via low limit) # cmddata=4 : ref home sensor # (via high limit) # cmddata=5 : ref center of home sensor # (via low limit) # cmddata=6 : ref center of home sensor # (via high limit) # cmddata=15 : direct homing # cmddata=21 : ref partly abs. encoder # (via low limit). # ref at abs bits. # over/under-flow.. # cmddata=22 : ref partly abs. encoder # (via high limit). # ref at abs bits. # over/under-flow.. # 23. ax\u0026lt;id\u0026gt;.traj.source internal source or expressions (rw) # source = 0: internal traj # source \u0026gt; 0: setpoints from expr # 24. ax\u0026lt;id\u0026gt;.traj.execute execute motion command (rw) # 25. ax\u0026lt;id\u0026gt;.traj.busy axis busy (ro) # 26. ax\u0026lt;id\u0026gt;.traj.dir axis setpoint direction (ro) # ax\u0026lt;id\u0026gt;.traj.dir\u0026gt;0: forward # ax\u0026lt;id\u0026gt;.traj.dir\u0026lt;0: backward # ax\u0026lt;id\u0026gt;.traj.dir=0: standstill # 27. ax\u0026lt;id\u0026gt;.cntrl.error actual controller error (ro) # 28. ax\u0026lt;id\u0026gt;.cntrl.poserror actual position error (ro) # 29. ax\u0026lt;id\u0026gt;.cntrl.output actual controller output (ro) # 30. ax\u0026lt;id\u0026gt;.drv.setvelraw actual raw velocity setpoint (ro) # 31. ax\u0026lt;id\u0026gt;.drv.enable enable drive command (rw) # 32. ax\u0026lt;id\u0026gt;.drv.enabled drive enabled (ro) # 33. ax\u0026lt;id\u0026gt;.seq.state sequence state (homing) (ro) # 34. ax\u0026lt;id\u0026gt;.mon.ilock motion interlock (both dir) (rw) # ax\u0026lt;id\u0026gt;.mon.ilock=1: motion allowed # ax\u0026lt;id\u0026gt;.mon.ilock=0: motion not allowed  # 35. ax\u0026lt;id\u0026gt;.mon.ilockbwd motion interlock bwd dir (rw) # ax\u0026lt;id\u0026gt;.mon.ilockbwd=1: motion allowed # ax\u0026lt;id\u0026gt;.mon.ilockbwd=0: motion not allowed  # 36. ax\u0026lt;id\u0026gt;.mon.ilockfwd motion interlock fwd dir (rw) # ax\u0026lt;id\u0026gt;.mon.ilockfwd=1: motion allowed # ax\u0026lt;id\u0026gt;.mon.ilockfwd=0: motion not allowed  # 37. ax\u0026lt;id\u0026gt;.mon.attarget axis at taget (ro) # 38. ax\u0026lt;id\u0026gt;.mon.lowlim low limit switch (ro) # 39. ax\u0026lt;id\u0026gt;.mon.highlim high limit switch (ro) # 40. ax\u0026lt;id\u0026gt;.mon.homesensor home sensor (ro) # 41. ax\u0026lt;id\u0026gt;.mon.lowsoftlim low soft limit (rw) # 42. ax\u0026lt;id\u0026gt;.mon.highsoftlim high soft limit (rw) # 43. ax\u0026lt;id\u0026gt;.mon.lowsoftlimenable low soft limit enable (rw) # 44. ax\u0026lt;id\u0026gt;.mon.highsoftlimenable high soft limit enable (rw) # 45. ax\u0026lt;id\u0026gt;.blockcom Enables/disables \u0026#34;set\u0026#34; commands (rw) # via command parser (ascii commands) # Statuses can still be read. # Exceptions (\u0026#34;set\u0026#34;-commands) that # will work: # - \u0026#34;StopMotion(axid)\u0026#34; # - \u0026#34;Cfg.SetAxisBlockCom(axid,block)\u0026#34; PLC # PLC variables: # 1. plc\u0026lt;id\u0026gt;.enable plc enable (rw) # (end exe with \u0026#34;plc\u0026lt;id\u0026gt;.enable:=0#\u0026#34; # Could be usefull for startup # sequences) # 2. plc\u0026lt;id\u0026gt;.error plc error (rw) # Will be forwarded to user as # controller error. # 3. plc\u0026lt;id\u0026gt;.scantime plc sample time in seconds (ro) # 4. plc\u0026lt;id\u0026gt;.firstscan true during first plc scan only (ro) # usefull for initiations of variables # 5. ax\u0026lt;id\u0026gt;.plc.enable Same as plc\u0026lt;id\u0026gt;.enable but for # axis \u0026lt;id\u0026gt; sync plc. # 6. ax\u0026lt;id\u0026gt;.plc.error Same as plc\u0026lt;id\u0026gt;.error but for # axis \u0026lt;id\u0026gt; sync plc. # 7. ax\u0026lt;id\u0026gt;.plc.scantime Same as plc\u0026lt;id\u0026gt;.scantime but for # axis\u0026lt;id\u0026gt; sync plc. # 8. ax\u0026lt;id\u0026gt;.plc.firstscan Same as plc\u0026lt;id\u0026gt;.firstscan but for # axis \u0026lt;id\u0026gt; sync plc. data storage # Data Storage variables: # 1. ds\u0026lt;id\u0026gt;.size Set/get size of data storage (rw) # Set will clear the data storage # 2. ds\u0026lt;id\u0026gt;.append Add new data at end (rw) # Current position index will be # increased # 3. ds\u0026lt;id\u0026gt;.data Set/get data ar current position (rw) # 4. ds\u0026lt;id\u0026gt;.index Set/get current position index (rw) # 5. ds\u0026lt;id\u0026gt;.error Data storage class error (ro) # 6. ds\u0026lt;id\u0026gt;.clear Data buffer clear (set to zero) (ro) # 7. ds\u0026lt;id\u0026gt;.full True if data storage is full (ro) functions # Function Lib: EtherCAT # 1. retvalue = ec_set_bit( # \u0026lt;value\u0026gt;, : Value to change # \u0026lt;bitindex\u0026gt; : Bit index # ); # Sets bit at bitindex position of value. Returns the new value. # # 2. retvalue = ec_wrt_bit( # \u0026lt;value\u0026gt;, : Value to change # \u0026lt;wrtValue\u0026gt;, : Value of bit to write # \u0026lt;bitindex\u0026gt; : Bit index # ); # Write wrtValue to a bit at bitindex position of value. Returns the new value. # # 3. retvalue = ec_wrt_bits( # \u0026lt;value\u0026gt;, : Value to change # \u0026lt;wrtValue\u0026gt;, : Value of bit to write # \u0026lt;startBit\u0026gt; : Start bit index (lsb is bit 0) # \u0026lt;stopBit\u0026gt; : Stop bit index # ); # Write wrtValue to a range of bits (statBit..stopBit) of value. Returns the new value. # # 4. retvalue = ec_clr_bit( # \u0026lt;value\u0026gt;, : Value to change # \u0026lt;bitindex\u0026gt; : Bit index # ); # Clears bit at bitindex position of value. Returns the new value. # # 5. retvalue = ec_flp_bit( # \u0026lt;value\u0026gt;, : Value to change # \u0026lt;bitindex\u0026gt; : Bit index # ); # Flips bit at bitindex position of value. Returns the new value. # # 6. retvalue = ec_chk_bit( # \u0026lt;value\u0026gt;, : Value to change # \u0026lt;bitindex\u0026gt; : Bit index # ); # Checks bit at bitindex position of value. Returns the value of bit. # # 7. retvalue = ec_chk_bits( # \u0026lt;value\u0026gt;, : Value to change # \u0026lt;startBit\u0026gt; : Start bit index (lsb is bit 0) # \u0026lt;stopBit\u0026gt; : Stop bit index # ); # Checks range of bits (startBit..stopBit) of value. Returns the value of bits. # # 8. retvalue = ec_print_hex( # \u0026lt;value\u0026gt;, : Value to print # \u0026lt;startBit\u0026gt; : Start bit index # \u0026lt;stopBit\u0026gt; : Stop bit index # ); # Prints \u0026lt;startBit\u0026gt; to \u0026lt;stopBit\u0026gt; of \u0026lt;value\u0026gt; in hex format # Returns error code or 0 if success.# # # 9. retvalue = ec_print_bin( # \u0026lt;value\u0026gt;, : Value to print # \u0026lt;startBit\u0026gt; : Start bit index # \u0026lt;stopBit\u0026gt; : Stop bit index # ); # Prints \u0026lt;startBit\u0026gt; to \u0026lt;stopBit\u0026gt; of \u0026lt;value\u0026gt; in bin format # Returns error code or 0 if success. # # 10. retvalue = ec_mm_cp( # \u0026lt;srcId\u0026gt;, : Source memmap index # \u0026lt;sdestId\u0026gt; : Dest memmap index # ); # Copies data from source memmap to dest memmap. The memmap ids are defined by the # order they are created (starting at 0). The smallest memmap size will define the # amout of data copied. Returns 0 for success or an error code. # # 11. retvalue = ec_get_mm_type( # \u0026lt;srcId\u0026gt;, : Source memmap index # ); # # Returns data type of memmap: # 0 = Not defined (Use \u0026#34;Cfg.EcAddMemMapDT()\u0026#34; instead of \u0026#34;Cfg.EcAddMemMap()\u0026#34;) # 1 = (Not valid for memmap) # 2 = (Not valid for memmap) # 3 = (Not valid for memmap) # 4 = (Not valid for memmap) # 5 = U8 # 6 = S8 # 7 = U16 # 8 = S16 # 9 = U32 # 10 = S32 # 11 = U64 # 12 = S64 # 13 = F32 # 14 = F64 # # 12. retvalue = ec_get_mm_data( # \u0026lt;srcId\u0026gt;, : Source memmap index # \u0026lt;index\u0026gt; : Index of data element # ); # # Reads data element at index from memmap with srcId and returns value. # # 13. retvalue = ec_set_mm_data( # \u0026lt;srcId\u0026gt;, : Source memmap index # \u0026lt;index\u0026gt; : Index of data element # \u0026lt;data\u0026gt; : Data to write # ); # # Writes data element at index from memmap with srcId. Returns 0 for success or an error code. # # 14. retvalue = ec_get_mm_size( # \u0026lt;srcId\u0026gt;, : Source memmap index # ); # # Returns number of elements (of type \u0026#34;ec_get_mm_type()\u0026#34;)in memmap with srcId. # If return value is less than zero it should be considered to be an error code. # # 14. retvalue = ec_mm_ds_append( # \u0026lt;mmId\u0026gt;, : Source memmap index # \u0026lt;dsId\u0026gt;); : Destination data storage index # # Returns Error code or zero if success # # 15. retvalue = ec_mm_append_to_ds_scale_offset( # \u0026lt;mmId\u0026gt;, : Source memmap index # \u0026lt;dsId\u0026gt; : Destination data storage index # \u0026lt;scale\u0026gt; : Scale # \u0026lt;offset\u0026gt;); : Offset # # 16. retvalue = ec_mm_push_asyn( # \u0026lt;mmId\u0026gt;) : Source memmap index. # # push memap to epics (can be used if T_SMP_MS=-1 for the param) # The mmId can be retrived by the bellow ecmc command (and feed into plc via macro): # ecmcConfig \u0026#34;EcGetMemMapId(ec0.s11.mm.CH1_ARRAY_IN)\u0026#34; # epicsEnvSet(MM_CH_1_IN,${ECMC_CONFIG_RETURN_VAL}) # # 17. retvalue = ec_get_time(); # # Returns current time in nano seconds (from 1 Jan 2000, same as EtherCAT DC:s). # If return value is less than zero it should be considered to be an error code. # # # 18. retvalue = ec_get_time_l32(); # # Returns lower 32 bits of current time in nano seconds (from 1 Jan 2000, same as EtherCAT DC:s). # If return value is less than zero it should be considered to be an error code. # # 19. retvalue = ec_get_time_u32(); # # Returns upper 32 bits of current time in nano seconds (from 1 Jan 2000, same as EtherCAT DC:s). # If return value is less than zero it should be considered to be an error code. # # 20. retvalue=ec_get_err(): # # Returns error code from last lib call. # # 21. retvalue=ec_err_rst(): # # Resets error code for ec_lib. # # Function Lib: Motion # 1. retvalue = mc_move_abs( # \u0026lt;axIndex\u0026gt;, : Axis index # \u0026lt;execute\u0026gt;, : Trigger # \u0026lt;pos\u0026gt;, : Target position # \u0026lt;vel\u0026gt;, : Target velocity # \u0026lt;acc\u0026gt;, : Acceleration # \u0026lt;dec\u0026gt; : Deceleration # ): # Absolute motion of axis. # Motion is triggerd with a positive edge on \u0026lt;execute\u0026gt; input. # returns 0 if success or error code. #  # 2. retvalue = mc_move_rel( # \u0026lt;axIndex\u0026gt;, : Axis index # \u0026lt;execute\u0026gt;, : Trigger # \u0026lt;pos\u0026gt;, : Target position # \u0026lt;vel\u0026gt;, : Target velocity # \u0026lt;acc\u0026gt;, : Acceleration # \u0026lt;dec\u0026gt; : Deceleration # ); # # Relative motion of axis \u0026lt;axIndex\u0026gt;. # Motion is triggerd with a positive edge on \u0026lt;execute\u0026gt; input. # returns 0 if success or error code. # # 3. retvalue = mc_move_ext_pos( # \u0026lt;axIndex\u0026gt;, : Axis index # \u0026lt;execute\u0026gt;, : Trigger # \u0026lt;vel\u0026gt;, : Target velocity # \u0026lt;acc\u0026gt;, : Acceleration # \u0026lt;dec\u0026gt; : Deceleration # ); # Move to current external plc position. Functions intended use is to # move to the start position for syncronized axes. This command is exactly # the same as issueing \u0026#34;mc_move_pos()\u0026#34; with the target postion ax\u0026lt;id\u0026gt;.traj.extsetpos. # Motion is triggerd with a positive edge on \u0026lt;execute\u0026gt; input. # returns 0 if success or error code. # # 4. retvalue = mc_move_vel( # \u0026lt;axIndex\u0026gt;, : Axis index # \u0026lt;execute\u0026gt;, : Trigger # \u0026lt;vel\u0026gt;, : Target velocity # \u0026lt;acc\u0026gt;, : Acceleration # \u0026lt;dec\u0026gt; : Deceleration # ); # Constant velocity motion of axis \u0026lt;axIndex\u0026gt;. # Motion is triggerd with a positive edge on \u0026lt;execute\u0026gt; input. # returns 0 if success or error code. # # 5. retvalue = mc_home( # \u0026lt;axIndex\u0026gt;, : Axis index # \u0026lt;execute\u0026gt;, : Trigger # \u0026lt;seqId\u0026gt;, : Motion sequence # \u0026lt;velTwoardsCam\u0026gt;, : Target Velocity twords cam # \u0026lt;velOffCam\u0026gt; : Target velocity off cam # ); # Perform a homing sequence of axis \u0026lt;axIndex\u0026gt;. # Motion is triggerd with a positive edge on \u0026lt;execute\u0026gt; input. # returns 0 if success or error code. # # 6. retvalue = mc_home_pos( # \u0026lt;axIndex\u0026gt;, : Axis index # \u0026lt;execute\u0026gt;, : Trigger # \u0026lt;seqId\u0026gt;, : Motion sequence # \u0026lt;velTwoardsCam\u0026gt;, : Target Velocity twords cam # \u0026lt;velOffCam\u0026gt; : Target velocity off cam # \u0026lt;homePos\u0026gt; : Homing position # ); # Perform a homing sequence of axis \u0026lt;axIndex\u0026gt; # Motion is triggerd with a positive edge on \u0026lt;execute\u0026gt; input. # returns 0 if success or error code. # # 7. retvalue = mc_halt( # \u0026lt;axIndex\u0026gt;, : Axis index # \u0026lt;execute\u0026gt;, : Trigger # ); # Stop motion of axis \u0026lt;axIndex\u0026gt;. # Motion is triggerd with a positive edge on \u0026lt;execute\u0026gt; input. # returns 0 if success or error code. # Note/Warning: This function will not stop a syncronized motion. # # 8. retvalue = mc_power( # \u0026lt;axIndex\u0026gt;, : Axis index # \u0026lt;enable\u0026gt;, : Enable power # ); # Enable power of axis \u0026lt;axIndex\u0026gt;. # Motion is triggerd with a positive edge on \u0026lt;execute\u0026gt; input. # returns 0 if success or error code. # # 9. retvalue = mc_get_busy( # \u0026lt;axIndex\u0026gt;, : Axis index#  # ); # Check if axis is busy. # # returns busy state of axis (1 if busy and 0 if not busy). # # 10. retvalue = mc_get_homed( # \u0026lt;axIndex\u0026gt;, : Axis index#  # ); # Check if axis is homed. # # returns state of homed flag of axis (1 if homed and 0 if not homed). # # 11. retvalue = mc_get_err(); # Returns error code for last lib call. #  # 12. retvalue = mc_reset(\u0026lt;axIndex\u0026gt;); # Resets error of motion axis. #  # 13. retvalue = mc_get_axis_err(\u0026lt;axIndex\u0026gt;); # Returns motion axis error code. #  # 14. retvalue = mc_set_enable_motion_funcs( # \u0026lt;axIndex\u0026gt;, : Axis index # \u0026lt;enablePos\u0026gt;, : Enable positioning # \u0026lt;enableVelo\u0026gt;, : Enable const velo # \u0026lt;enableHome\u0026gt;, : Enable const homing # );  # Enables/disables motion functionalities. Returns error code. # # Function Lib: Data Storage # 1. retvalue = ds_append_data( # \u0026lt;dsIndex\u0026gt;, : Data storage index # \u0026lt;data\u0026gt;, : Data # ); # Append data to data storage. # returns 0 if success or error code. # # 2. retvalue = ds_clear_data( # \u0026lt;dsIndex\u0026gt;, : Data storage index # ); # Clear data to data storage. # returns 0 if success or error code. # # 3. retvalue = ds_get_data( # \u0026lt;dsIndex\u0026gt;, : Data storage index # \u0026lt;bufferIndex\u0026gt;, : Buffer index # ); # Returns data from buffer. # # 4. retvalue = ds_set_data( # \u0026lt;dsIndex\u0026gt;, : Data storage index # \u0026lt;bufferIndex\u0026gt;, : Buffer index # ); # Sets data in data storage buffer. # returns 0 if success or error code. # # 5. retvalue = ds_get_buff_id( # \u0026lt;dsIndex\u0026gt;, : Data storage index # ); # Returns current buffer index. # # 6. retvalue = ds_set_buff_id( # \u0026lt;dsIndex\u0026gt;, : Data storage index # \u0026lt;bufferIndex\u0026gt;, : Buffer index # ); # Sets current buffer index in data storage buffer. # returns 0 if success or error code. # # 7. retvalue = ds_is_full( # \u0026lt;dsIndex\u0026gt;, : Data storage index # ); # Returns true if buffer is full. # # 8. retvalue = ds_get_size( # \u0026lt;dsIndex\u0026gt;, : Data storage index # ); # Returns buffer size of data storage. # # 9. retvalue = ds_get_err() # Returns error code for last lib call. #  # 10. retvalue = ds_push_asyn( # \u0026lt;dsIndex\u0026gt;, : Data storage index # ); # Triggers push of all asyn parameters in ds to EPICS (including data). # # 11. retvalue = ds_get_avg( # \u0026lt;dsIndex\u0026gt;, : Data storage index\\n # ); # Returns average of the values in the data storage.\\n # # 12. retvalue = ds_get_min( # \u0026lt;dsIndex\u0026gt;, : Data storage index\\n # ); # Returns minimum of the values in the data storage.\\n # # 13. retvalue = ds_get_max( # \u0026lt;dsIndex\u0026gt;, : Data storage index\\n # ); # Returns maximum of the values in the data storage.\\n # # 14. retvalue=ds_append_to_ds( # \u0026lt;dsFromId\u0026gt;, : Source data storage index\\n # \u0026lt;dsFromDataId\u0026gt;, : Source data element index\\n # \u0026lt;elements\u0026gt;, : Number of elements to copy \\n # \u0026lt;dsToId\u0026gt; : Destination data storage index\\n # ); # Appends data at the current position of the destination data storage (dsToId). The data source is defined by (dsFromId) and the selected position (dsFromDataId) and element count (elements) . # # 15. retvalue=ds_err_rst(): # Resets error code for ds_lib. # "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/manual/axis/axisplc/","title":"axis PLC","tags":[],"description":"","content":"introduction Each axis can have a native PLC. This PLC can be e.g. used for interlocking or synchronisation. The axis PLC is part of the yaml config. The code can be provided inline or in a separate file.\ninline plc: enable: yes externalCommands: yes code: - ax3.enc.actpos:=(ax1.enc.actpos+ax2.enc.actpos)/2 filter: velocity: enable: yes size: 100 trajectory: enable: yes size: 100 file plc: enable: yes externalCommands: yes file: cfg/heave.plc filter: velocity: enable: yes size: 100 trajectory: enable: yes size: 100 This is the respective plc file\nax${AXIS_NO}.enc.actpos:=(ax{{ var.ty1 }}.enc.actpos+ax{{ var.ty2 }}.enc.actpos)/2; Note the mixed use to MACROs ${AXIS_NO} and local variables {{ var.ty1 }} to boost flexibility.\n"},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/manual/axis/scaling/","title":"axis scaling","tags":[],"description":"","content":"By popular demand, the topic scaling will be discusses in closer detail.\nECMC has to scaling factors for each joint, firstly the drive scaling, secondly the encoder scaling.\nChanges to the scaling have direct effects on the Kp of the PID-loop. If the drive scaling is changes, make sure to adjust the PID parameters accordingly.\n drive scaling Drive scaling deals with the relation of the drive output (typically a 16- or 32-bit register) to axis velocity. Scaling is similar, but slighlty different for stepper drives and servo drives\nstepper motor drives The scaling for the Ex70xx slaves will be explained based on two very common examples.\nsimple linear axis Assumptions:\n 200 fullsteps/rev motor lead screw pitch: 5 mm/rev Register 0x8012:05 is set to 1 \u0026ndash;\u0026gt; 2000 fullsteps max step rate (default for ECMC, check for other slaves!) velocitySetpoint is in 16-bits.  drive: numerator: 50 # Fastest speed in engineering units (2000 full steps / s --\u0026gt; 10 rev/s * 50 mm/rev --\u0026gt; 50 mm/s) denominator: 32768 # I/O range 2^15, because 16-bit register, half is forward, the other half is backward Explanation The denominator is 32768 because the velocitySetpoint is a 16-register for the Beckhoff stepper drives. Thus, half of the full range is reserved for positive (forward) motion, the remaining half for negative (backward) motion. This means that at full output the motor would receive 2000 fullsteps per second. It is irrelevant whether the motor can actually spin this fast as this a purely theoretical value! Since we have established that the motor spins at 10 rev/s at full output, the conversion to engineering units is trivial and yields 50 mm/s, based on the lead screw pitch.\nrotational axis Assumptions:\n 400 fullsteps/rev motor drive train ratio: 180 rev/deg Register 0x8012:05 is set to 1 \u0026ndash;\u0026gt; 2000 fullsteps max step rate (default for ECMC, check for other slaves!) velocitySetpoint is in 16-bits.  drive: numerator: 37 # Fastest speed in engineering units (2000 full steps / s --\u0026gt; 5 rev/s * (180 rev/deg)^-1 --\u0026gt; 37 deg/s) denominator: 32768 # I/O range 2^15, because 16-bit register, half is forward, the other half is backward Explanation As before, at full output, the motor receives 2000 fullsteps/s. This results on 5 rev/s, due to the higher step count of the motor. The drive train ratio is specified as 180 motor revolutions per degree on the output. Hence, 180 rev/deg divided by 5 rev/s yields a velocity of 37 deg/s. Again, this is not the actual maximum velocity, it is purely theoretical scaling factor for the PID-loop!\nservo motor drives This section is based on the Beckhoff servo motor drives (Ex72xx), AX-drives or drives from other vendors might differ. The Ex72xx servo motor drives from Beckhoff use a 32-bit register for the velocity setpoint. Therefore, the denominator takes on a value of 2^31 = 2147483648.\nAs for the numerator, the situation is a bit more complicated. The AM81xx synchronous motors come with different pole counts, most have 3 pole pairs, but some have 4. Naturally, this results in a different scaling for either type. At full output a 3 pole pair motor would spin at 8000 revolutions per second! Respectively, the 4 pole pair motor will assume 6000 rev/s. Since no servo motor will ever reach such speeds and the value is only used for the PID-loop scaling, no difference is noticeable in real life applications. Except when a motor is replaced by a different model with deviating pole pair count.\nThe following example shows a 3 pole pair motor scaled for operation in degrees. Therefore, the numerator equals 8000 rev/s * 360 deg/rev = 2880000 deg/s.\ndrive: numerator: 2880000 # Fastest speed in engineering units (8000 rev/s * 360 deg/rev) denominator: 2147483648 # I/O range 2^31, because 32-bit register, half is forward, the other half is backward encoder scaling This scaling ratio describes the relation of encoder counts and engineering units of the axis.\nUnlike the drive scaling, the encoder scaling is much simpler. It represents merely the realtion between the observed counts on the encoder and the displacement of the load.\nclosed-loop Scaling absolute encoders is simple. This example shows a 32-bit encoder with 4096 ticks/mm, for an axis operated in mm.\nencoder: numerator: 1 denominator: 4096 type: 1 # Type: 0=Incremental, 1=Absolute bits: 32 # Total bit count of encoder raw data Explanation none, this should be simple enough!\nopen-loop Obviously, for open-loop operation there is no encoder. In this case the internal step counter of the stepper motor drive is used as \u0026ldquo;encoder\u0026rdquo;. In the example below such a case is presented, with an explanation.\nencoder: numerator: 0.125 # 0.125 mm/rev lead screw denominator: 12800 # 200 fullsteps/rev with 64 microsteps/fullstep type: 0 # Type: 0=Incremental, 1=Absolute bits: 16 # Total bit count of encoder raw data Explanation The internal step counter operates in microsteps. For most drives this value assumes 64, if uncertain consult the respective manual of the drive. In case of a 200 fullsteps/rev motor, the denominator therefore will be set to 200*64=12800. As for the numerator, this is simply the displacement observed for one full motor revolution. As the step counter is incremental, the type: 0 has to be set. The step counter is of type uint16, thus the bits: 16 setting, which is important to handle the over-/underflow.\n"},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/manual/axis/direction/","title":"direction of motion","tags":[],"description":"","content":"The direction of motion can be affected by multiple means. Namely, on the slave level, in the axis scaling or in the motorRecord.\nThe best option is to change the direction of motion on the slave level. The alternatives lead to unintuitive scaling factors or mismatch between ECMC and EPICS.\n EtherCAT slave ecmccfg allows SDOs to set individual SDOs in the startup-script of the IOC or in dedicated config files for slaves. As most slaves have a SDOs to invert the direction of motion or counting, it\u0026rsquo;s only natural to make use of this feature. The benefit of changing the direction on the slave is obvious. All axes move in there natural direction, as given by the machine coordinate system. Limit switches - consequently - are always where they belong, even non-experts can diagnose the device or system. Examples for encoder and drive are given below.\nConsult the respective slave manual for the correct SDO.\n encoder direction # slave 7 {ecmcEL5042} ${SCRIPTEXEC} ${ECMC_CONFIG_ROOT}configureSlave.cmd, \u0026#34;HW_DESC=EL5042, CONFIG=-Encoder-ch12-Renishaw_RL26BUT001B30V\u0026#34; # Reverse encoder direction of ch1 ecmcConfigOrDie \u0026#34;Cfg.EcAddSdo(${ECMC_EC_SLAVE_NUM},0x8008,0x1,1,1)\u0026#34; # Reverse encoder direction of ch2 ecmcConfigOrDie \u0026#34;Cfg.EcAddSdo(${ECMC_EC_SLAVE_NUM},0x8018,0x1,1,1)\u0026#34; drive direction # slave 18 {ecmcEL7041} ${SCRIPTEXEC} ${ECMC_CONFIG_ROOT}configureSlave.cmd, \u0026#34;HW_DESC=EL7041, CONFIG=-Motor-Phytron-VSS-42.200.2.5\u0026#34; # Reverse motor direction: ecmcConfigOrDie \u0026#34;Cfg.EcAddSdo(${ECMC_EC_SLAVE_NUM},0x8012,0x9,1,1)\u0026#34; ECMC scaling A negative numerator can be used to change the direction of motion. Refer to the scaling section for details.\nThis will result in negative values for MRES of the motorRecord.\n EPICS motorRecord The epics key of the axis config allows for motorRecord fields to be initialized. By initalizing the DIR field to Neg, the motorRecord will start inverted.\nepics: name: reveredAxis precision: 1 unit: deg motorRecord: enable: yes description: \u0026#34;inverted\u0026#34; fieldInit: \u0026#34;DIR=Neg\u0026#34;  This will affect the motorRecord only, thus ECMC internally is still moving in the wrong direction. You have been warned!\n "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/motion/ecmc_axis_sync_unset/","title":"","tags":[],"description":"","content":""},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/motion/ecmc_axis_unset/","title":"","tags":[],"description":"","content":""},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/motion/ecmc_virt_axis_unset/","title":"","tags":[],"description":"","content":""},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/scripts/empty/","title":"","tags":[],"description":"","content":""},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/startup/","title":"","tags":[],"description":"","content":""},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/categories/","title":"Categories","tags":[],"description":"","content":""},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/tags/","title":"Tags","tags":[],"description":"","content":""}]