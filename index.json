[{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/manual/build/","title":"build at PSI","tags":[],"description":"","content":" These instructions only work at PSI!\n Build at PSI, using driver.makefile by default this module is only build for Debian 10 and Epics \u0026gt;=R7.0.6\nbuild on login cluster make [LIBVERSION] [clean] [uninstall] install check a particular version check the module loads for version dev, Epics R7+ and ECMC version dev, note MASTER_ID=-1 which runs ECMC in master-less mode. Make proper adjustments to match your needs in terms of versions.\niocsh -7 -r \u0026#34;ecmccfg,dev \u0026#39;ECMC_VER=dev,MASTER_ID=-1\u0026#39;\u0026#34; "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/manual/","title":"manual","tags":[],"description":"","content":"ecmccfg A configuration framework for ECMC Motion Control Module for EPICS.\nPurpose The configuration framework contains the necessary files to configure an EPICS IOC for EtherCAT based motion control and DAQ.\n Topics  build at PSI   introduction   best practice   general   ecmc versions   knowledge base   motion   PLC    provided common user commands  addAxis.cmd addDataStorage.cmd addMaster.cmd addSlave.cmd addSlaveKL.cmd addVirtualAxis.cmd applyAxisSynchronization.cmd applyConfig.cmd applySlaveConfig.cmd configureAxis.cmd configureSlave.cmd configureVirtualAxis.cmd loadPLCFile.cmd loadPlugin.cmd setAppMode.cmd setDiagnostics.cmd  Example IOC  require the configuration module with optional version  require ecmccfg \u0026lt;VERSION\u0026gt; add a coupler and slave  # slave 0 {ecmcEK1100} ${SCRIPTEXEC} ${ECMC_CONFIG_ROOT}addSlave.cmd, \u0026#34;HW_DESC=EK1100\u0026#34; # SLAVE_ID is automatically incremented # slave 1 {ecmcEL1018} ${SCRIPTEXEC} ${ECMC_CONFIG_ROOT}addSlave.cmd, \u0026#34;HW_DESC=EL1018\u0026#34; # skip slaves 2..6 # slave 7 {ecmcEL2008}, with optional SLAVE_ID ${SCRIPTEXEC} ${ECMC_CONFIG_ROOT}addSlave.cmd, \u0026#34;HW_DESC=E2008, SLAVE_ID=7\u0026#34; #-- ATTENTION, this only work for certain slaves, as the EPICS templates have to be migrated before # slave 9 {ecmcEL2008}, with optional SLAVE_ID and P_SCRIPT ${SCRIPTEXEC} ${ECMC_CONFIG_ROOT}addSlave.cmd, \u0026#34;HW_DESC=E2008, SLAVE_ID=9, P_SCRIPT=mXsXXX\u0026#34; add more slaves and apply configuration to the slaves  # slave 10 {ecmcEL7062}, add slave and apply component ${SCRIPTEXEC} ${ecmccfg_DIR}addSlave.cmd, \u0026#34;HW_DESC=EL7062\u0026#34; ${SCRIPTEXEC} ${ecmccfg_DIR}applyComponent.cmd \u0026#34;COMP=Motor-Generic-2Phase-Stepper, CH_ID=1, MACROS=\u0026#39;I_MAX_MA=1000, I_STDBY_MA=100, U_NOM_MV=24000, R_COIL_MOHM=1230,L_COIL_UH=500\u0026#39;\u0026#34; ${SCRIPTEXEC} ${ecmccfg_DIR}applyComponent.cmd \u0026#34;COMP=Motor-Generic-2Phase-Stepper, CH_ID=2, MACROS=\u0026#39;I_MAX_MA=1000, I_STDBY_MA=100, U_NOM_MV=24000, R_COIL_MOHM=1230,L_COIL_UH=500\u0026#39;\u0026#34; # For two channel drives, both channels must be configured (ensure correct motor cfgs are used). If channel is not in use, then apply the \u0026#34;Generic-Ch-Not-Used\u0026#34; component. ${SCRIPTEXEC} ${ecmccfg_DIR}addSlave.cmd, \u0026#34;HW_DESC=EL7062\u0026#34; ${SCRIPTEXEC} ${ecmccfg_DIR}applyComponent.cmd \u0026#34;COMP=Motor-Generic-2Phase-Stepper, CH_ID=1, MACROS=\u0026#39;I_MAX_MA=1000, I_STDBY_MA=100, U_NOM_MV=24000, R_COIL_MOHM=1230,L_COIL_UH=500\u0026#39;\u0026#34; ${SCRIPTEXEC} ${ecmccfg_DIR}applyComponent.cmd \u0026#34;COMP=Generic-Ch-Not-Used\u0026#34; # Just ignore some slaves (increase SLAVE_ID with 4) ${SCRIPTEXEC} ${ecmccfg_DIR}ignoreSlaves.cmd \u0026#34;COUNT=4\u0026#34; # slave 16 {ecmcEL7037}, configure slave with optional SLAVE_ID. Please use applyComponent.cmd instead ${SCRIPTEXEC} ${ECMC_CONFIG_ROOT}addSlave.cmd, \u0026#34;HW_DESC=EL7037\u0026#34; ${SCRIPTEXEC} ${ecmccfg_DIR}applyComponent.cmd \u0026#34;COMP=Motor-Generic-2Phase-Stepper, CH_ID=1, MACROS=\u0026#39;I_MAX_MA=1000, I_STDBY_MA=100, U_NOM_MV=24000, R_COIL_MOHM=1230,L_COIL_UH=500\u0026#39;\u0026#34; # slave 17 {ecmcEL7037}, addSlave, with immediate call off applySlaveConfig. Please use applyComponent.cmd instead ${SCRIPTEXEC} ${ECMC_CONFIG_ROOT}addSlave.cmd, \u0026#34;HW_DESC=EL7037\u0026#34; ${SCRIPTEXEC} ${ECMC_CONFIG_ROOT}applySlaveConfig, \u0026#34;CONFIG=-Motor-Nanotec-ST4118L1804-B\u0026#34; # slave with local configuration, in this case provided by the module `ECMC_AGIR` epicsEnvSet(\u0026#34;CFG_ROOT\u0026#34;, \u0026#34;${ECMC_AGIR_DIR}/\u0026#34;) ${SCRIPTEXEC} ${ECMC_CONFIG_ROOT}addSlave.cmd, \u0026#34;HW_DESC=EP7211-0034_ALL\u0026#34; ${SCRIPTEXEC} ${ECMC_CONFIG_ROOT}applySlaveConfig.cmd, \u0026#34;LOCAL_CONFIG=${CFG_ROOT}AM8211_AGIR.cfg\u0026#34; additional configuration  manually set binaryOutput01 to 1\necmcConfigOrDie \u0026#34;Cfg.WriteEcEntryIDString(${ECMC_EC_SLAVE_NUM_DIG_OUT},binaryOutput01,1)\u0026#34; If a limit switch needs to be fed from a binary output then this can be configured in the yaml configuration for the axis by setting (cleaner solution):\naxis: feedSwitchesOutput: ec0.s1.binaryOutput04 adding a physical motor axis   yaml config  ${SCRIPTEXEC} ${ECMC_CONFIG_ROOT}loadYamlAxis.cmd, \u0026#34;FILE=./AM8111_CSV_minimum.yaml, ECMC_TMPDIR=/tmp/\u0026#34;  classic config, please use yaml config instead.  epicsEnvSet(\u0026#34;DEV\u0026#34;, \u0026#34;STEST-MYDEVICE\u0026#34;) ${SCRIPTEXEC} ${ECMC_CONFIG_ROOT}configureAxis.cmd, \u0026#34;CONFIG=./cfg/axis_1\u0026#34; adding a virtual motor axis, please use yaml config instead.  ${SCRIPTEXEC} ${ecmccfg_DIR}configureVirtualAxis.cmd, \u0026#34;CONFIG=./cfg/axis_11_virt\u0026#34; adding synchronization, can be simpler to add the code in a normal PLC, see.  ${SCRIPTEXEC} ${ecmccfg_DIR}applyAxisSynchronization.cmd, \u0026#34;CONFIG=./cfg/axis_1_sync\u0026#34; ${SCRIPTEXEC} ${ecmccfg_DIR}applyAxisSynchronization.cmd, \u0026#34;CONFIG=./cfg/axis_11_sync\u0026#34; loading a PLC from file   classic PLC-file  ${SCRIPTEXEC} ${ecmccfg_DIR}loadPLCFile.cmd, \u0026#34;PLC_ID=0, FILE=./plc/homeSlit.plc, SAMPLE_RATE_MS=100\u0026#34;  pure yaml based PLC, please use classic PLC-file load instead  ${SCRIPTEXEC} \u0026#34;${ECMC_CONFIG_ROOT}loadYamlPlc.cmd\u0026#34; \u0026#34;FILE=./plc1.yaml, ECMC_TMPDIR=/tmp/\u0026#34;  pure yaml based PLC, please use classic PLC-file load instead, with classic PLC-file, Note: file key in yaml config will overwrite anything in the code key!  ${SCRIPTEXEC} \u0026#34;${ECMC_CONFIG_ROOT}loadYamlPlc.cmd\u0026#34; \u0026#34;FILE=./plc1File.yaml, ECMC_TMPDIR=/tmp/\u0026#34; "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/scripts/addaxis/","title":"addAxis.cmd","tags":[],"description":"","content":"description Script for adding axis EPICS PVs.\ndetails Adds an motion axis.\nauthor Niko Kivel\n "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/scripts/adddatastorage/","title":"addDataStorage.cmd","tags":[],"description":"","content":"description Script for adding dataStorage.\ndetails Adds dataStorage buffer.\nauthor Anders Sandstroem\n paramters DS_SIZE Size of data buffer. DS_ID (optional), default 0, buffer ID DS_TYPE (optional), default 0, 0: Normal Buffer, 1: Ring Buffer, 2: FIFO Buffer SAMPLE_RATE_MS (optional), default 1 DS_DEBUG (optional), default 0, 0: No debug printouts, 1: Debug printouts DESC (optional) Description of PLC\n Example calls:\n call for 1000 elements at 10 Hz  ${SCRIPTEXEC} ${ecmccfg_DIR}addDataStorage.cmd \u0026#34;DS_ID=1, DS_SIZE=1000, SAMPLE_RATE_MS=100\u0026#34; "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/scripts/adddomain/","title":"addDomain.cmd","tags":[],"description":"","content":"description Script for adding an EtherCAT domain.\ndetails Adds an EtherCAt domain.\nauthor Anders Sandström\n paramters EXE_RATE (optional) Execution rate [cycles] defaults 0 (same EC_RATE) EXE_OFFSET (optional) Execution offset cycles [cycles] defaults 0 ALLOW_OFFLINE (optional) Allow domain to be offline defaults 0\n All EtherCAT entries generated after this command will be assigned\n"},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/scripts/addecdataitem/","title":"addEcDataItem.cmd","tags":[],"description":"","content":"description Script for adding a ethercat data item.\ndetails The ethercat data item allows for accessing alreday configured ethercat domain data in a flexible\nauthor Anders Sandström\n "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/scripts/addecsdort/","title":"addEcSdoRT.cmd","tags":[],"description":"","content":"description Script for adding asyn SDO object (access to SDO:s in realtime)\ndetails Add SDO for async access during realtime operation\nauthor Anders Sandström\n "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/scripts/addencoder/","title":"addEncoder.cmd","tags":[],"description":"","content":"description Script for adding an extra encoder to an axis.\ndetails Adds an encoder to the last configured axis.\nauthor Niko Kivel\n paramters CONFIG configuration file, i.e. ./cfg/axis_1_enc_2.enc DEV (optional) device name, i.e. MOTOR1 CLEAR_VARS_CMD (optional) Set to \u0026ldquo;empty\u0026rdquo; for not clear env vars (if vars needed for later use). CFG_MACROS (optional) Substitution macros for config file\n Example call:\n${SCRIPTEXEC} ${ecmccfg_DIR}addEncoder.cmd, \u0026#34;CONFIG=./cfg/linear_1_enc_3.enc\u0026#34; "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/scripts/addmaster/","title":"addMaster.cmd","tags":[],"description":"","content":"description Script for claiming a particular master.\ndetails Claims an EtherCAT master.\nauthor Niko Kivel\n paramters MASTER_ID (optional) master ID as shown by ethercat master.\n Example calls:\n call w/o MASTER_ID  ${SCRIPTEXEC} ${ecmccfg_DIR}addMaster.cmd  call w/ MASTER_ID, which claims the 4th master.  ${SCRIPTEXEC} ${ecmccfg_DIR}addMaster.cmd, \u0026#34;MASTER_ID=3\u0026#34; "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/scripts/addmasterslavesm/","title":"addMasterSlaveSM.cmd","tags":[],"description":"","content":"author Anders Sandström\n "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/scripts/addslave/","title":"addSlave.cmd","tags":[],"description":"","content":"description Script for adding a slave to the EtherCAT bus configuration.\ndetails Adds the respective hardware to the bus configuration, adds specific and default PV to the EPICS database. For some/most slaves also a default\nauthor Niko Kivel\n paramters HW_DESC Hardware descriptor, i.e. EL1008 SLAVE_ID (optional) bus position SUBST_FILE (optional) substitution file P_SCRIPT (optional) naming convention prefix script NELM (optional) Used for oversampling cards. Defaults to 1 DEFAULT_SUBS (optional) option to disable default PVs for mapped PDOs DEFAULT_SLAVE_PVS (optional, caution!) basic slave PVs, i.e. ${ECMC_P}-Operational will be suppressed CALLED_FROM_CFG_SLAVE (optional) Set if called by configureSlave.cmd, default 0 MACROS: MACROS for subst file\n Example calls:\n call w/o SLAVE_ID  ${SCRIPTEXEC} ${ecmccfg_DIR}addSlave.cmd, \u0026#34;HW_DESC=EL7037\u0026#34;  call w/ SLAVE_ID  ${SCRIPTEXEC} ${ecmccfg_DIR}addSlave.cmd, \u0026#34;HW_DESC=EL1018, SLAVE_ID=1\u0026#34;  call w/ SLAVE_ID and P_SCRIPT  ${SCRIPTEXEC} ${ecmccfg_DIR}addSlave.cmd, \u0026#34;HW_DESC=EL1018, SLAVE_ID=1, P_SCRIPT=mXsXXX\u0026#34;  call w/ default PDO PVs disabled  ${SCRIPTEXEC} ${ecmccfg_DIR}addSlave.cmd, \u0026#34;HW_DESC=EL3204, DEFAULT_SUBS=false, DEFAULT_SLAVE_PVS=true\u0026#34; "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/scripts/addslavekl/","title":"addSlaveKL.cmd","tags":[],"description":"","content":"description Script for adding a KL slave to the EtherCAT bus configuration of KL type.\ndetails Adds the respective hardware to the bus configuration, adds specific and default PV to the EPICS database. For some/most slaves also a default\nauthor Anders Sandstrom\n paramters HW_DESC Hardware descriptor, i.e. KL2032 SLAVE_ID EtherCAT bus position of the BK1250 (or similar terminal) SLAVE_ID_KL KL-Bus index in two digit hex starting at zero for the first slave after BK1250 (or similar terminal) SUBST_FILE (optional) substitution file\n Example calls:\n${SCRIPTEXEC} ${ecmccfg_DIR}addSlave.cmd, \u0026#34;HW_DESC=EL1018, SLAVE_ID=1, SLAVE_ID_KL=0A\u0026#34; "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/scripts/addvirtualaxis/","title":"addVirtualAxis.cmd","tags":[],"description":"","content":"description Script for adding axis EPICS PVs.\ndetails Adds an virtual axis with PVs.\nauthor Niko Kivel\n "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/scripts/applyaxissynchronization/","title":"applyAxisSynchronization.cmd","tags":[],"description":"","content":"description Script for applying axis synchronization\ndetails Adds synchronization parameters to an axis provided by CONFIG.\nauthor Niko Kivel\n paramters CONFIG configuration file, i.e. ./cfg/linear_1.sax CLEAR_VARS_CMD (optional) Set to \u0026ldquo;empty\u0026rdquo; for not clear env vars (if needed vars for later use).\n Example call:\n${SCRIPTEXEC} ${ecmccfg_DIR}applyAxisSynchronization.cmd, \u0026#34;CONFIG=./cfg/linear_1.sax\u0026#34; "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/scripts/applycomponent/","title":"applyComponent.cmd","tags":[],"description":"","content":"description Warpper for ecmccomp/applyComponent.cmd.\ndetails Checks if ecmccomp is loaded, if not loads, then calls ecmccomp/applyComponent.cmd.\nauthor Anders Sandström\n "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/scripts/applyconfig/","title":"applyConfig.cmd","tags":[],"description":"","content":"description Script for applying bus configuration.\ndetails Applies the EtherCAT configuration and caluclates data offsets in the process image.\nauthor Niko Kivel\n Example call:\n${SCRIPTEXEC} ${ecmccfg_DIR}applyConfig.cfg "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/scripts/applyslaveconfig/","title":"applySlaveConfig.cmd","tags":[],"description":"","content":"description Script for applying a specific slave configuration after the slave had been added manually.\ndetails Apply configurations to a slave.\nauthor Niko Kivel\n Example call: call applySlaveConfig with CONFIG\n${SCRIPTEXEC} ${ecmccfg_DIR}applySlaveConfig.cmd, \u0026#34;CONFIG=-Motor-Nanotec-ST4118L1804-B\u0026#34; call applySlaveConfig with LOCAL_CONFIG\n${SCRIPTEXEC} ${ecmccfg_DIR}applySlaveConfig.cmd, \u0026#34;LOCAL_CONFIG=./myFancyServoConfig.cfg\u0026#34; "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/scripts/applyslavedcconfig/","title":"applySlaveDCconfig.cmd","tags":[],"description":"","content":"description Script for applying dc config to slave\ndetails Apply dc configurations to a slave.\nauthor Anders Sandstroem\n "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/scripts/applysubstitutions/","title":"applySubstitutions.cmd","tags":[],"description":"","content":"description Script for applying substitution file\ndetails Applies substitution from ${SUBST_FILE} with ${P_SCRIPT}\nauthor Niko Kivel\n paramters SUBST_FILE (optional) substitution file ECMC_P PV prefix P_SCRIPT (optional) naming convention prefix script NELM (optional) Used for oversampling cards. Defaults to 1 MACROS: MACROS for subst file\n Example calls:\n call w/o SLAVE_ID  ${SCRIPTEXEC} \u0026#34;${ECMC_CONFIG_ROOT}applySubstitutions.cmd\u0026#34; \u0026#34;SUBST_FILE=${SUBST_FILE=ecmc${ECMC_EC_HWTYPE}.substitutions},ECMC_P=${ECMC_P}\u0026#34; "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/scripts/applytemplate/","title":"applyTemplate.cmd","tags":[],"description":"","content":"description Script for applying a template\ndetails Applies template from ${TEMPLATE_FILE} with ${P_SCRIPT}, PARAMS can be passed\nauthor Niko Kivel\n paramters TEMPLATE_FILE template file ECMC_P PV prefix PARAMS (optional) additional parameters\n Example calls:\n call w/o SLAVE_ID  ${SCRIPTEXEC} \u0026#34;${ECMC_CONFIG_ROOT}applyTemplate.cmd\u0026#34; \u0026#34;TEMPLATE_FILE=ecmcEcSlave.template,ECMC_P=${ECMC_P}\u0026#34; "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/general/chkoversampfactordie/","title":"chkOverSampFactOrDie.cmd","tags":[],"description":"","content":"description Validates requested oversampling factor\ndetails Checks if requested oversampling factor is valid otherwise exits EPICS/ECMC\nauthor Anders Sandstroem\n "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/general/chkoversamptimeordie/","title":"chkOverSampTimeOrDie.cmd","tags":[],"description":"","content":"description Validates the resulting sampling time for oversampling slaves.\ndetails Checks if the resulting sampling time for oversampling slaves is higher or equal to the minimum time.\nauthor Anders Sandstroem\n "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/general/chkvalidcurrentsetordie/","title":"chkValidCurrentSetOrDie.cmd","tags":[],"description":"","content":"description Validates current settings\ndetails Checks if requested run current and standby current is less than max current and larger than 0.\nauthor Anders Sandstroem\n "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/general/chkvalidvoltagesetordie/","title":"chkValidVoltageSetOrDie.cmd","tags":[],"description":"","content":"description Validates requested voltage\ndetails Ensure requested nominal voltage is less than max voltage and larger than 0\nauthor Anders Sandstroem\n "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/scripts/configureaxis/","title":"configureAxis.cmd","tags":[],"description":"","content":"description Script for adding an axis with configuration.\ndetails Adds an axis to the configuration and applies parameters provided by CONFIG.\nauthor Niko Kivel\n paramters CONFIG configuration file, i.e. ./cfg/linear_1.pax DEV (optional) device name, i.e. MOTOR1 CLEAR_VARS_CMD (optional) Set to \u0026ldquo;empty\u0026rdquo; for not clear env vars (if vars needed for later use). CFG_MACROS (optional) Substitution macros for config file\n Example call:\n${SCRIPTEXEC} ${ecmccfg_DIR}configureAxis.cmd, \u0026#34;CONFIG=./cfg/linear_1.pax\u0026#34; "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/scripts/configureslave/","title":"configureSlave.cmd","tags":[],"description":"","content":"description Script for adding a slave with dedicated slave configuration to the EtherCAT bus configuration.\ndetails Adds the respective hardware to the bus configuration, adds specific and default PV to the EPICS database. Applies a specific slave configuration.\nauthor Niko Kivel\n paramters HW_DESC Hardware descriptor, i.e. EL7037 CONFIG configuration file, i.e. -Motor-Nanotec-ST4118L1804-B\n The CONFIG together with the HW_DESC form the full filename which by definition is ecmc${HW_DESC}${CONFIG}.cmd, i.e.: ecmcEL7037-Motor-Nanotec-ST4118L1804-B.cmd\nparamters SLAVE_ID (optional) bus position CFG_MACROS (optional) Substitution macros for config file NELM (optional) Used for oversampling cards. Defaults to 1\n Example calls:\n call w/o SLAVE_ID  ${SCRIPTEXEC} ${ecmccfg_DIR}configureSlave.cmd, \u0026#34;HW_DESC=EL7037, CONFIG=-Motor-Nanotec-ST4118L1804-B\u0026#34;  call w/ SLAVE_ID  ${SCRIPTEXEC} ${ecmccfg_DIR}configureSlave.cmd, \u0026#34;HW_DESC=EL7037, CONFIG=-Motor-Nanotec-ST4118L1804-B, SLAVE_ID=8\u0026#34; "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/scripts/configurevirtualaxis/","title":"configureVirtualAxis.cmd","tags":[],"description":"","content":"description Script for adding a virtual axis with configuration.\ndetails Adds a virtual axis to the configuration and applies parameters provided by CONFIG.\nauthor Niko Kivel\n paramters CONFIG configuration file, i.e. ./cfg/linear_11.vax DEV (optional) device name, i.e. GAP CLEAR_VARS_CMD (optional) Set to \u0026ldquo;empty\u0026rdquo; for not clear env vars (if needed vars for later use).\n Example call:\n${SCRIPTEXEC} ${ecmccfg_DIR}configureVirtualAxis.cmd, \u0026#34;CONFIG=./cfg/linear_11.vax\u0026#34; "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/motion/ecmc_axis-records/","title":"ecmc_axis-records.cmd","tags":[],"description":"","content":"description Script for adding axis related EPICS PVs.\ndetails Adds motorRecord to the IOC.\nauthor Anders Sandstroem\n This script is typically called by \\b addAxis.cmd\n"},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/motion/ecmc_axis/","title":"ecmc_axis.cmd","tags":[],"description":"","content":"description Script for configuring a physical axis.\ndetails Configures a physical axis in ECMC, based on previously set environment variables.\nauthor Anders Sandstroem\n This script is typically called by \\b addAxis.cmd, often via \\b ecmc_axis-records.cmd\n"},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/motion/ecmc_axis_diag/","title":"ecmc_axis_diag.cmd","tags":[],"description":"","content":"description Script for adding axis diagnostic EPICS PVs.\ndetails Adds diagnostic PVs to the IOC.\nauthor Anders Sandstroem\n "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/motion/ecmc_axis_mr/","title":"ecmc_axis_mr.cmd","tags":[],"description":"","content":"description Script for loading motor record related databases\ndetails Script for loading motor record related databases and creating motor record axis object\nauthor Anders Sandstroem\n This script is typically called by \\b ecmc_axis.cmd, often via \\b ecmc_axis-records.cmd\n"},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/motion/ecmc_axis_sync/","title":"ecmc_axis_sync.cmd","tags":[],"description":"","content":"description Script for configuring axis synchronization\ndetails Configures ECMC for axis synchronization, based on previously set environment variables.\nauthor Anders Sandstroem\n This script is typically called by \\b applyAxisSynchronization.cmd\n"},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/motion/ecmc_enc-records/","title":"ecmc_enc-records.cmd","tags":[],"description":"","content":"description Script for adding encoder related EPICS PVs.\ndetails Script for adding an encoder to a previously created axis.\nauthor Anders Sandstroem\n This script is typically called by \\b addAxis.cmd\n"},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/motion/ecmc_enc/","title":"ecmc_enc.cmd","tags":[],"description":"","content":"description Script for adding an extra encoder\ndetails Configures a encoder object in ECMC, based on previously set environment variables.\nauthor Anders Sandstroem\n This script is typically called by \\b addEncoder.cmd\n"},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/motion/ecmc_virt_axis-records/","title":"ecmc_virt_axis-records.cmd","tags":[],"description":"","content":"description Script for adding axis related EPICS PVs.\ndetails Adds motorRecord to the IOC.\nauthor Anders Sandstroem\n This script is typically called by \\b addVirtualAxis.cmd\n"},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/motion/ecmc_virt_axis/","title":"ecmc_virt_axis.cmd","tags":[],"description":"","content":"description Script for configuring a virtual axis.\ndetails Configures a virtual axis in ECMC, based on previously set environment variables.\nauthor Anders Sandstroem\n This script is typically called by \\b addVirtualAxis.cmd, often via \\b ecmc_virt_axis-records.cmd\n"},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/","title":"ecmccfg","tags":[],"description":"","content":"ecmccfg A configuration framework for ECMC Motion Control Module for EPICS.\nLicense  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 3 of the License, or (at your option) any later version.\nThis program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.\nYou should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\nLatest release \nDownload \n"},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/naming/ecmcclassicnaming/","title":"ecmcClassicNaming.cmd","tags":[],"description":"","content":"description Script for defining ${ECMC_PREFIX}\ndetails Gathers relevant information about MasterID, SlaveID, \u0026hellip; to create naming convention compliant PREFIX\nauthor Niko Kivel\n "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/naming/ecmcessnaming/","title":"ecmcESSnaming.cmd","tags":[],"description":"","content":"description Script for defining ${ECMC_P}\ndetails Gathers relevant information about MasterID, SlaveID, \u0026hellip; to create naming convention compliant PREFIX\nauthor Niko Kivel\n "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/naming/ecmcmxsxxx/","title":"ecmcmXsXXX.cmd","tags":[],"description":"","content":"description Script for defining ${ECMC_P}\ndetails Gathers relevant information about MasterID, SlaveID, \u0026hellip; to create naming convention compliant PREFIX\nauthor Niko Kivel\n "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/scripts/finalize/","title":"finalize.cmd","tags":[],"description":"","content":"description Script for finalizing. Executed just before iocInit (atInit)\ndetails Script for finalizing. Executed just before iocInit (atInit).\nauthor Anders Sandström\n "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/general/","title":"general","tags":[],"description":"","content":"  chkOverSampFactOrDie.cmd   chkOverSampTimeOrDie.cmd   chkValidCurrentSetOrDie.cmd   chkValidVoltageSetOrDie.cmd   general.cmd   generalDiagnostics.cmd   init.cmd   initAll.cmd   initAxis.cmd   issueWarning.cmd   verifyOrDie.cmd   "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/general/general/","title":"general.cmd","tags":[],"description":"","content":"description Add general PVs\ndetails Script for adding general and master diagnostics EPICS PVs\nauthor Niko Kivel, Anders Sandstroem\n "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/general/generaldiagnostics/","title":"generalDiagnostics.cmd","tags":[],"description":"","content":"description Script for general diagnostics\ndetails Script for setting default diagnostics\nauthor Niko Kivel, Anders Sandstroem\n "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/scripts/ignoreslaves/","title":"ignoreSlaves.cmd","tags":[],"description":"","content":"description Ignores a slave\ndetails Ignores a slave by increase SLAVE_ID with 1\nauthor Anders Sandström\n "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/general/init/","title":"init.cmd","tags":[],"description":"","content":"description Initialization script\ndetails Script for setting up the basic EPICS environment.\nauthor Niko Kivel, Anders Sandstroem\n "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/general/initall/","title":"initAll.cmd","tags":[],"description":"","content":"description Init main script\ndetails Script for setting up the basic EPICS environment.\nauthor Niko Kivel, Anders Sandstroem\n "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/general/initaxis/","title":"initAxis.cmd","tags":[],"description":"","content":"description init axis environment\ndetails Script for setting up the basic AXIS environment.\nauthor Niko Kivel, Anders Sandstroem\n "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/general/issuewarning/","title":"issueWarning.cmd","tags":[],"description":"","content":"description Issue a warning\ndetails Generic verification script for expressions\nauthor Anders Sandstroem\n "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/scripts/jinja2/","title":"jinja2","tags":[],"description":"","content":"  loadYamlAxis.cmd   loadYamlEnc.cmd   loadYamlPlc.cmd   "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/scripts/loadaxisplcfile/","title":"loadAxisPLCFile.cmd","tags":[],"description":"","content":"description Script for adding a PLC from file.\ndetails Adds a PLC defined in FILE. Also adds PLC specific EPICS PVs, i.e. for enable/disable.\nauthor Niko Kivel\n paramters FILE PLC definition file, i.e. ./plc/homeSlit.plc AX_ID (optional) Ax number, default 0 PLC_MACROS (optional) Substitution macros for PLC code TMP_PATH (optional) directory to dump the temporary plc file after macro substitution PRINT_PLC_FILE (optional) 1/0, printout msi parsed plc file (default enable(1)). SUBST_FILE (optional) custom substitution file otherwise ecmccfg default will be loaded\n Example call:\n${SCRIPTEXEC} ${ecmccfg_DIR}loadAxisPLCFile.cmd, \u0026#34;AX_ID=1, FILE=./plc/homeSlit.plc\u0026#34; "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/scripts/loadlutfile/","title":"loadLUTFile.cmd","tags":[],"description":"","content":"author Anders Sandström\n "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/scripts/loadplcfile/","title":"loadPLCFile.cmd","tags":[],"description":"","content":"description Script for adding a PLC from file.\ndetails Adds a PLC defined in FILE. Also adds PLC specific EPICS PVs, i.e. for enable/disable.\nauthor Niko Kivel, Anders Sandström\n paramters FILE PLC definition file, i.e. ./plc/homeSlit.plc PLC_ID (optional) PLC number, default 0, or to next free PLC, the actual PLC Id is stored in ECMC_PLC_ID and can be used after this command SAMPLE_RATE_MS (optional) excecution rate, default 1000/EC_RATE PLC_MACROS (optional) Substitution macros for PLC code. The macros \u0026ldquo;SELF_ID\u0026rdquo;,\u0026ldquo;SELF\u0026rdquo;,M_ID, and M are reserved: TMP_PATH (optional) directory to dump the temporary plc file after macro substitution PRINT_PLC_FILE (optional) 1/0, printout msi parsed plc file (default enable(1)). SUBST_FILE (optional) custom substitution file otherwise ecmccfg default will be loaded INC (optional) List of directories for include files to pass to MSI (if several paths thendivide with \u0026lsquo;:'). DESC (optional) Description of PLC\n Example call:\n${SCRIPTEXEC} ${ecmccfg_DIR}loadPLCFile.cmd, \u0026#34;PLC_ID=0, FILE=./plc/homeSlit.plc, SAMPLE_RATE_MS=100\u0026#34; "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/scripts/loadplclib/","title":"loadPLCLib.cmd","tags":[],"description":"","content":"description Script for loading a PLC from lib from file.\ndetails Adds a PLC defined in FILE. Also adds PLC specific EPICS PVs, i.e. for enable/disable.\nauthor Anders Sandström\n paramters FILE PLC definition file, i.e. ./plc/homeSlit.plc PLC_ID (optional) PLC number, default last loaded PLC PLC_MACROS (optional) Substitution macros for PLC code. The macros \u0026ldquo;SELF_ID\u0026rdquo;,\u0026ldquo;SELF\u0026rdquo;,M_ID, and M are reserved: INC (optional) List of directories for include files to pass to MSI (if several paths thendivide with \u0026lsquo;:'). TMP_PATH (optional) directory to dump the temporary plc file after macro substitution PRINT_PLC_FILE (optional) 1/0, printout msi parsed plc file (default enable(1)).\n Example call:\n${SCRIPTEXEC} ${ecmccfg_DIR}loadPLCLib.cmd, \u0026#34;PLC_ID=0, FILE=./plc/homeSlit.plc, SAMPLE_RATE_MS=100\u0026#34; "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/scripts/loadplugin/","title":"loadPlugin.cmd","tags":[],"description":"","content":"description Script for loading a ecmc plugin from file.\ndetails Loads a ecmc-plugin from file.\nauthor Anders Sandström\n paramters FILE Filename of plugin shared lib (./ecmcPlugin_Advanced.so) PLUGIN_ID Id of plugin to load CONFIG (optional) Configuration string sent to plugin at construct REPORT (optional) Printout information of loaded plugin if set to \u0026ldquo;1\u0026rdquo;\n Example call:\n${SCRIPTEXEC} ${ecmccfg_DIR}loadPlugin.cmd, \u0026#34;PLUGIN_ID=0,FILE=./ecmcPlugin_Advanced.so,CONFIG=\u0026#39;PLUGIN CONFIGS GO HERE \u0026#39; "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/scripts/loadsubstaxes/","title":"loadSubstAxes.cmd","tags":[],"description":"","content":"description Script for adding multiple axes based on subst and template file\ndetails Configure multiple axes by using subst file\nauthor Anders Sandström\n ${SCRIPTEXEC} ${ecmccfg_DIR}loadSubstAxes.cmd, \u0026#34;FILE=./ax.subs\u0026#34; "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/scripts/loadsubstconfig/","title":"loadSubstConfig.cmd","tags":[],"description":"","content":"description Script for loading complete ecmc cfg based on subst files and templates\ndetails Loads complete ecmc cfg based on subst files and templates\nauthor Anders Sandström\n ${SCRIPTEXEC} ${ecmccfg_DIR}loadSubstConfig.cmd, \u0026#34;FILE=./cfg.subs\u0026#34; "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/scripts/loadsubsthw/","title":"loadSubstHw.cmd","tags":[],"description":"","content":"description Script for adding multiple hw based on subst and template file\ndetails Loads hw cfg based on subst files and templates\nauthor Anders Sandström\n ${SCRIPTEXEC} ${ecmccfg_DIR}loadSubstHw.cmd, \u0026#34;FILE=./hw.subs\u0026#34; "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/scripts/jinja2/loadyamlaxis/","title":"loadYamlAxis.cmd","tags":[],"description":"","content":"description Script for loading Axis from yaml file via jinja2\ndetails adds an Axis, based on a yaml config file\nauthor Niko Kivel, Anders Sandström\n paramters FILE the yaml-file containing the PLC definition DEV the device name (optional, defaults to ${IOC}), automatically appended with a : PREFIX the device PREFIX, will NOT be appended with a :\n Example calls:\n call  ${SCRIPTEXEC} \u0026#34;./loadYamlAxis.cmd\u0026#34; \u0026#34;FILE=./axis1.yaml\u0026#34; ${SCRIPTEXEC} \u0026#34;./loadYamlAxis.cmd\u0026#34; \u0026#34;FILE=./axis1.yaml, DEV=foobar\u0026#34; ${SCRIPTEXEC} \u0026#34;./loadYamlAxis.cmd\u0026#34; \u0026#34;FILE=./axis1.yaml, PREFIX=MTEST-STEPPER:X:\u0026#34; "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/scripts/jinja2/loadyamlenc/","title":"loadYamlEnc.cmd","tags":[],"description":"","content":"description Script for adding Encoder from yaml file via jinja2\ndetails adds an encoder to an axis, based on a yaml config file\nauthor Anders Sandström\n paramters FILE the yaml-file containing the PLC definition DEV the device name (optional, defaults to ${IOC}\n Example calls:\n call  ${SCRIPTEXEC} \u0026#34;./loadYamlEnc.cmd\u0026#34; \u0026#34;FILE=./enc.yaml\u0026#34; ${SCRIPTEXEC} \u0026#34;./loadYamlEnc.cmd\u0026#34; \u0026#34;FILE=./enc.yaml, DEV=foobar\u0026#34; "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/scripts/jinja2/loadyamlplc/","title":"loadYamlPlc.cmd","tags":[],"description":"","content":"description Script for loading PLC from yaml file via jinja2\ndetails adds a PLC, line by line, from a yaml-file, parsed by jinja2\nauthor Niko Kivel, Anders Sandström\n paramters FILE the yaml-file containing the PLC definition\n Example calls:\n call  ${SCRIPTEXEC} \u0026#34;./loadYamlPlc.cmd\u0026#34; \u0026#34;FILE=./plc1.yaml\u0026#34; "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/motion/","title":"motion","tags":[],"description":"","content":"  ecmc_axis-records.cmd   ecmc_axis.cmd   ecmc_axis_diag.cmd   ecmc_axis_mr.cmd   ecmc_axis_sync.cmd   ecmc_enc-records.cmd   ecmc_enc.cmd   ecmc_virt_axis-records.cmd   ecmc_virt_axis.cmd               "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/naming/","title":"naming","tags":[],"description":"","content":"  ecmcClassicNaming.cmd   ecmcESSnaming.cmd   ecmcmXsXXX.cmd   "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/scripts/pvtcontrollerconfig/","title":"pvtControllerConfig.cmd","tags":[],"description":"","content":"author Anders Sandström\n "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/scripts/restorerecordupdaterate/","title":"restoreRecordUpdateRate.cmd","tags":[],"description":"","content":"description Restores record update rate to what was defined in startup.cmd\ndetails Restores record update rate to what was defined in startup.cmd\nauthor Anders Sandström\n "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/scripts/","title":"scripts","tags":[],"description":"","content":"  addAxis.cmd   addDataStorage.cmd   addDomain.cmd   addEcDataItem.cmd   addEcSdoRT.cmd   addEncoder.cmd   addMaster.cmd   addMasterSlaveSM.cmd   addSlave.cmd   addSlaveKL.cmd   addVirtualAxis.cmd   applyAxisSynchronization.cmd   applyComponent.cmd   applyConfig.cmd   applySlaveConfig.cmd   applySlaveDCconfig.cmd   applySubstitutions.cmd   applyTemplate.cmd   configureAxis.cmd   configureSlave.cmd   configureVirtualAxis.cmd   finalize.cmd   ignoreSlaves.cmd   jinja2   loadAxisPLCFile.cmd   loadLUTFile.cmd   loadPLCFile.cmd   loadPLCLib.cmd   loadPlugin.cmd   loadSubstAxes.cmd   loadSubstConfig.cmd   loadSubstHw.cmd   pvtControllerConfig.cmd   restoreRecordUpdateRate.cmd   setAppMode.cmd   setDiagnostics.cmd   setRecordUpdateRate.cmd   slaveVerify.cmd         "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/scripts/setappmode/","title":"setAppMode.cmd","tags":[],"description":"","content":"description Script for switching to operational mode.\ndetails Validates configuration, starts realtime thread and checks EtherCAT slaves are in OP.\nauthor Niko Kivel\n "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/scripts/setdiagnostics/","title":"setDiagnostics.cmd","tags":[],"description":"","content":"description Script for enabling default diagnostics.\ndetails Set some default values to diagostics\nauthor Niko Kivel\n "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/scripts/setrecordupdaterate/","title":"setRecordUpdateRate.cmd","tags":[],"description":"","content":"description Script for changing record update rate\ndetails Update record processing rate, all records created after this command will be updated in the specified rate.\nauthor Anders Sandström\n "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/scripts/slaveverify/","title":"slaveVerify.cmd","tags":[],"description":"","content":"description ** script for slave verification and optional reset**\ndetails will verify the slave identity and reset by writing to 0x1011, optionally read firmwre version from 0x100a\nauthor Niko Kivel\n Macros\n"},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/","title":"source","tags":[],"description":"","content":"  general   motion   naming   scripts   utils      "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/utils/","title":"utils","tags":[],"description":"","content":"     "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/general/verifyordie/","title":"verifyOrDie.cmd","tags":[],"description":"","content":"description Generic verification script\ndetails Generic verification script for expressions\nauthor Anders Sandstroem\n "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/manual/introduction/","title":"introduction","tags":[],"description":"","content":"Principle EtherCAT requires the field bus components (slaves) to be configured on the master. The master must know about the data exchanges with the slaves, this is referred to as process image.\nDuring IOC-startup, the requested configuration is validated against the actually present hardware on the bus. Mismatches will result in an error, the IOC will not start.\nBlindly restarting the IOC, with only partially working EtherCAT hardware, will results in an inoperable IOC! If troubleshooting is needed then check out the knowledge base for details.\n IOC structure The startup script has several steps:\n require ecmccfg configure the slaves on the EtherCAT bus  additional configuration adding a physical motor axis adding a virtual motor axis adding synchronization loading a PLC from file    require ecmccfg require ecmccfg \u0026lt;VERSION\u0026gt; slave configuration Each slave on the field bus must be configured for use with ECMC. For this purpose scripts can be called for:\n adding slaves with default configuration adding and configure while adding applying a configuration to the previously added slaves  In addition to these ecmccfg scripts also the ecmccomp repo that contains a component library can be used. Settings are then applied with the ecmccomp/applyComponent.cmd, see below examples.\nexamples The addSlave is used for simple slaves, a default configuration is automatically applied. In addition default PVs will created for the basic slave features, i.e. status. Most slaves also have PVs created matching the purpose, i.e. inputs will have bi records, outputs will have bo records for each channel. This behaviour can be modified by arguments.\n  add a coupler and slaves\n# slave 0 {EK1100} ${SCRIPTEXEC} ${ecmccfg_DIR}addSlave.cmd, \u0026#34;HW_DESC=EK1100\u0026#34; # SLAVE_ID is automatically incremented # slave 1 {EL1018} ${SCRIPTEXEC} ${ecmccfg_DIR}addSlave.cmd, \u0026#34;HW_DESC=EL1018\u0026#34; # skip slaves 2..6 # slave 7 {EL2008}, with optional SLAVE_ID ${SCRIPTEXEC} ${ecmccfg_DIR}addSlave.cmd, \u0026#34;HW_DESC=EL2008, SLAVE_ID=7\u0026#34; # slave 9 {EL2008}, with optional SLAVE_ID and P_SCRIPT ${SCRIPTEXEC} ${ecmccfg_DIR}addSlave.cmd, \u0026#34;HW_DESC=EL2008, SLAVE_ID=7, P_SCRIPT=mXsXXX\u0026#34; # slave 10 {EL3204}, without any of the default PVs ${SCRIPTEXEC} ${ecmccfg_DIR}addSlave.cmd, \u0026#34;HW_DESC=EL3204, DEFAULT_SUBS=false, DEFAULT_SLAVE_PVS=true\u0026#34;   add more slaves and apply configuration to the slaves\n# slave 8 {EL7037}, configure slave using applyComponent.cmd from ecmccomp module with optional SLAVE_ID. ${SCRIPTEXEC} ${ecmccfg_DIR}addSlave.cmd, \u0026#34;HW_DESC=EL7037, SLAVE_ID=8\u0026#34; ${SCRIPTEXEC} ${ecmccfg_DIR}applyComponent.cmd \u0026#34;COMP=Motor-Generic-2Phase-Stepper, MACROS=\u0026#39;I_MAX_MA=1000, I_STDBY_MA=500, U_NOM_MV=48000, R_COIL_MOHM=1230\u0026#39;\u0026#34; # slave 9 {EL7037}, addSlave, with immediate call off applySlaveConfig # slave with global configuration ${SCRIPTEXEC} ${ecmccfg_DIR}addSlave.cmd, \u0026#34;HW_DESC=EL7037\u0026#34; ${SCRIPTEXEC} ${ecmccfg_DIR}applySlaveConfig.cmd, \u0026#34;CONFIG=-Motor-Nanotec-ST4118L1804-B\u0026#34; # slave with local configuration, in this case provided by the module `ECMC_AGIR` epicsEnvSet(\u0026#34;CFG_ROOT\u0026#34;, \u0026#34;${ECMC_AGIR_DIR}/\u0026#34;) ${SCRIPTEXEC} ${ecmccfg_DIR}addSlave.cmd, \u0026#34;HW_DESC=EP7211-0034_ALL\u0026#34; ${SCRIPTEXEC} ${ecmccfg_DIR}applySlaveConfig.cmd, \u0026#34;LOCAL_CONFIG=${CFG_ROOT}AM8211_AGIR.cfg\u0026#34;   additional configuration Optionally, manual modifications can be made to the default configuration.\nIn order to manually set binaryOutput01 to 1 at startup, the following can be added to the startup script.\necmcConfigOrDie \u0026#34;Cfg.WriteEcEntryIDString(${ECMC_EC_SLAVE_NUM_DIG_OUT},binaryOutput01,1)\u0026#34; ecmcConfigOrDie \u0026#34;Cfg.WriteEcEntryEcPath(ec0.s${ECMC_EC_SLAVE_NUM_DIG_OUT}.binaryOutput12,1)\u0026#34; adding a physical motor axis Axis configuration will is explained in details here. The preferred way to confuser axes is with the yaml based configuration. It unifies the way, (1) physical axes, (2) virtual axes and (3) synchronization is handled. It is theoretically possible to use a mix of yaml and classic configuration, but this is untested.\n yaml config  ${SCRIPTEXEC} ${ecmccfg_DIR}loadYamlAxis.cmd, \u0026#34;FILE=./cfg/ax1.yaml, DEV=${DEV}, DRV_SLAVE=4, ENC_SLAVE=3, ENC_CHANNEL=01\u0026#34;  classic config  epicsEnvSet(\u0026#34;DEV\u0026#34;, \u0026#34;STEST-MYDEVICE\u0026#34;) ${SCRIPTEXEC} ${ecmccfg_DIR}configureAxis.cmd, \u0026#34;CONFIG=./cfg/axis_1\u0026#34;  See best practice and yaml cfg and for more information.\n adding a virtual motor axis ${SCRIPTEXEC} ${ecmccfg_DIR}configureVirtualAxis.cmd, \u0026#34;CONFIG=./cfg/axis_11_virt\u0026#34;  See best practice and yaml cfg and for more information.\n adding synchronization ${SCRIPTEXEC} ${ecmccfg_DIR}applyAxisSynchronization.cmd, \u0026#34;CONFIG=./cfg/axis_1_sync\u0026#34; ${SCRIPTEXEC} ${ecmccfg_DIR}applyAxisSynchronization.cmd, \u0026#34;CONFIG=./cfg/axis_11_sync\u0026#34;  See best practice and yaml cfg and for more information.\n loading a PLC from file The PLC functionality is explained in detail here. ECMC PLCs can be loaded from classical PLC files, from pure yaml files or from a yaml/PLC hybrid.\n classic PLC-file  ${SCRIPTEXEC} ${ecmccfg_DIR}loadPLCFile.cmd, \u0026#34;PLC_ID=0, FILE=./plc/homeSlit.plc, SAMPLE_RATE_MS=100\u0026#34;  pure yaml based PLC  ${SCRIPTEXEC} ${ecmccfg_DIR}loadYamlPlc.cmd \u0026#34;FILE=./plc1.yaml\u0026#34;  yaml definition, with classic PLC-file, Note: file key in yaml config will overwrite anything in the code key!  ${SCRIPTEXEC} ${ecmccfg_DIR}loadYamlPlc.cmd \u0026#34;FILE=./plc1File.yaml\u0026#34;  See plc cfg for more information.\n "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/manual/best_practice/","title":"best practice","tags":[],"description":"","content":"links to best practice:  General Motion PLC  "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/manual/general_cfg/","title":"general","tags":[],"description":"","content":" Topics  startup.cmd   data storage buffer   iocsh utilities   ecmc command reference   best practice   PV Processing Rate   "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/manual/ecmc_versions/","title":"ecmc versions","tags":[],"description":"","content":"Features New features are described in the RELEASE.md file of ecmc: https://github.com/epics-modules/ecmc/blob/master/RELEASE.md\nv11 Some new features that might be useful in ecmc v11:\n Position Velocity Timne motion (profile move) CSP-PC mode (CSP Position Control). Enable ecmc centralized position loop also in CSP mode. Typical use cases:  A drive (El7062 or Ex72xx) in CSP that also needs to close the loop on a linear encoder. Motion based on analog I/O, analog output corresponds to a position. In order to close the loop in ecmc layer \u0026ldquo;CSP-PC\u0026rdquo; must be used.   PID parameters can be set from motor record fields but should be a factor 100 smaller (this because the fields are limited to teh range 0..1.0).  Please be careful when using the motor record PID parameter fields. The settings via motor record should be a factor 100 smaller than the ecmc setting. Also note that these MR-fields are not synced with the ecmc fields if they are changed. Example: ecmc kp = 1, same setting through MR.PCOF = 0.01.\n Breaking changes Following functionalities have been removed in ecmc 11:\n getAxisStatusStructV2 (plugins need to be rebuilt) Event* (replace by ecmc plc code) CommandList* (replace by ecmc plc code) DataRecorder* (replace by ecmc plc code) Update of ecmc axis command word mbbo record ${P}${AXIS_NAME}-MtnCmd. As long as strings are used when writing to the the PV then it\u0026rsquo;s backward compatible, however, if interfacing through the indexes/values then these needs to be updated:  Old version:\nrecord(mbbo, \u0026quot;${P}${AXIS_NAME}-MtnCmd\u0026quot;){ field(DESC, \u0026quot;${AXIS_NAME}: Motion Command\u0026quot;) field(DTYP, \u0026quot;asynInt32\u0026quot;) field(OUT, \u0026quot;@asyn($(PORT),$(ADDR),$(TIMEOUT))T_SMP_MS=$(T_SMP_MS=1000)/TYPE=asynInt32/ax$(AXIS_NO).command?\u0026quot;) field(ZRST, \u0026quot;NO_COMMAND\u0026quot;) field(ZRVL, 0) field(ONST, \u0026quot;VEL\u0026quot;) field(ONVL, 1) field(TWST, \u0026quot;REL\u0026quot;) field(TWVL, 2) field(THST, \u0026quot;ABS\u0026quot;) field(THVL, 3) field(FVST, \u0026quot;PVT_REL\u0026quot;) field(FVVL, 8) field(SXST, \u0026quot;PVT_ABS\u0026quot;) field(SXVL, 9) field(SVST, \u0026quot;HOME\u0026quot;) field(SVVL, 10) field(VAL, 0) } New version:\nrecord(mbbo, \u0026quot;${P}${AXIS_NAME}-MtnCmd\u0026quot;){ info(asyn:READBACK,\u0026quot;1\u0026quot;) field(DESC, \u0026quot;${AXIS_NAME}: Motion Command\u0026quot;) field(DTYP, \u0026quot;asynInt32\u0026quot;) field(OUT, \u0026quot;@asyn($(PORT),$(ADDR),$(TIMEOUT))T_SMP_MS=$(T_SMP_MS=1000)/TYPE=asynInt32/ax$(AXIS_NO).command?\u0026quot;) field(ZRST, \u0026quot;NO_COMMAND\u0026quot;) field(ZRVL, -1) field(ONST, \u0026quot;VEL\u0026quot;) field(ONVL, 1) field(TWST, \u0026quot;REL\u0026quot;) field(TWVL, 2) field(THST, \u0026quot;ABS\u0026quot;) field(THVL, 3) field(NIST, \u0026quot;PVT_INTERN\u0026quot;) field(NIVL, 9) field(TEST, \u0026quot;HOME\u0026quot;) field(TEVL, 10) field(VAL, 0) } Migration guide v10 to v11 In general v11 is backward compatible with v10 but in order to benefit from new functionalities some updates are recommended:\n Auto enable: Move auto enable from motor record to ecmc Master/Slave sync. state machine: Use ecmc native state machine for sync. of virtual and physical axes instead of state machine implemented in plc code. Logic on limits: Use plcOverride keyword to allow logic for setting limit switches. Minimize risk of burning motors by SDO verification for drive slaves.  Auto-enable Auto-enable, previously handled by the motor record model 3 driver has now been implemented also in ecmc layer. It\u0026rsquo;s highly recommended to switch to use the auto-enable features in ecmc since the motor record implementation is blocking and therefore other axes cannot take commands while auto enable is executing.\nFirst remove any custom motor record auto enable cfgs:\nRemove: #parameters: 'powerAutoOnOff=2;powerOffDelay=-1;' In ecmc auto-enable feature is configured with 3 settings:\naxis: autoEnable: enableTimeout: 1.0 # Timeout for going to enabled state disableTimeout: 5.0 # Axis disable after this time when non busy. atStartup: False # Auto enable axis at ioc start Master/Slave sync. state machine For master slave axes systems where the virtual-physical axes state machine is loaded from plc-code should be updated to use the native ecmc state machine instead. This gives a higher level of diagnostics and also adds a few new features like improved error handling and controlling standby current on slaved axes.\nThe following configurations needs to be updated:\n Remove including/loading of axis_sm.plc_inc code in plc files Add an ecmc state machine for each master slave system by the ecmccfg-cmd \u0026ldquo;addMasterSlaveSM.cmd\u0026rdquo;:  #- Add state machine to sync the virtual and physical axes (the groups are defined in the yaml axis-cfg files) ${SCRIPTEXEC} ${ecmccfg_DIR}addMasterSlaveSM.cmd \u0026quot;NAME=Slit_SM, MST_GRP_NAME=virtualAxes, SLV_GRP_NAME=realAxes\u0026quot; MACROS used in \u0026ldquo;addMasterSlaveSM.cmd\u0026rdquo;:\n NAME: needs to be unique for each master slave system MST_GRP_NAME: The group name for the virtual axes (defined in axis yaml definitions) SLV_GRP_NAME: The group name for the physical axes (defined in axis yaml definitions)  Note: if several master slave systems are configured then the NAME, MST_GRP_NAME and SLV_GRP_NAME needs to be unique for that system.\nExample 2 slit systems with unique names:\n#- State machine for slit system in Y direction (slitVirtY and slitRealY defined in axes yaml configurations for the axes) ${SCRIPTEXEC} ${ecmccfg_DIR}addMasterSlaveSM.cmd \u0026quot;NAME=SlitY, MST_GRP_NAME=slitVirtY, SLV_GRP_NAME=slitRealY\u0026quot; #- State machine for slit system in X direction (slitVirtX and slitRealX defined in axes yaml configurations for the axes) ${SCRIPTEXEC} ${ecmccfg_DIR}addMasterSlaveSM.cmd \u0026quot;NAME=SlitX, MST_GRP_NAME=slitVirtX, SLV_GRP_NAME=slitRealX\u0026quot; Logic on limits (plcOverride) Functionality to write to limit switches has been added. Combining several limits switches into one signal can be achieved by using the \u0026lsquo;plcOverride\u0026rsquo; keyword in the definition of limit switches. Limits can then be calculated based on custom logic in ecmc PLC code. Note: Motion are allowed when the value of the limit switches are \u0026lsquo;1\u0026rsquo; (0 means limit is engaged). Example:\n... input: limit: forward: 'plcOverride' # Overridden, see plc code below backward: 'plcOverride' # Overridden, see plc code below ... plc: enable: true # Enable axis plc externalCommands: true # Allow axis to inputs from PLC code: # Sync code (appended after code in plc.file) - ax${AX_ID=1}.mon.lowlim:=ec_chk_bit(ec0.s$(DRV_SID).binaryInputs01,0) and ec_chk_bit(ec0.s$(DRV_SID).ONE,0); - ax${AX_ID=1}.mon.highlim:=ec_chk_bit(ec0.s$(DRV_SID).binaryInputs01,1) and ec_chk_bit(ec0.s$(DRV_SID).ONE,1); .. SDO verification for drive slaves A misspelled macro could in worse case lead to that a current setting for a drive is not downloaded correctly. In order to minimize this risk a SDO verification step has been added in v11 of ecmc/cfg/comp. Workflow:\n  the hw-snippet called by \u0026ldquo;addSlave.cmd\u0026rdquo; for drive terminals, i.e EX7XXX, executes an ecmc-command that tells ecmc that a SDO configuration is needed for a certain channel.\n  \u0026ldquo;applyComponent.cmd\u0026rdquo; with a motor configuration: Executes an ecmc-command that tells ecmc that SDO configuration has been performed for a certain channel. If \u0026ldquo;applySlaveConfig.cmd, or configureSlave.cmd\u0026rdquo; is used, then independent on which configuration is downloaded to the slave, the command telling ecmc that SDO configuration for channel 1 and 2 is executed. This is of course not optimal but safer than without check. Please try to move to applyComponent.cmd for higher security. If the drive has more than 2 channels, like EL7062, and one channel is unused then also this channel needs a configuration. \u0026ldquo;applyComponent.cmd \u0026ldquo;COMP=Generic-Ch-Not-Used, CH_ID=2'\u0026rdquo;\n  If the SDO cfgs have not been downloaded for a channel, the IOC will stop at validation just before iocInit.\n  If all the needed channels have been configured with SDOs then the IOC will start.\n  Note: If manual configuration is made, not using applyComponent.cmd, configureSlave.cmd, or applySlaveConfig.cmd, then the SDO verification functionality can be overridden by:\n#- Use of apply component: ${SCRIPTEXEC} ${ecmccfg_DIR}applyComponent.cmd \u0026quot;COMP=Generic-Ch-Not-Used, CH_ID=2'\u0026quot; #- Ecmc native command ecmcConfig \u0026quot;Cfg.EcSetSlaveSDOSettingsDone(\u0026lt;SlaveID\u0026gt;,\u0026lt;ChID\u0026gt;,1)\u0026quot; Currently, this is implemented for stepper and servo drives. Analog or step direction control is not affected by SDO verification, if not manually added.\n"},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/manual/knowledgebase/","title":"knowledge base","tags":[],"description":"","content":"Topics  general   ethercat command line interface   motion   tuning   host / ecmc server   panel   hardware    Knowledge base Due to the complexity an EtherCAT bus topology can assume, troubleshooting can be challenging. This guide should provide the basic means to diagnose simple errors and is by no means complete!\ncommand line interface A very powerful tool is provided through the command line. See a summary, incl. some examples of what possible here.\nmotion For motion related issues, a very short troubleshooting guide is provided here.\nhardware For hardware related issues, a very short troubleshooting guide is provided here.\ntuning Tune drive control loops\n"},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/manual/motion_cfg/","title":"motion","tags":[],"description":"","content":"Topics  yaml configuration   scaling   direction of motion   Drive modes CSV, CSP, CSP-PC   homing   PLC   best practice    axis ECMC has two types of axes, (1) physical axes, aka joints, and (2) virtual axes, aka end effector. Both types are classes in ECMC, the physical axis is a super-set of the virtual axes, as the latter lacks the hardware.\nyaml config Since v7, axes can be configured with yaml-files. This is a huge improvement over the classic configuration based on EPICS environment variables. For backward compatibility the classical configuration is still supported.\nlinting and schema check From v8+ yaml files are linted for syntactic errors, observe the iocsh for warnings and errors. Additionally the schema of the yaml file is checked by Cerberus. This check will point out errors in the structure of the configuration as well as certain type errors.\nplc yaml config Synchronization configurations\nscaling Configuration of scaling\ndirection Defining the direction of motion\nhoming Configuration of homing\n"},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/manual/general_cfg/startup/","title":"startup.cmd","tags":[],"description":"","content":"startup.cmd startup.cmd takes the following arguments:\n Arguments [optional] ECMC_VER = 9.5.4 EthercatMC_VER = 3.0.2 (obsolete) INIT = initAll MASTER_ID = 0 \u0026lt;-- put negative number to disable master, aka non ec-mode SCRIPTEXEC = iocshLoad NAMING = mXsXXX (default), ClassicNaming, ESSnaming EC_RATE = 1000 MODE = FULL / DAQ FULL: Init ecmc with support for both motion and DAQ (DEFAULT) DAQ: Init ecmc with support for only daq (not motion) NO_MR: Init ecmc with support for motion (without motor record) and DAQ PVA = YES / NO TMP_DIR = directory for temporary files ENG_MODE = 1/0. If ENG_MODE is set then PVs used for commissioning will be avaialble EC_TOOL_PATH = Path to ethercat tool defaults to ethercat tool in ECmasterECMC_DIR, otherwise \u0026quot;/opt/etherlab/bin/ethercat\u0026quot; MAX_PARAM_COUNT = Maximum asyn param count, defaults to 1500 [set by module] ECMC_CONFIG_ROOT = root directory of ${MODULE} ECMC_CONFIG_DB = database directory of ${MODULE} EthercatMC_DB = database directory of EthercatMC ECMC_EC_MASTER_ID = EtherCAT master id in use (for use in later scripts) ECMC_EC_SAMPLE_RATE = EtherCAT bus sampling rate [Hz] (1000 default) ECMC_EC_SAMPLE_RATE_MS = EtherCAT bus sampling rate [ms] (1 default) ECMC_MODE = ecmc mode. FULL/DAQ, Defaults to FULL ECMC_PVA = use pva, default NO ECMC_SUPPORT_MOTION = Variable to be used to block use of motion (\u0026quot;\u0026quot;/empty=support motion or \u0026quot;#-\u0026quot;=disable motion) ECMC_TMP_DIR = directory for temporary files, defaults to \u0026quot;/tmp/${IOC}/EcMaster_${ECMC_EC_MASTER_ID}}/\u0026quot; ECMC_EC_TOOL_PATH = path to ethercat tool ECMC_SAMPLE_RATE_MS = current record update rate in milliseconds ECMC_SAMPLE_RATE_MS_ORIGINAL = ECMC_SAMPLE_RATE_MS (used for restore to default if ECMC_SAMPLE_RATE_MS is changed) Normally these arguments are set when the module is required:\nrequire ecmccfg \u0026quot;ENG_MODE=1,MASTER_ID=2\u0026quot; iocsh startup ecmc needs to be started with root priviledges (or with a user in realtime group), without ecmc might segfault.\n"},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/manual/knowledgebase/general/","title":"general","tags":[],"description":"","content":"General ERROR_EC_MAIN_INVALID_SLAVE_INDEX This error could be generated if:\n Power to the slaves are missing. Slave index is wrong Slaves are disconnected (cable disconnected) The MASTER_ID of the current IOC is wrong (the slaves are on another master).  Example of error in iocsh:\niocshLoad /gfa/.mounts/sls_ioc/modules/ecmccfg/9.6.8/R7.0.8/addSlave.cmd, \u0026quot;HW_DESC=EK1100\u0026quot; #============================================================================== ecmcIf(\u0026quot;'NAN'!='NAN' and 0!=1\u0026quot;) ecmcEndIf() epicsEnvUnset(ECMC_HW_PANEL) epicsEnvSet(\u0026quot;ECMC_EC_SLAVE_NUM\u0026quot;, \u0026quot;0\u0026quot;) epicsEnvSet(\u0026quot;HW_DESC\u0026quot;, \u0026quot;EK1100\u0026quot;) epicsEnvSet(\u0026quot;P_SCRIPT\u0026quot;, \u0026quot;mXsXXX\u0026quot;) epicsEnvUnset(ECMC_EC_COMP_TYPE) ecmcFileExist(\u0026quot;/gfa/.mounts/sls_ioc/modules/ecmccfg/9.6.8/R7.0.8/ecmcEK1100.cmd\u0026quot;,1) iocshLoad \u0026quot;/gfa/.mounts/sls_ioc/modules/ecmccfg/9.6.8/R7.0.8/ecmcEK1100.cmd\u0026quot; \u0026quot;NELM=1\u0026quot; epicsEnvSet(\u0026quot;ECMC_EC_HWTYPE\u0026quot; \u0026quot;EK1100\u0026quot;) epicsEnvSet(\u0026quot;ECMC_EC_VENDOR_ID\u0026quot; \u0026quot;0x2\u0026quot;) epicsEnvSet(\u0026quot;ECMC_EC_PRODUCT_ID\u0026quot; \u0026quot;0x044c2c52\u0026quot;) iocshLoad /gfa/.mounts/sls_ioc/modules/ecmccfg/9.6.8/R7.0.8/slaveVerify.cmd ecmcEpicsEnvSetCalcTernary(SLAVE_VERIFY, \u0026quot;0==0\u0026quot;,\u0026quot;\u0026quot;,\u0026quot;#- \u0026quot;) ecmcConfigOrDie \u0026quot;Cfg.EcSlaveVerify(0,0,0x2,0x044c2c52)\u0026quot; 2024/12/19 08:57:22.552 ../ecmc/devEcmcSup/ethercat/ecmcEc.cpp/verifySlave:1881: INFO: Slave index out of range (0x26002). ECMC command \u0026quot;Cfg.EcSlaveVerify(0,0,0x2,0x044c2c52)\u0026quot; returned error: ERROR_EC_MAIN_INVALID_SLAVE_INDEX (0x26002) Diagnose the issue by logging into the host/server and run the \u0026ldquo;ethercat slaves\u0026rdquo; command. Ensure that the slaves are there and powered.\nAsyn parameter count exceeded For big IOC:s sometimes the default maximum asyn parameter count might not be enough and an error will be shown:\n... ecmcConfigOrDie \u0026quot;Cfg.SetAppMode(1)\u0026quot; 2025/10/27 11:15:39.015 ecmcAsynPortDriver:appendAvailParam: ERROR: Parameter table full (available params). Parameter with name plcs.ax27.traj.extsetpos will be discarded (max params = 1500). Increase paramtable size in call to ecmcAsynPortDriverConfigure(). ..... The solution is to increase the maximum parameter count by setting the \u0026ldquo;MAX_PARAM_COUNT\u0026rdquo; macro when requiring ecmccfg:\nrequire ecmccfg \u0026quot;MASTER_ID=1,......,MAX_PARAM_COUNT=2000\u0026quot; Callback Queue Size The default callback queue in EPICS base is only 2000 bytes. To increase the use the following command in the top of your startup script:\ncallbackSetQueueSize(\u0026lt;size\u0026gt;) Increasing the callback queue size could solve issues like \u0026ldquo;WARNING dbEvent possible queue stall\u0026rdquo;.\n"},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/manual/plc_cfg/","title":"PLC","tags":[],"description":"","content":" Topics  syntax   function libs   best practice    PLCs In ECMC, PLCs are a very powerful tool to handle EtherCAT data in real-time.\nSince ecmccfg v7, the PLCs can be instantiated in 3 different ways:\n pure text files, classic ecmc PLC pure yaml files or text files, with yaml header.  pure text files The simplest and most generic way to load plc file is by the loadPLCFile.cmd command:\n${SCRIPTEXEC} ${ecmccfg_DIR}loadPLCFile.cmd, \u0026quot;FILE=\u0026lt;filename\u0026gt;, INC=\u0026lt;include_dirs\u0026gt;, SAMPLE_RATE_MS=\u0026lt;rate_ms\u0026gt;, PLC_MACROS='\u0026lt;custom_macros\u0026gt;'\u0026quot; pure yaml Backwards compatibility for classic, text based PLCs is assured for yaml based.\n yaml is - like python - indentation sensitive!\n Indent with 2 spaces.\n All keys are mandatory.\n id: PLC id, unique uint enable: PLC enabled at start rateMilliseconds: execution rate in ms. To execute every cycle, independent of cycle rate, use -1. code: dictionary of code lines.  Line terminator is still a pipe |, this is subject to change!\n For more complex PLCs, it is highly advisable to use text based PLC definitions with a yaml header.\n plc: id: 1 enable: no rateMilliseconds: 10 code: - \u0026#39;ec0.s2.binaryOutput07:=global.test|\u0026#39; - \u0026#39;${PLC_ID}.enable:=plc0.enable|\u0026#39; - \u0026#39;ec0.s2.binaryOutput05:=not(ec0.s2.binaryOutput05)|\u0026#39; - \u0026#39;plc1.error:=12345|\u0026#39; yaml header Instead of the code dictionary, the file key can be used to load the PLC from a text file. The syntax of the text PLCs is kept from earlier versions.\nAll keys are mandatory.\n id: PLC id, unique uint enable: PLC enabled at start rateMilliseconds: execution rate in ms. To execute every cycle, independent of cycle rate, use -1. file: PLC text file to load.  If the file key is set, all definitions in the code dictionary are overwritten.\n  yaml header\n plc: id: 1 enable: yes rateMilliseconds: 10 file: plc1.plc  PLC file\n # this is a comment println(\u0026#39;plc1 from file\u0026#39;); println(\u0026#39;plc1 from file # hash with inline comment\u0026#39;); # inline test static.i:=static.i+1; # counter println(\u0026#39;i = # + - * / \u0026#39;, static.i); # println  iocsh call\n ${SCRIPTEXEC} \u0026#34;${ECMC_CONFIG_ROOT}loadYamlPlc.cmd\u0026#34; \u0026#34;FILE=./plc1File.yaml, ECMC_TMPDIR=/tmp/\u0026#34; "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/manual/knowledgebase/ethercatcli/","title":"ethercat command line interface","tags":[],"description":"","content":"ethercat CLI The IgH EtherCAT master provides a command line interface (CLI) which is a very powerful tool. The most common commands will be explained here.\nethercat master This will show the state of all masters on the respective host.\nThe command will show the state of all masters. To limit the command to a single master, make use of the -m parameter.\n The -m parameter is available to all ethercat commands, and is even require by some in case of multiple masters. Check the help by issuing ethercat -h for details.\n Example:\nethercat master Master0 Phase: Operation Active: yes Slaves: 38 Ethernet devices: Main: b4:7a:f1:30:7e:d5 (attached) Link: UP Tx frames: 133210322 Tx bytes: 11957093893 Rx frames: 133210320 Rx bytes: 11957093737 Tx errors: 0 Tx frame rate [1/s]: 500 500 500 Tx rate [KByte/s]: 43.4 43.4 43.3 Rx frame rate [1/s]: 500 500 500 Rx rate [KByte/s]: 43.4 43.4 43.3 Common: Tx frames: 737445202 Tx bytes: 114898987125 Rx frames: 737445184 Rx bytes: 114898984314 Lost frames: 18 Tx frame rate [1/s]: 500 500 500 Tx rate [KByte/s]: 43.4 43.4 43.3 Rx frame rate [1/s]: 500 500 500 Rx rate [KByte/s]: 43.4 43.4 43.3 Loss rate [1/s]: 0 0 0 Frame loss [%]: 0.0 0.0 0.0 Distributed clocks: Reference clock: Slave 0 DC reference time: 708164169043902491 Application time: 708427716430011969 2022-06-13 09:28:36.430011969 In case the numbers mostly zero, check the link state.\nEthernet devices: Main: b4:7a:f1:30:7e:d5 (attached) Link: UP \u0026lt;--- HERE If the link is DOWN, try bringing the network device up manually. This, can be done with ip link set \u0026lt;nameOfNetworkDevice\u0026gt; up\nIf the device name is unknown, check with ip link show and search for the MAC the EtherCAT master is bound to.\nethercat slaves As the command suggest, this will provide a list of the EtherCAT slaves.\nExample:\nethercat slaves 0 0:0 PREOP + EK1100 EtherCAT Coupler (2A E-Bus) 1 0:1 PREOP + EL9227-5500 ?berstromschutz 24V DC, 2K., max. 10A (Summe), eins 2 0:2 PREOP + EL1034 4K. Dig. Eingang 24V, potenzialfrei, 10?s 3 0:3 PREOP + EL5042 2Ch. BiSS-C Encoder 4 0:4 PREOP + EL5042 2Ch. BiSS-C Encoder 5 0:5 PREOP + EL9410 E-Bus Netzteilklemme (Diagnose) 6 0:6 PREOP + EL9576 Bremschopper Klemme 7 0:7 PREOP + EL7041 1Ch. Stepper motor output stage (50V, 5A) 8 0:8 PREOP + EL7041 1Ch. Stepper motor output stage (50V, 5A) 9 0:9 PREOP + EL7041 1Ch. Stepper motor output stage (50V, 5A) 10 0:10 PREOP + EL7041 1Ch. Stepper motor output stage (50V, 5A) 11 0:11 PREOP + EK1100 EtherCAT-Koppler (2A E-Bus) 12 0:12 PREOP + EL9227-5500 ?berstromschutz 24V DC, 2K., max. 10A (Summe), eins 13 0:13 PREOP + EL1034 4K. Dig. Eingang 24V, potenzialfrei, 10?s 14 0:14 PREOP + EL1034 4K. Dig. Eingang 24V, potenzialfrei, 10?s 15 0:15 PREOP + EL1034 4K. Dig. Eingang 24V, potenzialfrei, 10?s 16 0:16 PREOP + EL5042 2Ch. BiSS-C Encoder 17 0:17 PREOP + EL5042 2Ch. BiSS-C Encoder 18 0:18 PREOP + EL5042 2Ch. BiSS-C Encoder 19 0:19 PREOP + EL3314 4K. Ana. Eingang Thermoelement (TC) 20 0:20 PREOP + EL9410 E-Bus Netzteilklemme (Diagnose) 21 0:21 PREOP + EL9576 Bremschopper Klemme 22 0:22 PREOP + EL7041 1Ch. Stepper motor output stage (50V, 5A) 23 0:23 PREOP + EL7041 1Ch. Stepper motor output stage (50V, 5A) 24 0:24 PREOP + EL7041 1Ch. Stepper motor output stage (50V, 5A) 25 0:25 PREOP + EL7041 1Ch. Stepper motor output stage (50V, 5A) 26 0:26 PREOP + EL7041 1Ch. Stepper motor output stage (50V, 5A) 27 0:27 PREOP + EL7041 1Ch. Stepper motor output stage (50V, 5A) 28 0:28 PREOP + EKM1101 EtherCAT Coupler (2A E-Bus, ID switch, Diagnostics, is 29 0:29 PREOP + ELM3004-0000 4K. Ana. Eingang +/-30V, 24 bit, hochgenau 30 0:30 PREOP + ELM3146-0000 6Ch. Ana. Input +/-10V, +/-20mA, 24 bit, high prec 31 0:31 PREOP + ELM3602-0002 2Ch. IEPE Sensor, 24 bit, high precision 32 0:32 OP + EP7047-1032 1K. Schrittmotor-Endstufe (50V, 5A) 33 0:33 OP + EP5001-0002 1K. SSI Encoder 34 0:34 PREOP + EP7041-0002 1K. Schrittmotor-Endstufe (50V, 5A) 35 0:35 PREOP + EP7211-0034 1Ch. MDP742 Servo motor output stage with OCT (50V, 36 0:36 PREOP + EP7211-0034 1K. MDP742 Servo-Motor-Endstufe mit OCT (50V, 4,5A 37 0:37 PREOP + EP7211-0034 1K. MDP742 Servo-Motor-Endstufe mit OCT (50V, 4,5A ethercat sdos Download and display the service data objects.\nUse with caution as this command can take a long time to fetch all data. It is advised to limit the download to the specific slave in question, with the -p \u0026lt;slaveID\u0026gt; parameter.\n ethercat pdos Similar to the sdos counterpart, this command will fetch the currently applied process data objects. To avoid excessive output, it is advised to limit the command to a single slave.\nethercat upload With this command the value of a register can be fetched.\nIf the type is not explicitly given, first issue ethercat -p \u0026lt;slaveID\u0026gt; sdos. This will allow implicit type handling.\n Example: Fetch content of register 0x8020, sub-register 0x05 from slave 32.\nethercat upload -m0 -p32 0x8020 0x05 0x03e8 1000 ethercat download With this command the value of a register can be set on the slave.\nIf the type is not explicitly given, first issue ethercat -p \u0026lt;slaveID\u0026gt; sdos. This will allow implicit type handling.\n Example: Set value of register 0x8010, sub-register 0x07 from slave 7 to 314.\nethercat download -m0 -p7 0x8010 0x07 314 ethercat states With this command a specific state of a slave can be forced, or at least an attempt to enter the specific state is made.\nThis is helpful when a slave is stuck, e.g. with an error. Rather than cycle the power of the entire controller, the slave can be set to \u0026lsquo;REBOOT\u0026rsquo;. This might be enough to recover.\nAlternatively, cycling to \u0026lsquo;INIT\u0026rsquo; and back to \u0026lsquo;OP\u0026rsquo; might also be attempted.\nA power cycling of the of the EtherCAT components is the last resort!\n "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/manual/knowledgebase/motion/","title":"motion","tags":[],"description":"","content":"Topics  both_limits error position lag error, (following error) drive refuse to enable force manual motion double limit switches   both_limits error The \u0026ldquo;BOTH_LIMITS\u0026rdquo; error can be related to that limits switches are not powered with 24V. As standard at PSI, limits are feed from 24V outputs, normally an EL2819 terminal. Basically the outputs needs then to be set to 1 in order to power the switches. Check the schematics in order to find out which output that powers the switches for a certain axis and then use one the following approaches to set it to 1:\nDefine the output in axis yaml file:\naxis: id: 1 # Axis id ... feedSwitchesOutput: ec0.s5.binaryOutput02 # Ethercat entry for feed switches ... By using the command Cfg.WriteEcEntryEcPath(ec\u0026lt;master_id\u0026gt;.s\u0026lt;slave_id\u0026gt;.binaryOutput\u0026lt;id\u0026gt;,\u0026lt;value\u0026gt;):\necmcConfigOrDie \u0026quot;Cfg.WriteEcEntryEcPath(ec0.s5\u0026gt;.binaryOutput02,1)\u0026quot; position lag error A position lag error (following error) can be generated in the following situations:\n The motor torque is too low, making it hard for the motor to keep up with the setpoint. The scaling factors are wrong resulting in that the feed forward part of the controller is not working well. The velocity setpoint is too high resulting in motor stall (common for stepper motors). The velocity setpoint is higher than what the drive can achieve (saturated velocity setpoint).  1. motor torque to low  First ensure that the mechanics are i good condition and not blocked (over the entire working range). If possible, measure needed torque with a torque meter. Check motor data, can the motor deliver the required torque at the required speed. If not, then a motor with higher torque is needed. Check the current setting of the motor. If possible increase the current setting to get a higher torque.  Before increase current to the motor, make sure that both motor and drive can handle the higher current. Extra care needs to be taken for vacuum applications.\n 2. scaling factors are wrong Check the scaling documentation here. One way to test if the scaling is correct is to set all controller parameters (except Kff) to 0 and then initiate a move. Basically the actual position of the axis should follow the setpoint closely with the same slope. If the slope differs, then the scaling factors are wrong.\n3. the velocity setpoint is too high resulting in stall If a stepper motor stalls because of too high velocity there\u0026rsquo;s a few thing that can be done in order to improve the ability to reach higher velocities:\n Add a damper: This is normally very efficient but not always possible. Tune controller parameters (both position loop in ecmc and the controller loops in the drive), see hardware/tuning If possible, test to increase or reduce current (make sure you do not burn the motor if increasing).  Before increase current to the motor, make sure that both motor and drive can handle the higher current. Extra care needs to be taken for vacuum applications.\n 4. velocity higher than allowed by driver The velocity setpoint of drives covers a certain velocity range:\n EL70xx stepper drives default: 16bit setpoint that corresponds to a velocity range of +-2000full-steps/s. EL72xx servo drives default: 32bit setpoint that corresponds to a velocity range of either +-6000Hz or +-8000Hz depending on the motor pole count.  If a velocity outside the velocity range is requested, the velocity setpoint will be saturated and the requested velocity will not be reached resulting in a position lag error.\nFor EL70xx drives the velocity range can be configured to other values than the default +-2000full-steps/s. See el70x1 speed range for setting other velocity range.\ndrive refuse to enable First check the dedicated hardware drive panel for diagnostics and errors/warnings. For EL70x1 drive diagnostics, check el70x1.\nPossible reasons:\n For systems equipped with motion safety (STO or power to the drive removed by contactor): Check status of safety system. Drives with STO:   EL72xx-9xxx EP7211-0034 Festo CMMT-S  Over current protection of motor power (48V) tripped. No motor power connected (48V or24V). ecmc PLC disabling axis, check PLC sources. Motion axis in error state. Some errors prevent the axis from being enabled. Check axis error state. Drive hardware enable input not set high (valid for EL70xx if special cfgs). Axis object configured with external interlock (yaml-\u0026gt;input.interlock).  force manual motion  This procedure is for experts only. You run the risk of destroying expansive devices! Limit switches are not obeyed! YOU HAVE BEEN WARNED!\n In case the hardware is fine, the cables are checked, human error is mostly excluded, or the system used to work but doesn\u0026rsquo;t work any longer, directly writing to the drive is possible.\nFor this however, the IOC needs to be reconfigured to not link the hardware to an axis!\n Edit the startup script and comment out the axis, just leave the slave configuration. restart the IOC check the PVs for the drive in question (slave 7 in this case) dbgrep \u0026quot;*s007*\u0026quot; There should be two PVs ending with, -Drv01-Cmd and -Drv01-Spd Set -Drv01-Cmd to 1 and check the amplifier did enable, if you don\u0026rsquo;t know how to check for an enabled amplifier, you should not use this command! After the amplifier is engaged, write a small number to -Drv01-Spd. Depending on the scaling, the number might be in the range of 1..1000. Observe the encoder, or in case of open-loop, the device itself.  double limit switches For axes with dual limit switches or where special logic is needed, limit switches can be overriden by the keyword \u0026ldquo;plcOverride\u0026rdquo;:\n... input: limit: forward: 'plcOverride' # Overridden, see plc code below backward: 'plcOverride' # Overridden, see plc code below ... The limits then must be written to from PLC. Any logic can then be applied to to set the limits, example:\n... plc: enable: true # Enable axis plc externalCommands: true # Allow axis to inputs from PLC code: # Sync code (appended after code in plc.file) - ax${AX_ID=1}.mon.lowlim:=ec_chk_bit(ec0.s$(DRV_SID).binaryInputs01,0) and ec0.s2.analogInput01\u0026lt;1000; - ax${AX_ID=1}.mon.highlim:=ec_chk_bit(ec0.s$(DRV_SID).binaryInputs01,1) and ec0.s33.binaryInput02; ... Note that in plc code the bits must be accessed with the ec_chk_bit()-command.\ndouble limit switches legacy (still an option) Sometimes two limit switches are needed, but only one can be linked in the yaml configuration. A use case could be if two axes have overlapping ranges and a switch is used to prevent them from colliding.\nIn order to configurethis a PLC needs to be added where the two limits switches are combined with a \u0026ldquo;and\u0026rdquo; (for normally closed switches) into one bit by the use of the simulation entries (ec.s.ONE or ec.s.ZERO).\n Add a plc Choose a non used bit in the simulation emtry ec.s.ZERO (dummy 32bit memory area in ecmc initiated to 0). Any slave can be chooses but probbaly makes sense to use the drive slave. Add code to combine the two switches into one bit (\u0026ldquo;and\u0026rdquo;). Use ec_wrt_bit to set the value. Use the selected simulation bit in the yaml cfg.  Example (use ec0.s2.ZERO.31 as combined limit switch):\n# Master 0 # Drive slave 3 (can be any slave) # Bit 31 # Switch 1: ec0.s5.binaryInput01 # Switch 2: ec0.s5.binaryInput02 ec0.s3.ZERO:=ec_wrt_bit(ec0.s3.ZERO,ec0.s5.binaryInput01 and ec0.s5.binaryInput02,31); Then use as forward or backward bit in yaml:\ninput: limit: forward: ec0.s2.ZERO.31 # In PLC \u0026quot;ec0.s5.binaryInput01 and ec0.s5.binaryInput02\u0026quot; backward: .... yaml parser installation error ecmc yaml motion axis configururations depends on python venv with certain libs. The needed venv is installed in the \u0026ldquo;/tmp\u0026rdquo; dir when the first axis yaml file is loaded in a startup file.\nIf the ecmc-server is not allowed to install with pip, like in the machine networks, then the below error meassge is printed in iocsh and loading of the axis fails:\niocshLoad /gfa/.mounts/sls_ioc/modules/ecmccfg/9.6.8/R7.0.8/loadYamlAxis.cmd, \u0026quot;FILE=cfg/servo-linear.yaml, ID=1, NAME=SERVO1, DESC=test, DRV_SLAVE=9\u0026quot; #============================================================================== # loadYamlAxis.cmd on error halt # Step 1: Get Filename (need to check if filename contains other macros also). Bascally run the filename in this iocsh ecmcFileExist(\u0026quot;cfg/servo-linear.yaml\u0026quot;,1) epicsEnvSet(FILE_TEMP_BASE,/tmp/X01DD-CPCL-FEMOT02/EcMaster_2/cfg/servo-linear.yaml) epicsEnvSet(FILE_TEMP_1,/tmp/X01DD-CPCL-FEMOT02/EcMaster_2/cfg/servo-linear.yaml_1) system \u0026quot;. /gfa/.mounts/sls_ioc/modules/ecmccfg/9.6.8/R7.0.8/pythonVenv.sh -d /tmp/X01DD-CPCL-FEMOT02/EcMaster_2/; python /gfa/.mounts/sls_ioc/modules/ecmccfg/9.6.8/R7.0.8/ecmcPlcGetFileName.py cfg/servo-linear.yaml /tmp/X01DD-CPCL-FEMOT02/EcMaster_2/cfg/servo-linear.yaml_1\u0026quot; Collecting wheel Retrying (Retry(total=4, connect=None, read=None, redirect=None, status=None)) after connection broken by 'ReadTimeoutError(\u0026quot;HTTPSConnectionPool(host='pypi.org', port=443): Read timed out. (read timeout=15)\u0026quot;)': /simple/wheel/ Retrying (Retry(total=3, connect=None, read=None, redirect=None, status=None)) after connection broken by 'ReadTimeoutError(\u0026quot;HTTPSConnectionPool(host='pypi.org', port=443): Read timed out. (read timeout=15)\u0026quot;)': /simple/wheel/ Retrying (Retry(total=2, connect=None, read=None, redirect=None, status=None)) after connection broken by 'ReadTimeoutError(\u0026quot;HTTPSConnectionPool(host='pypi.org', port=443): Read timed out. (read timeout=15)\u0026quot;)': /simple/wheel/ PSI specific: The solution is to use the ecmc_server_cfg repo as described in it\u0026rsquo;s readme.md. This repo enures that the correct python venv is copied after each boot and therefore the install is not needed at ioc startup.\nIn future release of ecmc/ecmccfg the yaml parser will be moved into ecmc (c++), making the python venv obsolete and not needed. This is WIP.\n "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/manual/general_cfg/startup/modes/","title":"modes","tags":[],"description":"","content":"ecmc modes ecmc can be started in different modes by setting the MODE parameter to startup.cmd (or require ecmccfg):\n FULL DAQ NO_MR  A separate mode for commissioning is also available, called ENG_MODE.\nmode==FULL (default) In FULL mode all ecmc functionalities are supported, like motion, daq and plcs.\nExample of starting ecmc in FULL mode:\n$(ECMCCFG_INIT)$(SCRIPTEXEC) ${ecmccfg_DIR}startup.cmd, \u0026quot;IOC=$(IOC),ECMC_VER=develop,MODE=FULL\u0026quot; # or since FULL mode is default the MODE parameter can be ignored $(ECMCCFG_INIT)$(SCRIPTEXEC) ${ecmccfg_DIR}startup.cmd, \u0026quot;IOC=$(IOC),ECMC_VER=develop\u0026quot; mode==DAQ In DAQ mode, motion functionalities are disabled and the following commands are blocked:\n configureAxis.cmd configureVirtualAxis.cmd addAxis.cmd addVirtualAxis.cmd  This mode is intended to be used for pure DAQ use cases.\nExample of starting ecmc in DAQ mode:\n$(ECMCCFG_INIT)$(SCRIPTEXEC) ${ecmccfg_DIR}startup.cmd, \u0026quot;IOC=$(IOC),ECMC_VER=develop,MODE=DAQ\u0026quot; NOTE: The default record update rate is set to 10ms in initAlll.cmd. For DAQ applications it could be needed to change this parameter to update records faster by changing the ECMC_SAMPLE_RATE_MS variable:\nepicsEnvSet(\u0026quot;ECMC_SAMPLE_RATE_MS\u0026quot;,1) mode==NO_MR In this mode all features are supported, but motor record will not be created for motion axes.\nENG_MODE Setting the parameter ENG_MODE=1 will result in loading of extra PVs usefull for commissioning, i.e. controller parameters for motion axes.\n"},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/manual/motion_cfg/best_practice/stepper_biss_c/","title":"stepper and biss-c","tags":[],"description":"","content":"setup  EL7041 stepper drive slave EL5042 BISS-C encoder slave Lab test stage (1mm/rev) Lab 4 axis motion control box RLS BISS-C linear encoder (absolute) Open loop encoder (incremental)  scalings Config for scaling in mm, mm/s, mm/s2\nencoder scaling Two encoders are configured:\n Closed loop: BISS-C. This is used as the default encoder for control Open loop: EL7041 Step counter  Both these encoders (and drive) should be scaled to the same unit (mm).\nRLS BISS-C (encoder 1) RLS BISS-C:\n encoder.numerator: Travels 1 mm/rev (linear encoder) encoder.denominator: Resolution: 4096 counts per = 1mm encoder.absBits: 26 bits encoder.type: Absolute (type 1) encoder.absOffset: Offset to 0 position of linear stage (-1408.794 in this example)  encoder: desc: BISS-C numerator: 1 # Scaling numerator example 1 mm/rev denominator: 4096 # Scaling denominator example 4096 ticks per 360 degree type: 1 # Type: 0=Incremental, 1=Absolute bits: 26 # Total bit count of encoder raw data absBits: 26 # Absolute bit count (for absolute encoders) always least significant part of 'bits' absOffset: -1408.794 # Encoder offset in eng units (for absolute encoders) position: ec0.s$(ENC_SID).positionActual${ENC_CH=01} # Ethercat entry for actual position input (encoder) status: ec0.s$(ENC_SID).encoderStatus${ENC_CH=01} # mandatory only if 'warning' or 'error' are used ready: 2 # Bit in encoder status word for encoder ready warning: 0 # Warning (optional) error: # max 3 (optional) - 1 # Error 0 Hardware configuration EL5042\nDo not use the LSB offset functionality of the EL5042 (0x80p8:17). The same amount of ones (\u0026ldquo;1\u0026rdquo;) will be shifted in as MSB which then normally leads to a higher position value, which is confusing. For more information see the knowledge-base/hardware section.\n open loop (encoder 2) The EL7041 drive has a build in micro step counter (64 micro-steps/full-step):\n encoder.numerator: Travels 1 mm/rev encoder.denominator: Resolution: 200*64=12800 micro-steps/rev = 12800 micro-steps/mm encoder.bits: The counter is 16bit (default) encoder.type: Incremental (type 0)  encoder: desc: 'Open loop' unit: mm numerator: 1 # Scaling numerator denominator: 12800 # Scaling denominator type: 0 # Type: 0=Incremental, 1=Absolute bits: 16 # Total bit count of encoder raw data absBits: 0 # Absolute bit count (for absolute encoders) absOffset: 0 # Encoder offset in eng units (for absolute encoders) position: ec0.s$(DRV_SID).positionActual01 # Ethercat entry for actual position input (encoder) homing: refToEncIDAtStartup: 1 # Ref encoder at startup (to BISS value) drive scalings The EL7041 is default setup to operate in a velocity range of +-2000 full steps/s which then corresponds to the 16bit drive.setpoint parameter (ec0.s$(DRV_SID).velocitySetpoint01):\n drive.numerator: Max velo = 2000 full-steps/s == 10mm/s drive.denominator: velocity setpoint is 16bit == +-15bit = 32768 drive.type: Stepper drive, set to 0  drive: numerator: 10 # Fastest speed in eng. units (2000 Full-steps/s==10mm/s) denominator: 32768 # I/O range for ECMC_EC_ALIAS_DRV_VELO_SET (normally +-16bit) type: 0 # Stepper: 0. DS402: 1 (DS402 = servos and advanced stepper drives) setpoint: ec0.s$(DRV_SID).velocitySetpoint01 # Velocity setpoint if CSV. Position setpoint if CSP control: ec0.s$(DRV_SID).driveControl01 # Control word ethercat entry enable: 0 # Enable bit index in control word (not used if DS402) reset: 1 # Reset bit in control word (if no drive reset bit then leave empty) reduceTorque: 2 # Reduce torque bit in drive control word reduceTorqueEnable: True # Enable reduce torque functionality status: ec0.s$(DRV_SID).driveStatus01 # Status word ethercat entry enabled: 1 # Enabled bit index in status word (not used if DS402) warning: 2 # Warning bit in status word (if no drive warning bit then leave empty) error: # max 3 error bits in status word - 3 # Error 0 (if no drive error bit then leave empty) - 7 # Error 1 (if no drive error bit then leave empty) - 14 # Error 2 (if no drive error bit then leave empty) switches In standard setup switches are feed from 24V output, for the lab 4ax motion crate this is not the case. However, the configuration for feeding switches (axis.feedSwitchesOutput) have been added anyway:\naxis: id: 1 # Axis id feedSwitchesOutput: ec0.s5.binaryOutput01 # Ethercat entry for feed switches At PSI, the limit switches are connected directly to the 2 inputs of the EL70xx stepper drives and are accessible in the status word, bit 11 and 12:\ninput: limit: forward: ec0.s$(DRV_SID).driveStatus01.12 # Ethercat entry for low limit switch input backward: ec0.s$(DRV_SID).driveStatus01.11 # Ethercat entry for high limit switch input home: 'ec0.s$(DRV_SID).ONE.0' # Ethercat entry for home switch interlock: 'ec0.s$(DRV_SID).ONE.0' # Ethercat entry for interlock switch input  Always verify where the switches are connected in the electrical drawings.\n All switches in the \u0026ldquo;input\u0026rdquo; section needs to be linked. If not used, then the simulation registers, \u0026ldquo;ONE\u0026rdquo; and \u0026ldquo;ZERO\u0026rdquo;, can be used:\n 32 bit register of ones (rw): ec\u0026lt;master_id\u0026gt;.s\u0026lt;slave_id\u0026gt;.ONE. 32 bit register of zeros (rw): ec\u0026lt;master_id\u0026gt;.s\u0026lt;slave_id\u0026gt;.ZERO.  Example, Use bit 1 in the ONE register of slave 1:\nec0.s1.ONE.1  If no ethercat slave is defined, slave number \u0026ldquo;-1\u0026rdquo; can be used: ec\u0026lt;master_id\u0026gt;.s-1.ONE.\n "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/manual/plc_cfg/syntax/","title":"syntax","tags":[],"description":"","content":"In ECMC, PLCs are based on the exprtk expression evaluation library. For detailed syntax help please visit the exprtk website\ncommon errors, misconceptions and info operators  :=: assignment = or ==: equal comparison  functions PLC do not immediately write to the bus! The PLC will execute synchronous to the cycle, or at an integer fraction of it. The processed data will be send to the bus with the next cycle. PLCs do not delay the bus!\nstatement terminator Statements are terminated by a semicolon ;\nvariables All variables are initiated to 0\ncomments The hash character # is reserved for comments. Everything after this char will be removed before compile. println('########'); will be seen by the compiler as println(' !\n macros So far macro substitution is not implemented for yaml!\n If macro substitution is needed, please use the traditional approach using loadPLCFile.cmd, with the PLC_MACROS variable.\n examples PLC can access:\n variables process data axis PLCs data storage  Function examples are given at the end.\nCustom function libs in exprtk syntax can be added and loaded to the PLC objects.\n Custom plc functions can be written in c in plugins.\n general 1. Assignment: ec0.s1.VALUE:=100; 2. if-else (note the equal sign): if(ec0.s1.VALUE=100) { # code } else { # code }; 3. for loop: for (static.i := 0; static.i \u0026lt; static.elements; static.i += 1) { # code }; 4. printouts (minimize printouts or use only for debug): print(\u0026#34;The value of ec0.s1.VALUE is: \u0026#34;,ec0.s1.VALUE); # Without line feed println(\u0026#34;The value of ec0.s1.VALUE is: \u0026#34;,ec0.s1.VALUE); # With line feed Also see the \u0026#34;ec_print_bin()\u0026#34; and \u0026#34;ec_print_hex()\u0026#34; below. variables generic 1. static.\u0026lt;varname\u0026gt; Static variable. Initiated to 0. (rw) Access only in the PLC where defined. Will keep value between execution loops. 2. global.\u0026lt;varname\u0026gt; Global variable. Initiated to 0. (rw) Access from all PLCs. Will keep value between execution loops. 3. var \u0026lt;varname\u0026gt; Local variable (exprtk syntax) (rw) Will NOT keep value between execution loops. EtherCAT 1. ec\u0026lt;ecid\u0026gt;.s\u0026lt;sid\u0026gt;.\u0026lt;alias\u0026gt; ethetcat data (rw) ecid: ethercat master index sid: ethercat slave bus position alias: entry name as defined in \u0026#34;Cfg.EcAddEntryComplete() 2. ec\u0026lt;ecid\u0026gt;.masterstatus Status of master (1=OK) motion 1. ax\u0026lt;id\u0026gt;.id axis id (ro) 2. ax\u0026lt;id\u0026gt;.reset reset axis error (rw) 3. ax\u0026lt;id\u0026gt;.counter execution counter (ro) 4. ax\u0026lt;id\u0026gt;.error error (ro) 5. ax\u0026lt;id\u0026gt;.allowplccmd Allow writes to axis from PLC (rw) 6. ax\u0026lt;id\u0026gt;.enc.actpos actual position (rw) 7. ax\u0026lt;id\u0026gt;.enc.extactpos actual position from plc sync. expression (ro) 8. ax\u0026lt;id\u0026gt;.enc.actvel actual velocity (ro) 9. ax\u0026lt;id\u0026gt;.enc.rawpos actual raw position (ro) 10. ax\u0026lt;id\u0026gt;.enc.source internal source or expressions (rw) source = 0: internal encoder source \u0026gt; 0: actual pos from expr 11. ax\u0026lt;id\u0026gt;.enc.homed encoder homed (rw) 12. ax\u0026lt;id\u0026gt;.enc.homepos homing position (rw) 13. ax\u0026lt;id\u0026gt;.traj.setpos curent trajectory setpoint (rw) 14. ax\u0026lt;id\u0026gt;.traj.targetpos target position (rw) 15. ax\u0026lt;id\u0026gt;.traj.extsetpos current trajecrory setpoint from plc sync. expression (rw) 16. ax\u0026lt;id\u0026gt;.traj.targetvel target velocity setpoint (rw) 17. ax\u0026lt;id\u0026gt;.traj.targetacc target acceleration setpoint (rw) 18. ax\u0026lt;id\u0026gt;.traj.targetdec target deceleration setpoint (rw) 19. ax\u0026lt;id\u0026gt;.traj.setvel current velocity setpoint (ro) 20. ax\u0026lt;id\u0026gt;.traj.setvelffraw feed forward raw velocity (ro) 21. ax\u0026lt;id\u0026gt;.traj.command command (rw) command=1: move velocity command=2: move rel. pos command=3: move abs. pos command=10: homing 22. ax\u0026lt;id\u0026gt;.traj.cmddata cmddat. Homing procedure only valid if ax\u0026lt;id\u0026gt;.traj.command=10 cmddata=1 : ref low limit cmddata=2 : ref high limit cmddata=3 : ref home sensor (via low limit) cmddata=4 : ref home sensor (via high limit) cmddata=5 : ref center of home sensor (via low limit) cmddata=6 : ref center of home sensor (via high limit) cmddata=15 : direct homing cmddata=21 : ref partly abs. encoder (via low limit). ref at abs bits. over/under-flow.. cmddata=22 : ref partly abs. encoder (via high limit). ref at abs bits. over/under-flow.. 23. ax\u0026lt;id\u0026gt;.traj.source internal source or expressions (rw) source = 0: internal traj source \u0026gt; 0: setpoints from expr 24. ax\u0026lt;id\u0026gt;.traj.execute execute motion command (rw) 25. ax\u0026lt;id\u0026gt;.traj.busy axis busy (ro) 26. ax\u0026lt;id\u0026gt;.traj.dir axis setpoint direction (ro) ax\u0026lt;id\u0026gt;.traj.dir\u0026gt;0: forward ax\u0026lt;id\u0026gt;.traj.dir\u0026lt;0: backward ax\u0026lt;id\u0026gt;.traj.dir=0: standstill 27. ax\u0026lt;id\u0026gt;.cntrl.error actual controller error (ro) 28. ax\u0026lt;id\u0026gt;.cntrl.poserror actual position error (ro) 29. ax\u0026lt;id\u0026gt;.cntrl.output actual controller output (ro) 30. ax\u0026lt;id\u0026gt;.drv.setvelraw actual raw velocity setpoint (ro) 31. ax\u0026lt;id\u0026gt;.drv.enable enable drive command (rw) 32. ax\u0026lt;id\u0026gt;.drv.enabled drive enabled (ro) 33. ax\u0026lt;id\u0026gt;.seq.state sequence state (homing) (ro) 34. ax\u0026lt;id\u0026gt;.mon.ilock motion interlock (both dir) (rw) ax\u0026lt;id\u0026gt;.mon.ilock=1: motion allowed ax\u0026lt;id\u0026gt;.mon.ilock=0: motion not allowed 35. ax\u0026lt;id\u0026gt;.mon.ilockbwd motion interlock bwd dir (rw) ax\u0026lt;id\u0026gt;.mon.ilockbwd=1: motion allowed ax\u0026lt;id\u0026gt;.mon.ilockbwd=0: motion not allowed 36. ax\u0026lt;id\u0026gt;.mon.ilockfwd motion interlock fwd dir (rw) ax\u0026lt;id\u0026gt;.mon.ilockfwd=1: motion allowed ax\u0026lt;id\u0026gt;.mon.ilockfwd=0: motion not allowed 37. ax\u0026lt;id\u0026gt;.mon.attarget axis at taget (ro) 38. ax\u0026lt;id\u0026gt;.mon.lowlim low limit switch (ro) 39. ax\u0026lt;id\u0026gt;.mon.highlim high limit switch (ro) 40. ax\u0026lt;id\u0026gt;.mon.homesensor home sensor (ro) 41. ax\u0026lt;id\u0026gt;.mon.lowsoftlim low soft limit (rw) 42. ax\u0026lt;id\u0026gt;.mon.highsoftlim high soft limit (rw) 43. ax\u0026lt;id\u0026gt;.mon.lowsoftlimenable low soft limit enable (rw) 44. ax\u0026lt;id\u0026gt;.mon.highsoftlimenable high soft limit enable (rw) 45. ax\u0026lt;id\u0026gt;.blockcom Enables/disables \u0026#34;set\u0026#34; commands (rw) via command parser (ascii commands) Statuses can still be read. Exceptions (\u0026#34;set\u0026#34;-commands) that will work: - \u0026#34;StopMotion(axid)\u0026#34; - \u0026#34;Cfg.SetAxisBlockCom(axid,block)\u0026#34; 46. ax\u0026lt;id\u0026gt;.ctrl.kp Set PID-controller kp (rw) 47. ax\u0026lt;id\u0026gt;.ctrl.ki Set PID-controller ki (rw) 48. ax\u0026lt;id\u0026gt;.ctrl.kd Set PID-controller kd (rw) 49. ax\u0026lt;id\u0026gt;.ctrl.kff Set PID-controller kff (rw) PLC 1. plc\u0026lt;id\u0026gt;.enable plc enable (rw) (end exe with \u0026#34;plc\u0026lt;id\u0026gt;.enable:=0#\u0026#34; Could be use full for startup sequences) 2. plc\u0026lt;id\u0026gt;.error plc error (rw) Will be forwarded to user as controller error. 3. plc\u0026lt;id\u0026gt;.scantime plc sample time in seconds (ro) 4. plc\u0026lt;id\u0026gt;.firstscan true during first plc scan only (ro) use full for initiations of variables 5. ax\u0026lt;id\u0026gt;.plc.enable Same as plc\u0026lt;id\u0026gt;.enable but for axis \u0026lt;id\u0026gt; sync plc. 6. ax\u0026lt;id\u0026gt;.plc.error Same as plc\u0026lt;id\u0026gt;.error but for axis \u0026lt;id\u0026gt; sync plc. 7. ax\u0026lt;id\u0026gt;.plc.scantime Same as plc\u0026lt;id\u0026gt;.scantime but for axis\u0026lt;id\u0026gt; sync plc. 8. ax\u0026lt;id\u0026gt;.plc.firstscan Same as plc\u0026lt;id\u0026gt;.firstscan but for axis \u0026lt;id\u0026gt; sync plc. data storage 1. ds\u0026lt;id\u0026gt;.size Set/get size of data storage (rw) Set will clear the data storage 2. ds\u0026lt;id\u0026gt;.append Add new data at end (rw) Current position index will be increased 3. ds\u0026lt;id\u0026gt;.data Set/get data ar current position (rw) 4. ds\u0026lt;id\u0026gt;.index Set/get current position index (rw) 5. ds\u0026lt;id\u0026gt;.error Data storage class error (ro) 6. ds\u0026lt;id\u0026gt;.clear Data buffer clear (set to zero) (ro) 7. ds\u0026lt;id\u0026gt;.full True if data storage is full (ro) functions EtherCAT 1. retvalue = ec_set_bit( \u0026lt;value\u0026gt;, : Value to change \u0026lt;bitindex\u0026gt; : Bit index ); Sets bit at bitindex position of value. Returns the new value. 2. retvalue = ec_wrt_bit( \u0026lt;value\u0026gt;, : Value to change \u0026lt;wrtValue\u0026gt;, : Value of bit to write \u0026lt;bitindex\u0026gt; : Bit index ); Write wrtValue to a bit at bitindex position of value. Returns the new value. 3. retvalue = ec_wrt_bits( \u0026lt;value\u0026gt;, : Value to change \u0026lt;wrtValue\u0026gt;, : Value of bit to write \u0026lt;startBit\u0026gt; : Start bit index (lsb is bit 0) \u0026lt;stopBit\u0026gt; : Stop bit index ); Write wrtValue to a range of bits (statBit..stopBit) of value. Returns the new value. 4. retvalue = ec_clr_bit( \u0026lt;value\u0026gt;, : Value to change \u0026lt;bitindex\u0026gt; : Bit index ); Clears bit at bitindex position of value. Returns the new value. 5. retvalue = ec_flp_bit( \u0026lt;value\u0026gt;, : Value to change \u0026lt;bitindex\u0026gt; : Bit index ); Flips bit at bitindex position of value. Returns the new value. 6. retvalue = ec_chk_bit( \u0026lt;value\u0026gt;, : Value to change \u0026lt;bitindex\u0026gt; : Bit index ); Checks bit at bitindex position of value. Returns the value of bit. 7. retvalue = ec_chk_bits( \u0026lt;value\u0026gt;, : Value to change \u0026lt;startBit\u0026gt; : Start bit index (lsb is bit 0) \u0026lt;stopBit\u0026gt; : Stop bit index ); Checks range of bits (startBit..stopBit) of value. Returns the value of bits. 8. retvalue = ec_print_hex( \u0026lt;value\u0026gt;, : Value to print \u0026lt;startBit\u0026gt; : Start bit index \u0026lt;stopBit\u0026gt; : Stop bit index ); Prints \u0026lt;startBit\u0026gt; to \u0026lt;stopBit\u0026gt; of \u0026lt;value\u0026gt; in hex format Returns error code or 0 if success. 9. retvalue = ec_print_bin( \u0026lt;value\u0026gt;, : Value to print \u0026lt;startBit\u0026gt; : Start bit index \u0026lt;stopBit\u0026gt; : Stop bit index ); Prints \u0026lt;startBit\u0026gt; to \u0026lt;stopBit\u0026gt; of \u0026lt;value\u0026gt; in bin format Returns error code or 0 if success. 10. retvalue = ec_mm_cp( \u0026lt;srcId\u0026gt;, : Source memmap index \u0026lt;sdestId\u0026gt; : Dest memmap index ); Copies data from source memmap to dest memmap. The memmap ids are defined by the order they are created (starting at 0). The smallest memmap size will define the amount of data copied. Returns 0 for success or an error code. Note: The mmId can be retrieved by the bellow ecmc command (and feed into plc via macro): ecmcConfig \u0026#34;EcGetMemMapId(ec0.s11.mm.analogInputArray01)\u0026#34; epicsEnvSet(MM_CH_1_IN,${ECMC_CONFIG_RETURN_VAL}) 11. retvalue = ec_get_mm_type( \u0026lt;srcId\u0026gt;, : Source memmap index ); Returns data type of memmap: 0 = Not defined (Use \u0026#34;Cfg.EcAddMemMapDT()\u0026#34; instead of \u0026#34;Cfg.EcAddMemMap()\u0026#34;) 1 = (Not valid for memmap) 2 = (Not valid for memmap) 3 = (Not valid for memmap) 4 = (Not valid for memmap) 5 = U8 6 = S8 7 = U16 8 = S16 9 = U32 10 = S32 11 = U64 12 = S64 13 = F32 14 = F64 Note: The mmId can be retrived by the bellow ecmc command (and feed into plc via macro): ecmcConfig \u0026#34;EcGetMemMapId(ec0.s11.mm.analogInputArray01)\u0026#34; epicsEnvSet(MM_CH_1_IN,${ECMC_CONFIG_RETURN_VAL}) 12. retvalue = ec_get_mm_data( \u0026lt;srcId\u0026gt;, : Source memmap index \u0026lt;index\u0026gt; : Index of data element ); Reads data element at index from memmap with srcId and returns value. Note: The mmId can be retrived by the bellow ecmc command (and feed into plc via macro): ecmcConfig \u0026#34;EcGetMemMapId(ec0.s11.mm.analogInputArray01)\u0026#34; epicsEnvSet(MM_CH_1_IN,${ECMC_CONFIG_RETURN_VAL}) 13. retvalue = ec_set_mm_data( \u0026lt;srcId\u0026gt;, : Source memmap index \u0026lt;index\u0026gt; : Index of data element \u0026lt;data\u0026gt; : Data to write ); Writes data element at index from memmap with srcId. Returns 0 for success or an error code. Note: The mmId can be retrived by the bellow ecmc command (and feed into plc via macro): ecmcConfig \u0026#34;EcGetMemMapId(ec0.s11.mm.analogInputArray01)\u0026#34; epicsEnvSet(MM_CH_1_IN,${ECMC_CONFIG_RETURN_VAL}) 14. retvalue = ec_get_mm_size( \u0026lt;srcId\u0026gt;, : Source memmap index ); Returns number of elements (of type \u0026#34;ec_get_mm_type()\u0026#34;)in memmap with srcId. If return value is less than zero it should be considered to be an error code. Note: The mmId can be retrived by the bellow ecmc command (and feed into plc via macro): ecmcConfig \u0026#34;EcGetMemMapId(ec0.s11.mm.analogInputArray01)\u0026#34; epicsEnvSet(MM_CH_1_IN,${ECMC_CONFIG_RETURN_VAL}) 15. retvalue = ec_mm_append_to_ds( \u0026lt;mmId\u0026gt;, : Source memmap index \u0026lt;dsId\u0026gt;); : Destination data storage index Returns Error code or zero if success Note: The mmId can be retrived by the bellow ecmc command (and feed into plc via macro): ecmcConfig \u0026#34;EcGetMemMapId(ec0.s11.mm.analogInputArray01)\u0026#34; epicsEnvSet(MM_CH_1_IN,${ECMC_CONFIG_RETURN_VAL}) 16. retvalue = ec_mm_append_to_ds_scale_offset( \u0026lt;mmId\u0026gt;, : Source memmap index \u0026lt;dsId\u0026gt; : Destination data storage index \u0026lt;scale\u0026gt; : Scale \u0026lt;offset\u0026gt;); : Offset Returns Error code or zero if success Note: The mmId can be retrived by the bellow ecmc command (and feed into plc via macro): ecmcConfig \u0026#34;EcGetMemMapId(ec0.s11.mm.analogInputArray01)\u0026#34; epicsEnvSet(MM_CH_1_IN,${ECMC_CONFIG_RETURN_VAL}) 17. retvalue = ec_mm_push_asyn( \u0026lt;mmId\u0026gt;) : Source memmap index. push memap data to epics (can be used if T_SMP_MS=-1 for the param) Note: The mmId can be retrived by the bellow ecmc command (and feed into plc via macro): ecmcConfig \u0026#34;EcGetMemMapId(ec0.s11.mm.analogInputArray01)\u0026#34; epicsEnvSet(MM_CH_1_IN,${ECMC_CONFIG_RETURN_VAL}) 18. retvalue = ec_get_time(); Returns current time in nano seconds (from 1 Jan 2000, same as EtherCAT DC:s). If return value is less than zero it should be considered to be an error code. 19. retvalue = ec_get_time_l32(); Returns lower 32 bits of current time in nano seconds (from 1 Jan 2000, same as EtherCAT DC:s). If return value is less than zero it should be considered to be an error code. 20. retvalue = ec_get_time_u32(); Returns upper 32 bits of current time in nano seconds (from 1 Jan 2000, same as EtherCAT DC:s). If return value is less than zero it should be considered to be an error code. 21. retvalue = ec_get_time_frm_src( \u0026lt;clock_src_id\u0026gt;); : System dependent clock id. Normally CLOCK_REALTIME=0, CLOCK_MONOTONIC=1. Returns current time in nano seconds for a certain clock source defined by clock_id. (from 1 Jan 2000, same as EtherCAT DC:s). If return value is equal or less than zero it should be considered to be an error. 22. retvalue = ec_get_time_offset_mono(): Returns current time offset in nano seconds if selected clock source is CLOC_MONOTONIC otherwise 0 monotonic. 23. retvalue = ec_get_time_local_hour( \u0026lt;ns_since_ec_epoch\u0026gt;); : Nano seconds since jan 1:st 2000. returns the hours part, 0..23, of the nano second counter (removes years, months , days), 24. retvalue = ec_get_time_local_min( \u0026lt;ns_since_ec_epoch\u0026gt;); : Nano seconds since jan 1:st 2000. returns the minutes part, 0..59, within the hour, 25. retvalue = ec_get_time_local_sec( \u0026lt;ns_since_ec_epoch\u0026gt;); : Nano seconds since jan 1:st 2000. returns the seocods part, 0..59, within the minute, 26. retvalue = ec_get_time_local_nsec( \u0026lt;ns_since_ec_epoch\u0026gt;); : Nano seconds since jan 1:st 2000. returns the nanoseocods part, 0..1E9-1, within the second, 27. retvalue = ec_get_dom_state( \u0026lt;domain_id\u0026gt;); : Id for domain returns 1 if domain communication is ok, 0 if not and -1 if error (domain id out of range). 28. retvalue=ec_get_err(): Returns error code from last lib call. 29. retvalue=ec_err_rst(): Resets error code for ec_lib. Master to Master communication (within same host) Support for communication between different ecmc ioc:s running on the same host. A shared memory buffer of 120 doubles can be accessed for read and write operations by alll ecmc ioc running on the same master.\n1. retvalue = m2m_write( \u0026lt;index\u0026gt;, : Mem buffer index (index must be 0..119) \u0026lt;value\u0026gt;): : value to write returns 0 if success or error code. Write a value to an index of a common memory buffer accessible by all masters running on same host 2. retvalue = m2m_read(\u0026lt;index\u0026gt;); : Mem buffer index (index must be 0..119) returns the value stored at index in the shared mem buffer. 3. retvalue = m2m_stat(); returns 1 if connection to shared memory is OK, else 0 or a negative value with an errro code. 4. m2m_err_rst(); reset any m2m error codes. 5. retvalue = m2m_err_rst(); returns current m2m error code. 6. retvalue = m2m_ioc_ec_ok(\u0026lt;master_index\u0026gt;); returns status ethercat status of another ecmc ioc (1==op, 0==not op, -1==error). 7. retvalue = m2m_ioc_run(\u0026lt;master_index\u0026gt;); checks of a certian master is running (negative master id is ioc:s without ec master). Motion 1. retvalue = mc_move_abs( \u0026lt;axIndex\u0026gt;, : Axis index \u0026lt;execute\u0026gt;, : Trigger \u0026lt;pos\u0026gt;, : Target position \u0026lt;vel\u0026gt;, : Target velocity \u0026lt;acc\u0026gt;, : Acceleration \u0026lt;dec\u0026gt; : Deceleration ): Absolute motion of axis. Motion is triggerd with a positive edge on \u0026lt;execute\u0026gt; input. returns 0 if success or error code. 2. retvalue = mc_move_rel( \u0026lt;axIndex\u0026gt;, : Axis index \u0026lt;execute\u0026gt;, : Trigger \u0026lt;pos\u0026gt;, : Target position \u0026lt;vel\u0026gt;, : Target velocity \u0026lt;acc\u0026gt;, : Acceleration \u0026lt;dec\u0026gt; : Deceleration ); Relative motion of axis \u0026lt;axIndex\u0026gt;. Motion is triggerd with a positive edge on \u0026lt;execute\u0026gt; input. returns 0 if success or error code. 3. retvalue = mc_move_ext_pos( \u0026lt;axIndex\u0026gt;, : Axis index \u0026lt;execute\u0026gt;, : Trigger \u0026lt;vel\u0026gt;, : Target velocity \u0026lt;acc\u0026gt;, : Acceleration \u0026lt;dec\u0026gt; : Deceleration ); Move to current external plc position. Functions intended use is to move to the start position for syncronized axes. This command is exactly the same as issueing \u0026#34;mc_move_pos()\u0026#34; with the target postion ax\u0026lt;id\u0026gt;.traj.extsetpos. Motion is triggerd with a positive edge on \u0026lt;execute\u0026gt; input. returns 0 if success or error code. 4. retvalue = mc_move_vel( \u0026lt;axIndex\u0026gt;, : Axis index \u0026lt;execute\u0026gt;, : Trigger \u0026lt;vel\u0026gt;, : Target velocity \u0026lt;acc\u0026gt;, : Acceleration \u0026lt;dec\u0026gt; : Deceleration ); Constant velocity motion of axis \u0026lt;axIndex\u0026gt;. Motion is triggerd with a positive edge on \u0026lt;execute\u0026gt; input. returns 0 if success or error code. 5. retvalue = mc_home( \u0026lt;axIndex\u0026gt;, : Axis index \u0026lt;execute\u0026gt;, : Trigger \u0026lt;seqId\u0026gt;, : Motion sequence \u0026lt;velTwoardsCam\u0026gt;, : Target Velocity twords cam \u0026lt;velOffCam\u0026gt; : Target velocity off cam ); Perform a homing sequence of axis \u0026lt;axIndex\u0026gt;. Motion is triggerd with a positive edge on \u0026lt;execute\u0026gt; input. returns 0 if success or error code. 6. retvalue = mc_home_pos( \u0026lt;axIndex\u0026gt;, : Axis index \u0026lt;execute\u0026gt;, : Trigger \u0026lt;seqId\u0026gt;, : Motion sequence \u0026lt;velTwoardsCam\u0026gt;, : Target Velocity twords cam \u0026lt;velOffCam\u0026gt; : Target velocity off cam \u0026lt;homePos\u0026gt; : Homing position ); Perform a homing sequence of axis \u0026lt;axIndex\u0026gt; Motion is triggerd with a positive edge on \u0026lt;execute\u0026gt; input. returns 0 if success or error code. 7. retvalue = mc_halt( \u0026lt;axIndex\u0026gt;, : Axis index \u0026lt;execute\u0026gt;, : Trigger ); Stop motion of axis \u0026lt;axIndex\u0026gt;. Command is triggerd with a positive edge on \u0026lt;execute\u0026gt; input. returns 0 if success or error code. 8. retvalue = mc_power( \u0026lt;axIndex\u0026gt;, : Axis index \u0026lt;enable\u0026gt;, : Enable power ); Enable power of axis \u0026lt;axIndex\u0026gt;. Motion is triggerd with a positive edge on \u0026lt;execute\u0026gt; input. returns 0 if success or error code. 9. retvalue = mc_get_busy( \u0026lt;axIndex\u0026gt;, : Axis index# ); Check if axis is busy. returns busy state of axis (1 if busy and 0 if not busy). 10. retvalue = mc_get_homed( \u0026lt;axIndex\u0026gt;, : Axis index# ); Check if axis is homed. returns state of homed flag of axis (1 if homed and 0 if not homed). 11. retvalue = mc_get_err(); Returns error code for last lib call. 12. retvalue = mc_reset(\u0026lt;axIndex\u0026gt;); Resets error of motion axis. 13. retvalue = mc_get_axis_err(\u0026lt;axIndex\u0026gt;); Returns motion axis error code. 14. retvalue = mc_set_enable_motion_funcs( \u0026lt;axIndex\u0026gt;, : Axis index \u0026lt;enablePos\u0026gt;, : Enable positioning \u0026lt;enableVelo\u0026gt;, : Enable const velo \u0026lt;enableHome\u0026gt;, : Enable const homing ); Enables/disables motion functionalities. Returns error code. 15. retvalue = mc_get_act_pos( \u0026lt;axIndex\u0026gt;, : Axis index \u0026lt;encIndex\u0026gt; : Encoder index (starts from 1) ); Returns encoder position for any of the configured encoders of an axis. 16. retvalue = mc_set_act_pos( \u0026lt;axIndex\u0026gt;, : Axis index \u0026lt;encIndex\u0026gt; : Encoder index (starts from 1) \u0026lt;position\u0026gt; : position to set ); NOTE: Preferably executed when axis is disabled. Returns 0 or error code. 17. retvalue = mc_get_enc_ready( \u0026lt;axIndex\u0026gt;, : Axis index \u0026lt;encIndex\u0026gt; : Encoder index (starts from 1) \u0026lt;position\u0026gt; : position to set ); Returns 1 if encoder is ready, otherwise 0 16. retvalue = mc_set_prim_enc( \u0026lt;axIndex\u0026gt;, : Axis index \u0026lt;encIndex\u0026gt; : Encoder index ); Sets primary and homing encoder index of the axis (the encoder used for control). The primary encoder can only be changed when the axis is not busy. Returns motion axis error code. 17. retvalue = mc_get_prim_enc( \u0026lt;axIndex\u0026gt;, : Axis index ); Returns primary encoder index of the axis (the encoder used for control). 18. mc_set_enc_homed( \u0026lt;axis_id\u0026gt;, : Axis index \u0026lt;encoder_id\u0026gt;, : Encoder index \u0026lt;homed\u0026gt;, : Homed (value to set) ); Sets homed bit of a certain encoder. Returns error code. 19. mc_get_enc_homed( \u0026lt;axis_id\u0026gt;, : Axis index \u0026lt;encoder_id\u0026gt;, : Encoder index ); Returns homed bit of a certain encoder or an error code (negative number) 20. mc_set_axis_error( \u0026lt;axis_id\u0026gt;, : Axis index \u0026lt;error_code\u0026gt; : Error code to set ); Sets an arbitrary error code to an axis object. 21. mc_set_slaved_axis_in_error( \u0026lt;axis_id\u0026gt;, : Axis index ); Set axis error that indicates that a slaved axis is in error state (ERROR_AXIS_SLAVED_AXIS_IN_ERROR 0x1432B). 22. mc_mr_set_sync( \u0026lt;axis_id\u0026gt;, : Axis index \u0026lt;sync\u0026gt;, : Sync yes or no (1 or 0) ); 1. Sync ecmc current setpoint with actual value (if not enabled and internal mode) 2. Execute a motor record SYNC Note: The command only triggers once per ecmc cycle (with the latest value written to sync) 23. mc_mr_set_stop( \u0026lt;axis_id\u0026gt;, : Axis index \u0026lt;stop\u0026gt;, : Stop yes or no (1 or 0) ); 1. Execute a motor record STOP Note: The command only triggers once per ecmc cycle (with the latest value written to stop) 24. mc_mr_set_cnen( \u0026lt;axis_id\u0026gt;, : Axis index \u0026lt;enable\u0026gt;, : Enable yes or no (1 or 0) ); 1. Enable/disable motor record via CNEN field Note: The command only triggers once per ecmc cycle (with the latest value written to enable) 25. error = mc_set_traj_vel( \u0026lt;axIndex\u0026gt;, : Axis index \u0026lt;vel\u0026gt; : Target velocity ); Set target velocity. 26. error = mc_set_traj_acc( \u0026lt;axIndex\u0026gt;, : Axis index \u0026lt;acc\u0026gt; : Max acceleration ); Set max acceleration. 27. error = mc_set_traj_dec( \u0026lt;axIndex\u0026gt;, : Axis index \u0026lt;dec\u0026gt; : Max deceleration ); Set max deceleration. note: mc_set_traj_dec() is only valid for trapez trajectory (trajectory.type=0). For s-curve trajectory mc_set_traj_acc() is used for both acceleration and deceleration. 28. error = mc_set_traj_jerk( \u0026lt;axIndex\u0026gt;, : Axis index \u0026lt;jerk\u0026gt; : Max jerk ); Set max jerk. note: mc_set_traj_jerk() is only valid for s-curve trajectory (ruckig, trajectory.type=1) Motion Group 1. mc_grp_get_enable( \u0026lt;grp_id\u0026gt;, : Group index ); Returns true if all axes in the group have the enable bit set, else false. Note: The axes do not need to be enabled if this function returns true, see mc_grp_get_enabled(). 2. mc_grp_get_any_enable( \u0026lt;grp_id\u0026gt;, : Group index ); Returns true if atleast one axis in the group has the enable bit set, else false. 3. mc_grp_get_enabled( \u0026lt;grp_id\u0026gt;, : Group index ); Returns true if all axes in the group are in enabled state, else false. 4. mc_grp_get_any_enabled( \u0026lt;grp_id\u0026gt;, : Group index ); Returns true if atleast one axis in the group is in enabled state, else false. 5. mc_grp_get_busy( \u0026lt;grp_id\u0026gt;, : Group index ); Returns true if all axes in the group are in busy state, else false. 6. mc_grp_get_any_busy( \u0026lt;grp_id\u0026gt;, : Group index ); Returns true if atleast one axis in the group is in busy state, else false. 7. mc_grp_get_any_error_id( \u0026lt;grp_id\u0026gt;, : Group index ); Returns error id if atleast one axis in the group is in error state, else zero. 8. mc_grp_set_enable( \u0026lt;grp_id\u0026gt;, : Group index \u0026lt;enable\u0026gt; : Enable state ); Sets enable for all axes in group. Returns 0 or error id. 9. mc_grp_set_traj_src( \u0026lt;grp_id\u0026gt;, : Group index \u0026lt;source\u0026gt; : Trajectory source (0 = internal, 1 = external/PLC ) ); Sets trajectory source for all axes in group. Returns 0 or error id. 10. mc_grp_set_enc_src( \u0026lt;grp_id\u0026gt;, : Group index \u0026lt;source\u0026gt; : Encoder source (0 = internal, 1 = external/PLC ) ); Sets encoder source for all axes in group. Returns 0 or error id. 11. mc_grp_reset_error( \u0026lt;grp_id\u0026gt;, : Group index ); Resets error of all axes in group. 12. mc_grp_set_error( \u0026lt;grp_id\u0026gt;, : Group index \u0026lt;error_id\u0026gt; : Error Id ); Set error id of all axes in group. 13. mc_grp_set_slaved_axis_in_error( \u0026lt;grp_id\u0026gt;, : Group index ); Set error id of all axes in group to ERROR_AXIS_SLAVED_AXIS_IN_ERROR (0x1432B) 14. mc_grp_halt( \u0026lt;grp_id\u0026gt;, : Group index ); Halt all axes in group (only works if traj source = internal/0) 15. mc_grp_axis_in_grp( \u0026lt;grp_id\u0026gt;, : Group index \u0026lt;axis_id\u0026gt;, : Axis index ); Returns true if axis is in group, else false. 16. mc_grp_size( \u0026lt;grp_id\u0026gt;, : Group index ); Returns the number of axes in group. 17. mc_grp_get_traj_src_ext( \u0026lt;grp_id\u0026gt;, : Group index ); Returns true if all axes in the group have trajectory source set to external. 18. mc_grp_get_any_traj_src_ext( \u0026lt;grp_id\u0026gt;, : Group index ); Returns true if atleast one axis in the group have trajectory source set to external. 19. mc_grp_set_allow_src_change_when_enabled( \u0026lt;grp_id\u0026gt;, : Group index \u0026lt;allow\u0026gt;, : Allow change of source ); Allow source change for trajectory and encoder when axis is enabled. 20. mc_grp_mr_set_sync( \u0026lt;grp_id\u0026gt;, : Group index \u0026lt;sync\u0026gt;, : Sync yes or no (1 or 0) ); 1. Sync ecmc current setpoint with actual value (if not enabled and internal mode) 2. Execute a motor record SYNC Note: The command only triggers motor record maximum once per ecmc cycle (with the latest value written to sync) 21. mc_grp_mr_set_stop( \u0026lt;grp_id\u0026gt;, : Group index \u0026lt;stop\u0026gt;, : Stop yes or no (1 or 0) ); 1. Execute a motor record STOP Note: The command only triggers motor record maximum once per ecmc cycle (with the latest value written to stop) 22. mc_grp_mr_set_cnen( \u0026lt;grp_id\u0026gt;, : Group index \u0026lt;enable\u0026gt;, : Enable yes or no (1 or 0) ); 1. Enable/disable motor record via CNEN field Note: The command only triggers motor record maximum once per ecmc cycle (with the latest value written to enable) 23. mc_grp_set_ignore_mr_status_check_at_disable( \u0026lt;grp_id\u0026gt;, : Group index \u0026lt;ignore\u0026gt;, : Ignore 1/0 ); Ignore check of status when mr is disabling (avoid enableAmplifier(xx) failed\u0026#34;) error 23. mc_grp_get_any_at_fwd_limit( \u0026lt;grp_id\u0026gt;, : Group index ); Returns true if any axis in the group is at a fwd limit switch, otherwise false. 24. mc_grp_get_any_at_bwd_limit( \u0026lt;grp_id\u0026gt;, : Group index ); Returns true if any axis in the group is at a bwd limit switch, otherwise false. 25. mc_grp_get_any_at_limit( \u0026lt;grp_id\u0026gt;, : Group index ); Returns true if any axis in the group is at a limit switch, otherwise false. 26. mc_grp_set_slaved_axis_ilocked( \u0026lt;grp_id\u0026gt;, : Group index ); Set slaved axis in interlock error. Data Storage 1. retvalue = ds_append_data( \u0026lt;dsIndex\u0026gt;, : Data storage index \u0026lt;data\u0026gt;, : Data ); Append data to data storage. returns 0 if success or error code. 2. retvalue = ds_clear_data( \u0026lt;dsIndex\u0026gt;, : Data storage index ); Clear data to data storage. returns 0 if success or error code. 3. retvalue = ds_get_data( \u0026lt;dsIndex\u0026gt;, : Data storage index \u0026lt;bufferIndex\u0026gt;, : Buffer index ); Returns data from buffer. 4. retvalue = ds_set_data( \u0026lt;dsIndex\u0026gt;, : Data storage index \u0026lt;bufferIndex\u0026gt;, : Buffer index ); Sets data in data storage buffer. returns 0 if success or error code. 5. retvalue = ds_get_buff_id( \u0026lt;dsIndex\u0026gt;, : Data storage index ); Returns current buffer index. 6. retvalue = ds_set_buff_id( \u0026lt;dsIndex\u0026gt;, : Data storage index \u0026lt;bufferIndex\u0026gt;, : Buffer index ); Sets current buffer index in data storage buffer. returns 0 if success or error code. 7. retvalue = ds_is_full( \u0026lt;dsIndex\u0026gt;, : Data storage index ); Returns true if buffer is full. 8. retvalue = ds_get_size( \u0026lt;dsIndex\u0026gt;, : Data storage index ); Returns buffer size of data storage. 9. retvalue = ds_get_err() Returns error code for last lib call. 10. retvalue = ds_push_asyn( \u0026lt;dsIndex\u0026gt;, : Data storage index ); Triggers push of all asyn parameters in ds to EPICS (including data). 11. retvalue = ds_get_avg( \u0026lt;dsIndex\u0026gt;, : Data storage index ); Returns average of the values in the data storage. 12. retvalue = ds_get_min( \u0026lt;dsIndex\u0026gt;, : Data storage index ); Returns minimum of the values in the data storage. 13. retvalue = ds_get_max( \u0026lt;dsIndex\u0026gt;, : Data storage index ); Returns maximum of the values in the data storage. 14. retvalue=ds_append_to_ds( \u0026lt;dsFromId\u0026gt;, : Source data storage index \u0026lt;dsFromDataId\u0026gt;, : Source data element index \u0026lt;elements\u0026gt;, : Number of elements to copy \u0026lt;dsToId\u0026gt; : Destination data storage index ); Appends data at the current position of the destination data storage (dsToId). The data source is defined by (dsFromId) and the selected tion (dsFromDataId) and element count (elements). 15. retvalue=ds_err_rst(): Resets error code for ds_lib. Lookup tables  1. value = lut_get_value( \u0026lt;lutObjIndex\u0026gt;, : Lookup table object index \u0026lt;index\u0026gt; : Index to which a value should be interpolated ); Returns an interpolated value from the lookup table object, with \u0026quot;lutObjIndex\u0026quot;, for the position \u0026quot;index\u0026quot;. Misc  1. value = epics_get_started() Returns if epics has started (passed iocInit()) 2. value = epics_get_state() Returns epics state (hook) "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/manual/motion_cfg/axisyaml/","title":"yaml configuration","tags":[],"description":"","content":"Since ecmccfg v7, the axis configuration is based on yaml files. Backwards compatibility for classic EPICS environment variable based configuration is assured for legacy systems.\n yaml is - like python - indentation sensitive!\n Indent with 2 spaces.\n introduction  python 3.x is required\n The config is processed by a python script with a jinja2 backend. The processor will complain if mandatory keys are missing. Likewise, missing optional keys are populated with default values.\nThe script invokes a python script which subsequently uses a jinja2 processor to render the respective templates. The script will create a python virtual environment and install the required libraries automatically.\n The configuration is separated into the following mandatory sections:\n axis epics drive (only mandatory for physical axis) encoder controller trajectory input  in addition the following optional sections are available.\n output homing softlimits monitoring  Each sections provides an example, the optional keys are commented.\n axis mandatory\n id: unique numeric identifier of the axis  optional\n type: type of the axis mode: operating mode of the drive parameters: additional parameters  axis: id: 1 # type: joint # axis types: # 1 (equiv: physical, joint, j, motor, real) # 2 (equiv: virtual, end_effector, end-effector, ee, e) # mode: CSV # supported modes: CSV and CSP # parameters: powerAutoOnOff=2;powerOnDelay=6.0;powerOffDelay=1.0; Auto enable/disable ecmc native (preferred way) Native ecmc auto-enable/disable is the preferred way and can be configured by:\naxis: autoEnable: # ecmc auto enable of axis (Please use this instead of motor record version..) enableTimeout: 5.0 # If defined, ecmc tries to auto-enable for a maximum enableTimeout seconds. disableTime: 5.0 # If defined, ecmc disables axis after idle (non busy) in disableTime seconds The motor record auto-enable/disable fucntionality will then automatically be disabled. However, do not configure both ecmc native and motor record auto enable/disable at the same time.\n motor record (do not use) Please use the ecmc-native auto-enable/disable described above.\n Auto enable disable is by default enabled in motor record. However, this solution is not optimal since motor record is just polling information from ecmc and all motor records block when one motor is waiting for enable. This is how the parameters timing paramters can be changed.\naxis: parameters: powerAutoOnOff=2;powerOnDelay=6.0;powerOffDelay=1.0;  The powerAutoOnOff is defining a mode and should always be set to 2.\n Note the mandatory \u0026ldquo;;\u0026rdquo; in the end of the parameters string. If not present, then teh last parameter will not be parsed.\n Tweak value ecmc and motor record tweak value can be defined in the axis.tweakDist:\naxis: tweakDist: 5.0 # Tweak distance epics Epics configuration.\nThe Epics motorRecord can now be disabled.\n mandatory\n name: name of the PV  optional\n precision: PREC field; default 3 unit: EGU field; optional default mm motorRecord  enable: set to false to disable motorRecord description: DESC field; default '' fieldInit: string with additional field initial values; default ''    epics: name: M1 # precision: 3 # unit: deg # motorRecord: # enable: false # fieldInit: \u0026#39;RRES=1.0,RTRY=2,RMOD=1,UEIP=0,RDBD=0.1,URIP=1,RDBL=$(IOC):$(ECMC_MOTOR_NAME)-PosActSim\u0026#39; # fieldInit: \u0026#39;NTM=1\u0026#39; # description: AM8111 CSV drive mandatory for physical axis\n numerator: scaling numerator denominator: scaling denominator type: type of drive: 0=stepper, 1=DS402, aka servo or complex stepper control: control word entry status: status word entry setpoint: setpoint entry, position or velocity, depending on mode  optional\n reduceTorque: control word bit to set for reduced torque mode brake  openDelay: number of cycles to wait after enable to disengage the brake closeAhead: number of cycles to wait after the brake was engaged   reset: control word bit to set in order to reset the drive warning: status word bit for drive warning error: list of status bits for drive errors  drive: numerator: 2880000 # Fastest speed in engineering units denominator: 2147483648 # I/O range for ECMC_EC_ALIAS_DRV_VELO_SET type: 1 # Stepper: 0, DS402: 1 (DS402 = servos and advanced stepper drives) control: ec0.s$(DRV_SLAVE).driveControl01 status: ec0.s$(DRV_SLAVE).driveStatus01 setpoint: ec0.s$(DRV_SLAVE).velocitySetpoint01 # reduceTorque: 2 # Reduce torque bit in drive control word # brake: # openDelay: 0 # Brake timing parameter in EtherCAT cycles # closeAhead: 0 # Brake timing parameter in EtherCAT cycles # reset: 1 # Reset bit in control word # warning: 2 # Warning bit of status word # error: # max 3 # - 3 # Error 0 bit of status word # - 7 # Error 1 bit of status word # - 14 # Error 2 bit of status word encoder mandatory\n numerator: scaling numerator, equivalent distance to the maximum drive frequency (default: 2000 Hz i.e. 2000 full steps), also effectively absolute maximum velocity denominator: scaling denominator type: type of encoder: 0=incremental, 1=absolute bits: raw data bit count absBits: Absolute bit count (for absolute encoders) always least significant part of \u0026lsquo;bits\u0026rsquo; absOffset: Encoder offset in engineering units (for absolute encoders) position: position entry  optional\n source: position source, 0=from EC entry ; 1=from PLC control: control word entry; mandatory when reset is set. status: status word entry; mandatory when error or warning are set reset: control word bit to set in order to reset the encoder warning: status word bit for encoder warning error: list of status bits for encoder errors velocityFilterSize: size of the velocity filter (cycles) positionFilterSize: size of the position filter (cycles) positionFilterEnable: position filter enable latch:  position: '' control: '' status: ''    encoder: numerator: 360 denominator: 1048576 type: 1 # Type: 0=Incremental, 1=Absolute bits: 32 # Total bit count of encoder raw data absBits: 25 # Absolute bit count (for absolute encoders) always least significant part of \u0026#39;bits\u0026#39; absOffset: 0 # Encoder offset in eng units (for absolute encoders) position: ec0.s$(DRV_SLAVE).positionActual01  # Ethercat entry for actual position input (encoder) # source: 0 # control: ec0.s$(ENC_SLAVE).encoderControl01 # mandatory only if \u0026#39;reset\u0026#39; is used # status: ec0.s$(DRV_SLAVE).encoderStatus01 # mandatory only if \u0026#39;warning\u0026#39; or \u0026#39;error\u0026#39; are used # reset: 1 # Reset (optional) # warning: 2 # Warning (optional) # error: # max 3 (optional) # - 5 # Error 0 # - 9 # Error 1 # - 11 # Error 2 # velocityFilterSize: 100 # positionFilterSize: 1 # positionFilterEnable: false # latch: # position: \u0026#39;\u0026#39; # control: \u0026#39;\u0026#39; # status: \u0026#39;\u0026#39; optional\n velocityFilterSize: Add filtering if the encoder is too coarse to reliably determine velocity each PLC cycle  controller PID controller parameters\nmandatory\n Kp: proportional  optional\n Ki: integral; default 0 Kd: differential; default 0 Kff: feed forward; default 1  controller: Kp: 90 # Ki: 0.1 # Kd: 0 # Kff: 1 trajectory settings for the trajectory planning.\nAll accelerations are now defined in EGU s^{-2}\n mandatory\n axis  velocity: velocity setpoint the axis will be initialized to (in EGU/sec) acceleration: acceleration setpoint for initialization (in EGU/sec2)    optional\n source: source of position setpoint, 0=trajectory generator of axis ; 1=from PLC type: type of velocity profile: 0=trapezoidal ; 1=s-curve axis  deceleration: deceleration setpoint for initialization (in EGU/sec2) emergencyDeceleration: deceleration setpoint for emergencies. Defaults to acceleration setpoint if not specified. jerk: jerk for s-curved profiles (in EGU/sec3)   jog  velocity: velocity setpoint the axis will be initialized to for jogging acceleration: acceleration setpoint for initialization, for jogging   modulo  range: modulo range type: modulo type    trajectory: # source: 0 # type: 0 axis: velocity: 180 acceleration: 180 # deceleration: 360 # jerk: 1.0 # emergencyDeceleration: 0.05 # jog: # velocity: 90 # acceleration: 0.1 # modulo: # range: 0 # type: 0 input Links to the binary input sensors for limit switches, home sensor and external interlock. All four inputs must be provided. If an input is not used, set it to the ONE.0 entry of a slave. See the example for details.\nmandatory\n limit  forward: limit switch sensor input in the forward direction. backward: limit switch sensor input in the backward direction.   home: binary input for the home sensor extinterlock: binary input for external interlock.  input: limit: forward: ec0.s$(DRV_SLAVE).ONE.0  # Ethercat entry for low limit switch input backward: ec0.s$(DRV_SLAVE).ONE.0  # Ethercat entry for high limit switch input home: ec0.s$(DRV_SLAVE).ONE.0  # Ethercat entry for home switch input interlock: ec0.s$(DRV_SLAVE).ONE.0  # Ethercat entry for interlock switch input output Two outputs can be utilizes with ECMC.\nThe brake output was moved to the drive key, as it is directly coupled to the drive state.\n optional\n health: sum parameter for axis health  # output: # health: \u0026#39;\u0026#39; # Ethercat entry for health output homing This section is should be obsolete at PSI, as for all new installation using EtherCAT, absolute encoders are mandatory. In case a legacy system or temporary installation requires a incremental encoder, or even open loop operation, several procedures for referencing are available.\noptional\n type: referencing procedure position: position of the reference mark in engineering units postMoveEnable: post homing move postMovePosition: post homing move target switchPolarity: home switch polarity, for NO switches latchCount: latch counter velocity: velocities  to: to the cam from: off the cam   acceleration: acceleration time in s deceleration: deceleration time in s  # homing: # type: 3 # position: 0 # postMoveEnable: false # postMovePosition: 0 # switchPolarity: 0 ## 0: NC, 1: NO # latchCount: 0 # velocity: # to: 2.72 # # from: 3.14 # # acceleration: 2 # # deceleration: 5 softlimits Soft limits to propagate to the motorRecord.\noptional\n enable: global enable of soft limits. forwardEnable: forward on/off. forward: soft limit in the forward direction. backwardEnable: backward on/off. backward: soft limit in the backward direction.  # softlimits: # enable: true # forwardEnable: true # optional switch for forward direction # forward: 300.0 # backwardEnable: true # optional switch for backward direction # backward: 25.0 monitoring Three entities can be monitored, (1) lag, aka following error, (2) target, aka in position, (3) velocity.\nIt is highly advisable to always use the lag and target monitoring fo closed-loop axis. Failure to do so, will most likely results in unexpected behaviour.\n The monitoring key, must be included in the config, despite all features being optional. It\u0026rsquo;s a means to let the integrator think twice to skip it all together.\n optional\n lag  enable: enable lag monitoring tolerance: tolerance in engineering units time: time for the condition to be true in ms   target  enable: enable target monitoring tolerance: tolerance in engineering units time: time for the condition to be true in ms   velocity  enable: enable velocity monitoring max: upper limit for velocity time  trajectory: time for the condition to be in violation in ms drive: time for the condition to be in violation in ms      monitoring: # lag: # enable: false # tolerance: 5 # time: 100 # target: # enable: true # tolerance: 0.125 # time: 100 # velocity: # enable: false # max: 100 # time: # trajectory: 100 # drive: 200 All yaml settings axis: id: 1 # Axis id type: joint # this is for future selection of axis type mode: CSV # supported mode, CSV and CSP, defaults CSV parameters: 'axisPar' # additional parameters # Additional params to motor record driver # \u0026quot;powerAutoOnOff=\u0026lt;value\u0026gt;;\u0026quot; //2: What you want, 1:do not use, 0 to disable # \u0026quot;powerOffDelay=\u0026lt;value\u0026gt;:\u0026quot; # \u0026quot;powerOnDelay=\u0026lt;value\u0026gt;;\u0026quot; healthOutput: ec0... # Ethercat entry for health output feedSwitchesOutput: ec0... # Ethercat entry for fed switches feedSwitchesValue: 1 # Value to write to axis.feedSwitchesOutput. Defaults to 1 group: testGroup # Add axis to group (group will be created if not exists), # group id will be stored in GRP\u0026lt;axis.group\u0026gt;_ID for later use. autoMode: # Switch drive modes automaticaly for normal motion and homing (smaract for instance) modeSet: ec0.. # Ethercat entry drive mode write (set CSV,CSP,homing) modeAct: ec0.. # Ethercat entry drive mode reading (set CSV,CSP,homing) modeCmdMotion: 9 # Drive mode value for normal motion (written to axis.drvMode.modeSet when normal motion) modeCmdHome: 10 # Drive mode value for when homing (written to axis.drvMode.modeSet when homing) features: blockCom: false # Block communication to axis allowSrcChangeWhenEnabled: false # Allow traj/enc source change when axis is enabled allowedFunctions: homing: true # Allow homing constantVelocity: true # Allow constant velocity positioning: true # Allow positioning autoEnable: # ecmc auto enable of axis (Please use this instead of motor record version..) enableTimeout: 5.0 # If defined, ecmc tries to auto-enable for a maximum enableTimeout seconds. disableTimeout: 5.0 # If defined, ecmc disables axis after idle (non busy) in disableTime seconds atStartup: True # Auto enable axis at ioc start, default False tweakDist: 2.0 # Tweak value (both ecmc interface and motor record tweak value) epics: name: M1 # Axis name precision: 3 # Decimal count description: very important motor axis # Axis description unit: mm # Unit motorRecord: enable: true description: This is MR fieldInit: 'RRES=1.0,RTRY=2,RMOD=1,UEIP=0,RDBD=0.1,URIP=1,RDBL=$(IOC):$(ECMC_MOTOR_NAME)-PosActSim' # Extra config for Motor record syncSoftLimits: false # Optional: Sync softlimits between motor and ecmc (default false) drive: numerator: 360 # Fastest speed in engineering units denominator: 4096 # I/O range for ECMC_EC_ALIAS_DRV_VELO_SET type: 0 # Stepper: 0. DS402: 1 (DS402 = servos and advanced stepper drives) control: ec0.s$(DRV_SLAVE).driveControl01 # Control word ethercat entry enable: 0 # Enable bit index in control word (not used if DS402) enabled: 1 # Enabled bit index in status word (not used if DS402) status: ec0.s$(DRV_SLAVE).driveStatus01 # Status word ethercat entry setpoint: ec0.s$(DRV_SLAVE).velocitySetpoint01 # Velocity setpoint if CSV. Position setpoint if CSP reduceTorque: 2 # Reduce torque bit in drive control word reduceTorqueEnable: True # Enable reduce torque functionality useAsCSPDrvEnc: True # Use this encoder as CSP drive encoder (ecmc controller enabled in CSP) brake: enable: false output: ec0... # Ethercat link to brake output openDelay: 0 # Brake timing parameter in cycles (default 1kHz) closeAhead: 0 # Brake timing parameter in cycles (default 1kHz) reset: 1 # Reset (if no drive reset bit then leave empty) warning: 2 # Warning (if no drive warning bit then leave empty) error: # max 3 - 3 # Error 0 (if no drive error bit then leave empty) - 7 # Error 1 (if no drive error bit then leave empty) - 14 # Error 2 (if no drive error bit then leave empty) encoder: numerator: 360 # Scaling numerator example 360 deg/rev denominator: 4096 # Scaling denominator example 4096 ticks per 360 degree type: 0 # Type: 0=Incremental, 1=Absolute bits: 16 # Total bit count of encoder raw data absBits: 0 # Absolute bit count (for absolute encoders) always least significant part of 'bits' absOffset: 0 # Encoder offset in eng units (for absolute encoders) mask: '0xFFF00' # Mask applied to raw encoder value position: ec0.s$(ENC_SLAVE).positionActual01 # Ethercat entry for actual position input (encoder) control: ec0.s$(ENC_SLAVE).encoderControl01 # mandatory only if 'reset' is used status: ec0.s$(DRV_SLAVE).encoderStatus01 # mandatory only if 'warning' or 'error' are used ready: 10 # Bit in encoder status word for encoder ready source: 0 # 0 = Encoder value from etehrcat hardware, 1 = Encoder value from PLC reset: 1 # Reset (optional) warning: 2 # Warning (optional) error: # max 3 (optional) - 5 # Error 0 - 9 # Error 1 - 11 # Error 2 filter: velocity: size: 100 # Filter size for velocity enable: true # enable velocity filter position: size: 100 # Filter size for encoder value enable: true # enable encoder value filter latch: position: '' # Link to latched value. Used for some homing seqs control: 0 # Bit in encoder control word to arm latch. Used for some homing seqs status: 0 # Bit in encoder status word for latch triggered status. Used for some homing seqs armCmd: # Value in dec to arm latch/touch probe to write to encoder.control armBits: # Bit size of encoder.latch.armCmd primary: True # Use this encoder as primary (for control) homing: type: 3 # Homing sequence type position: -30 # Position to reference encoder to velocity: to: 10 # Velocity to cam/sensor (used for some homing seqs) from: 5 # Velocity from cam/sensor (used for some homing seqs) acceleration: 20 # Acceleration during homing deceleration: 100 # Deceleration during homing refToEncIDAtStartup: 1 # At startup then set the start value of this encoder to actpos of this encoder id refAtHome: 1 # If homing is executed then set position of this encoder tolToPrim: 0 # If set then this is the max allowed tolerance between prim encoder and this encoder postMoveEnable: yes # Enable move after successfull homing postMovePosition: 10 # Position to move to after successfull homing trigg: ec0.. # Ethercat entry for triggering drive internal homing seq (seq id 26) ready: ec0.. # Ethercat entry for readinf drive internal homing seq ready (seq id 26) latchCount: 1 # latch number to ref on (1=ref on first latch) delayComp: # Delay compensation for time between application of setpoint to reading of encoder (normally atleast 1 cycle) time: 1.5 # Delay time between set and act [cycles] # enable: true # enable (defaults to 1 if not set) lookuptable: filename: ./cfg/enc.corr # Load correction lockuptable file (default enabled if loaded) # enable: 1 # Enable correction table # mask: '0x3FF' # Encoder raw mask to apply correction (example single turn bits or period bits of EL5021) controller: Kp: 15 # Kp proportional gain Ki: 0.02 # Ki integral gain Kd: 0 # Kd derivative gain Kff: 1 # Feed forward gain deadband: tol: 0.01 # Stop control if within this distance from target for the below time time: 100 limits: minOutput: -100 # Minimum controller output maxOutput: 100 # Maximum controller output minIntegral: -100 # Minimum integral output maxIntegral: 100 # Maximum integral output inner: Kp: 0.1 # Kp for when close to target Ki: 0.1 # Ki for when close to target Kd: 0.1 # Kd for when close to target tol: 0.1 # Distance from target for when inner PID params will be used, defaults to atTarget tol trajectory: type: 1 # Default 0 = trapetz, 1 = S-curve (ruckig) source: 0 # 0 = take trajectory setpoint from axis traj object, 1 = trajectory setpoint from plc axis: velocity: 10 # Default velo for axis acceleration: 0.1 # Default acc for axis deceleration: 0.1 # Default dec for axis emergencyDeceleration: 0.05 # Deceleration when axis in error state jerk: 10 # Default jerk for axis jog: velocity: 5 # Default velo fro JOG (motor record) modulo: range: 360 # Modulo range 0..360 type: 0 # Modulo type # Limits can be overridden with plc-code by setting input.limit.forward or input.limit.backward to 'plcOverride', then 'ax\u0026lt;id\u0026gt;.mon.lowlim' and or 'ax\u0026lt;id\u0026gt;.mon.highlim' needs to be written to in plc code (1 means linit OK). input: limit: forward: ec0.s$(ENC_SLAVE).ONE.0 # Ethercat entry for low limit switch input, forwardPolarity: 0 # Polarity of forward limit switch backward: ec0.s1.BI_2.0 # Ethercat entry for high limit switch input backwardPolarity: 0 # Polarity of forward limit switch home: 'ec0.s$(MCS2_SLAVE_NUM).ONE.0' # Ethercat entry for home switch homePolarity: 0 # Polarity of home switch interlock: 'ec0.s$(ENC_SLAVE).ONE.0' # Ethercat entry for interlock switch input interlockPolarity: 0 # Polarity of interlock switch analog: interlock: 'ec0.s$(ENC_SLAVE).ONE' # Ethercat entry for analog interlock interlockPolarity: 1 # 0: High value is bad, 1 = Low value is bad rawLimit: 2000 # Analog raw limit enable: true # Enable analog interlock default true if analog.interlock is set softlimits: enable: false # Enable soft limits forward: 100 # Soft limit position fwd forwardEnable: false # Soft limit position fwd enable backward: -100 # Soft limit position bwd backwardEnable: false # Soft limit position bwd enable monitoring: lag: enable: false # Enable position lag monitoring (following error) tolerance: 0.5 # Allowed tolerance time: 10 # Allowed time outside tolerance target: enable: true # Enable at target monitoring (needs to be enabled if using motor record) tolerance: 0.5 # Allowed tolerance time: 10 # Filter time inside tolerance to be at target velocity: enable: false # Enable velocity monitoring max: 100 # Allowed max velocity time: trajectory: 100 # Time allowed outside max velo before system init halt drive: 200 # Time allowed outside max velo before system disables drive velocityDifference: enable: true # Enable velocity diff monitoring (velo set vs velo act) max: 100 # Allowed max difference time: trajectory: 100 # Time allowed outside max diff velo before system init halt drive: 200 # Time allowed outside max diff velo before system disables drive stall: enable: True # Enable stall monitoring. Attarget must be enabled for this functionallity time: timeout: 10000 # If not attarget after \u0026quot;timeout\u0026quot; cycles after trajectory generator is ready then drive will disable factor: 5.0 # Measures duration of last motion command (busy high edge to busy low edge). The new timeout will be defined as this duration multiplied by this factor. The timeout finaly used for stall detection will be the longest (of time.timeout and calculated from time.factor). plc: enable: true # Enable axis plc externalCommands: true # Allow axis to inputs from PLC file: myplcfile.plc # File with plc code code: # Sync code (appended after code in plc.file) - if(ax2.traj.source){ax2.drv.enable:=(ax10.drv.enable or ax11.drv.enable)}; # Enable axis if one of master axes is enabled - ax2.traj.setpos:=ax10.traj.setpos-ax11.traj.setpos/2; # calculate set pos for physical axis velocity_filter: # Filter used to smother velocity feedforward encoder: # Filter plc enc velo enable: false # Filter enable size: 100 # Filter size trajectory: # Filter plc traj velo enable: false # Filter enable size: 100 # Filter size # filter: # Use \u0026quot;velocity_filter\u0026quot; instead since this naming is missleading and should be phased out # velocity: # Filter plc enc velo # enable: false # size: 100 # trajectory: # Filter plc traj velo # enable: false # size: 100 "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/manual/general_cfg/data_storage/","title":"data storage buffer","tags":[],"description":"","content":"data storage examples This dir contains two examples: here.\n Continuously add value to data storage. Push to epics by hw trigger. Continuously add value to data storage. Push to epics by epics pv trigger. Data buffered data can be accessed by the \u0026ldquo;IOC_TEST:ds0-Data-Act\u0026rdquo; waveform pv (NELM 10000)  Custom scale and offset can be applied to the stored values by MACROS (to the plc) in the startup file.\n1 push to epics by hw trigger In this example the data stored in dataStorage 0 is pushed to epics at a falling edge of the axis 1 high limit.\nExample 1 is started with the following startup file: \u0026ldquo;add_data_to_buffer_trigg_push_hw.script\u0026rdquo;\niocsh.bash add_data_to_buffer_trigg_push_hw.script Trigger writes to epics by toggle of axis 1 high limit switch.\nPLC-code:\n################################################################################## # PLC to add encoder data to dataStorage and push data on falling edge of higlimit # # MACROS: # DS_ID = ID of ds to use as a filter id # PLC_ID = ID of this PLC # ENC_S_ID = Slave id of encoder terminal # DBG = Set to empty string to get printouts, set to \u0026quot;#\u0026quot; to avoid printouts # SCALE = Encoder scale value, defaults to 1 # OFFSET = Encoder offset value, defaults to 0 # # Append data to storage ds_append_data(${DS_ID},ec0.s${ENC_S_ID}.positionActual01*${SCALE=1}+${OFFSET=0}); # Trigger push of data on falling edge of limit switch if(static.highlimOld and not(ax1.mon.highlim)) { ${DBG=#}println('Pushing data to EPICS....'); ds_push_asyn(${DS_ID}); }; static.highlimOld:=ax1.mon.highlim; 2 push to epics by epics pv trigger In this example the data stored in dataStorage 0 is pushed to epics at a rising edge of the \u0026ldquo;IOC_TEST:Set-PushDataTrigger-RB\u0026rdquo; pv.\nExample 2 is started with the following startup file: \u0026ldquo;add_data_to_buffer_trigg_push_hw.script\u0026rdquo;\niocsh.bash add_data_to_buffer_trigg_push_epics.script Trigger writes to epics by:\nraspberrypi-16970 \u0026gt; dbpf IOC_TEST:Set-PushDataTrigger-RB 1 DBF_STRING: \u0026quot;One\u0026quot; raspberrypi-16970 \u0026gt; Pushing data to EPICS.... dbpf IOC_TEST:Set-PushDataTrigger-RB 0 DBF_STRING: \u0026quot;Zero\u0026quot; raspberrypi-16970 \u0026gt; dbpf IOC_TEST:Set-PushDataTrigger-RB 1 DBF_STRING: \u0026quot;One\u0026quot; raspberrypi-16970 \u0026gt; Pushing data to EPICS.... PLC-code:\n################################################################################## # PLC to add encoder data to dataStorage and push data on trigger from epics PV # # MACROS: # DS_ID = ID of ds to use as a filter id # PLC_ID = ID of this PLC # ENC_S_ID = Slave id of analog input terminal # DBG = Set to empty string to get printouts, set to \u0026quot;#\u0026quot; to avoid printouts # SCALE = Encoder scale value, defaults to 1 # OFFSET = Encoder offset value, defaults to 0 # # Append data to storage ds_append_data(${DS_ID},ec0.s${ENC_S_ID}.positionActual01*${SCALE=1}+${OFFSET=0}); # Trigger push of data on rising edge of trigger if(static.trigg and not(static.triggOld)) { ${DBG=#}println('Pushing data to EPICS....'); ds_push_asyn(${DS_ID}); }; static.triggOld:=static.trigg; "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/manual/knowledgebase/hardware/elxxxx/","title":"ELxxxx","tags":[],"description":"","content":"Power bus - 5V or 24V terminals 24V is the most common signal level for the terminals, however, some also support other voltage levels, for instance 5V, or 12V or\u0026hellip;. In that case, normally the terminal needs to be powered with the same voltage. For 5V terminals, normally a EL9505 is added before the 5v terminal in the ethercat chain supplying the power bus with 5V.\nExample of slaves needing 5V power supply:\n EL1124 El1252-0050 \u0026hellip;  If a 5V terminal is supplied with 24V it will most likely break. Make sure the terminals has the correct power supply before powering the system.\n The voltage level of the power bus after (downstream) of a 5V terminal is normally also 5V, if another voltage is needed then another system terminal is needed to set a new voltage level of the power bus\n "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/manual/knowledgebase/tuning/","title":"tuning","tags":[],"description":"","content":"Tuning There are normally several control loops in an ecmc motion system:\n Position loop (centralized in ecmc if CSV) Velocity loop (in drive) Current loop (in drive)  Position loop The position loop control parameters can be accessed and tuned by PVs. Normally, a pure P controller is enough (ki and kp set to 0) but sometimes the I and D part can be needed for instance if the drive is running in CSP mode with ecmc position loop enabled (ecmc mode CSP_PC).\nBacklash\nTuning systems with backlash can be difficult. Sometimes a small D-part helps to reduce spikes in the centralized ecmc position loop controller output.\nVelocity and Current loop These control loops need to be tuned in the drive.\nFor EL70x1, see EL70x1 Tuning For other drives, consult the dedicated manual.\nEL7062 EL7062 have an autotune feature that works well. For more info see knowledge-base/hardware/el7062.\n"},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/manual/knowledgebase/hardware/el1xxx/","title":"EL1xxx","tags":[],"description":"","content":"EL1252, EL1252-0050 EL1252-xxxx is a 2 ch digital input terminal with timestamps (low to high, high to low):\n EL1252: 24V signals EL1252-0050: 5V signals  Both terminals have the product id and process data and can therefore be configured as EL1252:\n# One channel: ${SCRIPTEXEC} ${ecmccfg_DIR}addSlave.cmd, \u0026quot;SLAVE_ID=16, HW_DESC=EL1252\u0026quot; These terminals are very powerful since they can latch the time of the positive edge and/or negative edge of the input signal (independent of the ethercat bus rate). These timestamps can then be used to correlated other data, like encoders or analog inputs with timestamps.\nIMPORTANT Sine the EL1252-0050 is a 5V terminal, it needs to be powered with 5V if the terminal is powered with 24V, the terminal will burn. The simplest way to achieve a correct power supply is by adding an EL9505 (or similar) before the EL1252-0050. See above for more information 5v-and-24v-terminals\nMake sure the EL1252-0050 has a 5V power supply by an EL9505 (or similar), before powering the system. If the terminal is powered with the normal 24V it will most likely break\n A 5v signal will not be detected with the 24V version (EL1252), the terminal will however not be damaged. Further more, it\u0026rsquo;s not a good idea to to power the 24V version with 5V (EL9505, or similar)\n "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/manual/plc_cfg/function_libs/","title":"function libs","tags":[],"description":"","content":"function libs Function libraries can be loaded into ecmc PLCs by loadPLCLib.cmd. The command takes these parameters:\n FILE: definition file, i.e. ./plc/homeSlit.plc PLC_ID: (optional) PLC number, default last loaded PLC PLC_MACROS: (optional) Substitution macros for PLC code. The macros \u0026ldquo;SELF_ID\u0026rdquo;,\u0026ldquo;SELF\u0026rdquo;,M_ID, and M are reserved:  \u0026ldquo;SELF_ID\u0026rdquo; = PLC Id of this plc \u0026ldquo;SELF\u0026rdquo; = \u0026ldquo;plc${SELF_ID}\u0026rdquo; \u0026ldquo;M_ID\u0026rdquo; = EtherCAT master ID \u0026ldquo;M\u0026rdquo; = \u0026ldquo;ec${M_ID}\u0026rdquo;   INC: (optional) List of directories for include files to pass to MSI (if several paths then divide with \u0026lsquo;:'). TMP_PATH: (optional) directory to dump the temporary plc file after macro substitution PRINT_PLC_FILE: (optional) 1/0, printout msi parsed plc file (default enable(1)).  Example:\n${SCRIPTEXEC} ${ECMC_CONFIG_ROOT}loadPLCLib.cmd, \u0026#34;FILE=./plc/test.plc_lib, PLC_MACROS=\u0026#39;OFFSET=3\u0026#39;\u0026#34; The functions must be defined according to this template (max 5 parameters):\nfunction \u0026lt;name\u0026gt;(\u0026lt;param1\u0026gt;,...,\u0026lt;param5\u0026gt;) { \u0026lt;code body\u0026gt;; } also without param is allowed:\nfunction \u0026lt;name\u0026gt;() { \u0026lt;code body\u0026gt;; }  Several functions can be defined in the same file. For syntax of the \u0026ldquo;code body\u0026rdquo;, check plc syntax and the exprtk website. The parameters as well as the return value must be scalars, however, local vectors can be defined and used in calculations (initiations of vector can be done with MACROS, constants or parameters). \u0026ldquo;#\u0026rdquo; as a first char in a line is considered a comment (the line will be removed before compile). The lib file will be parsed through MSI allowing macro expansion, \u0026ldquo;include\u0026rdquo; and \u0026ldquo;substitute\u0026rdquo; commands. For more info check best practice and msi documentation/help.  can be used in functions  The parameters Other functions (also recursive) The normal ecmc function libs:   motion: mc_* ethercat: ec_* data storages: ds_*, master 2 master: m2m_*  the exprtk functions libs:   println print open close write read\u0026quot;, getline eof  vectors in the calculations (but NOT as parameter or return value).  can NOT be used in functions \u0026ldquo;ecmc variables\u0026rdquo; can NOT be used/accessed in functions:\n EtherCAT I/0 direct access ec.s.* Data storage variables: ds.* Motion variables: ax.* Static variables: static.* Global variables: global.* Vectors as parameter or return value (only first value will be passed).  example function lib file # Nothing fancy function add(a,b,c,d,e) { println('This is add: ', a+b+c+d+e) return[a+b+c+d+e+${OFFSET=0}]; }; function prod(a,b,c,d,e) { println('This is prod, add2 : ', add(a,b,c,d,e)); println('This is prod, prod: ', a*b*c*d*e); return [a * b * c * d * e + ${OFFSET=0}]; }; # function with vector calcs (inside) function testLocalArray(a) { var test[5]:={a,a,a,a,a}; println('This is testLocalArray: ',test); return [dot(test,test)]; }; # function without arg function one() { println('This is one: ',1); return [1+${OFFSET=0}]; } # function with ecmc function inside function testm2m() { m2m_write(0,m2m_read(0)+${OFFSET=0}); println('This is testmt2: elem 0: ',m2m_read(0)); } debugging Unfortunately debugging of function libs is not as easy as normal PLC:s since exprtk returns less information at compile failure.\nIn order to troubleshoot, load the code as a normal PLC instead. This way you will get more diagnostics. Also remember, ecmc variables cannot be accessed in plc libs.\n "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/manual/knowledgebase/host/","title":"host / ecmc server","tags":[],"description":"","content":"Topics  Prefered NICs latency issues / lost frames EtherCAT rate (EC_RATE) Debian 12  Prefered NICs igb driver (ec_igb):\n Intel Corporation I210 Gigabit Network Connection (rev 03) Intel Corporation I350 Gigabit Network Connection (rev 01)  latency issues / lost frames High latency, more than 30% of the ethercat cycle time, can result in lost ethercat frames, which means data are lost. High latency of the ecmc_rt thread can be related to:\n The generic device driver is used High load on system \u0026hellip;  generic device driver is used Check which driver is in use by running (on the ecmc server):\nlsmod | grep ec_ If the ec_master is using the ec_generic driver then a switch to igb driver is recommended.\nThe file /ioc/hosts/\u0026lt;hostname\u0026gt;/cfg/ETHERCATDRVR is listing the available drivers.\nThe recommended contents of the ETHERCATDRVR file is:\nDEVICE_MODULES=\u0026quot;igb generic\u0026quot; In this case, the system will first try to use igb driver, if not possible it will fallback to the generic driver. After editing the file, the host needs to be rebooted in order for the changes to take effect.\nhigh load on system ** Reduce sample rate** Reducing the ethercat cycle time is often very efficient when it comes to reduce latency. Do not run the ecmc systems faster than needed. The default ecmc sample rate is 1Khz, which in many cases is not needed.\nThe sample rate is defined when require ecmccfg (example set to 500Hz, instead of 1kHz):\nrequire ecmccfg \u0026quot;EC_RATE=500\u0026quot;  There are some restrictions on the sample rate. Normally, a rate in the range 100Hz-1Khz is a good choice. For other rates, please check the documentation of slaves in use. See heading \u0026ldquo;EtherCAT rate\u0026rdquo; below for more information.\n ** Affinity** Setting the affinity of the ecmc realtime thread can often improve the performance. First check how many cores the controller has. At PSI, core 0 is always isolated, do not move any threads to core 0.\n In order to pin the ecmc thread to a single core, add the following line to the startup script (after setAppMode.cmd):\n#- go active (create ecmc_rt) ${SCRIPTEXEC} ${ecmccfg_DIR}setAppMode.cmd #- Set affinity of ecmc_rt (core 5) epicsThreadSetAffinity ecmc_rt 5 If more than one ecmc ioc is running on the server, then make sure the ecmc_rt threads run on different cores.\nFurther tuning might include moving other cpu intensive threads to dedicated cores, for instance the epics thread cbLow:\nafterInit \u0026quot;epicsThreadSetAffinity cbLow 6\u0026quot;  cbLow is created at iocInit, therefore the \u0026ldquo;epicsThreadSetAffinity\u0026rdquo; must be executed with the \u0026ldquo;afterInit\u0026rdquo; command.\n The affinity can also be set with the tools accessible in the EPICS module MCoreUtils.\n EtherCAT rate (EC_RATE) The default EtherCAT frame rate in ecmc is set to 1kHz. For most applications this is however not needed and can therefore be reduced. A reduced EtherCAT rate reduces the load on the controller. In general, a good value for the frame rate is in the range 100Hz to 1kHz. For motion systems, a frame rate of 100Hz..500Hz is normally enough. Rates outside the 100Hz..1kHz range is normally not a good idea, and some slaves might not support it. However, in special cases both lower and higher rates might be possible and required.\nExample: Set rate to 500Hz\nrequire ecmccfg \u0026quot;EC_RATE=500\u0026quot; ... For more information see the chapter describing startup.cmd.\nAs a comparison, TwinCAT default EtherCAT rates are:\n 100Hz for PLC 500Hz for motion  Lower rates Issues that could occur in rates below 100Hz:\n triggering of slave watchdogs issues with dc clock syncs (DC capable slaves normally performs best with at a rate of at least 500Hz) some slaves might not support it  Higher rates Issues that could occur in rates over 1Kz:\n missed frames issues with dc clock syncs some slaves might not support it.  NOTE: Some slave might support a high rate but could have built in signal filters of several ms which then makes sampling at higher freqs unnecessary/not needed.\nIn order to successfully run an ecmc ethercat system at higher rates some tuning might be needed:\n minimize slave count (and ensure that the slaves support it) minimize amount of processing (PLC, motion) use a performant host/controller use native ethercat driver (igb, not generic) only transfer the needed PVs to epics. affinity: Use a dedicated core for the ecmc_rt thread and move other high prio threads to other cores. see \u0026ldquo;high load on system \u0026quot; above. consider use of more than one domain  (PSI specific) Debian 12 For debian 12 a different phyton venv needs to be copied to the tmp dir at startup. The venv can be found here: /ioc/NeedfulThings/ecmc_python_venv/.venv_deb12/\niocsh startup ecmc needs to be started with root priviledges (or with a user in realtime group), without ecmc might segfault.\nc6025-0010 startup Need to change boot setting:\n At PSI: make normal warewulf and packet fence setup, DON\u0026rsquo;T FORGETT THE USB DONGLE!!! Go to boot menu Boot menu: Set boot option 1 to \u0026ldquo;Usb stick\u0026rdquo; Advanced-\u0026gt;Network stack configuration: Enable network stack and PXE support Save and exit  "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/manual/general_cfg/iocsh_utils/","title":"iocsh utilities","tags":[],"description":"","content":"ECMC Iocsh Utilities ecmcEpicsEnvSetCalc \u0026ldquo;ecmcEpicsEnvSetCalc()\u0026rdquo; is used to evaluate expressions and set result to EPCIS environment variables. Useful for calculate:\n slave offsets sdo/pdo addresses (also in hex) motion scaling record fields \u0026hellip;  ecmcEpicsEnvSetCalc -h Use \u0026#34;ecmcEpicsEnvSetCalc(\u0026lt;envVarName\u0026gt;, \u0026lt;expression\u0026gt;, \u0026lt;format\u0026gt;)\u0026#34; to evaluate the expression and assign the variable. \u0026lt;envVarName\u0026gt; : EPICS environment variable name. \u0026lt;expression\u0026gt; : Calculation expression (see exprTK for available functionality). Examples: Simple expression:\u0026#34;5.5+${TEST_SCALE}*sin(${TEST_ANGLE}/10)\u0026#34;. Use of \u0026#34;RESULT\u0026#34; variable: \u0026#34;if(${TEST_VAL}\u0026gt;5){RESULT:=100;}else{RESULT:=200;};\u0026#34;. Strings are used within \u0026#39;\u0026lt;str\u0026gt;\u0026#39;: \u0026#34;\u0026#39;test\u0026#39;=\u0026#39;test\u0026#39;\u0026#34;. Note: expression result must be numeric and not string (in this case expression result is 1 =\u0026gt; \u0026lt;envVarName\u0026gt; will be set to \u0026#34;1\u0026#34;). \u0026lt;format\u0026gt; : Optional format string. Example \u0026#34;%lf\u0026#34;, \u0026#34;%8.3lf\u0026#34;, \u0026#34;%x\u0026#34;, \u0026#34;%04d\u0026#34; or \u0026#34;%d\u0026#34;, defaults to \u0026#34;%d\u0026#34;. Can contain text like \u0026#34;0x%x\u0026#34; or \u0026#34;Hex value is 0x60%x\u0026#34;. Must contain one numeric value where result of expression will be written. Restrictions: - Some flags and/or width/precision combinations might not be supported. - Hex numbers in the expression is not allowed (but hex as output by formating is OK). - Non floating point values will be rounded to nearest int. Examples: #### Calculate addresses in HEX with specified width # ecmcEpicsEnvSetCalc(\u0026#34;test2\u0026#34;, \u0026#34;$(test1)+1+2+3+4+5*10.1\u0026#34;, \u0026#34;%03x\u0026#34;) ecmcEpicsEnvSetCalc(\u0026#34;test2\u0026#34;, \u0026#34;061+1+2+3+4+5*10.1\u0026#34;, \u0026#34;%03x\u0026#34;) epicsEnvShow(\u0026#34;test2\u0026#34;) test2=07a #### Hex + text in format string # ecmcEpicsEnvSetCalc(\u0026#34;test2\u0026#34;, \u0026#34;$(test1)+1+2+3+4+5*10.1\u0026#34;, \u0026#34;This is the number: 0x%06x\u0026#34;) ecmcEpicsEnvSetCalc(\u0026#34;test2\u0026#34;, \u0026#34;061+1+2+3+4+5*10.1\u0026#34;, \u0026#34;This is the number: 0x%06x\u0026#34;) epicsEnvShow(\u0026#34;test2\u0026#34;) test2=This is the number: 0x00007a #### Calculate scaling (floating point) epicsEnvSet(\u0026#34;IORange\u0026#34;,32768) # ecmcEpicsEnvSetCalc(\u0026#34;scaling\u0026#34;, \u0026#34;$(test1)/$(IORange)*10\u0026#34;, \u0026#34;%lf\u0026#34;) ecmcEpicsEnvSetCalc(\u0026#34;scaling\u0026#34;, \u0026#34;061/32768*10\u0026#34;, \u0026#34;%lf\u0026#34;) epicsEnvShow(\u0026#34;scaling\u0026#34;) scaling=0.018616 #### Offset slave numbers (format defaults to \u0026#34;%d\u0026#34;) epicsEnvSet(\u0026#34;ECMC_SLAVE_NUM\u0026#34;,10) epicsEnvSet(\u0026#34;ECMC_SLAVE_NUM_OFFSET\u0026#34;,25) # ecmcEpicsEnvSetCalc(\u0026#34;ECMC_SLAVE_NUM\u0026#34;, \u0026#34;$(ECMC_SLAVE_NUM)+$(ECMC_SLAVE_NUM_OFFSET)\u0026#34;) ecmcEpicsEnvSetCalc(\u0026#34;ECMC_SLAVE_NUM\u0026#34;, \u0026#34;10+25\u0026#34;) epicsEnvShow(\u0026#34;ECMC_SLAVE_NUM\u0026#34;) ECMC_SLAVE_NUM=35 #### if-statement syntax (use \u0026#34;RESULT\u0026#34; variable) epicsEnvSet(\u0026#34;VALUE\u0026#34;,10) # ecmcEpicsEnvSetCalc(\u0026#34;IF_TEST\u0026#34;, \u0026#34;if(${VALUE}\u0026gt;5){RESULT:=100;}else{RESULT:=200;};\u0026#34;) ecmcEpicsEnvSetCalc(\u0026#34;IF_TEST\u0026#34;, \u0026#34;if(10\u0026gt;5){RESULT:=100;}else{RESULT:=200;};\u0026#34;) epicsEnvShow(\u0026#34;IF_TEST\u0026#34;) IF_TEST=100 #### Comparing strings 1 (use \u0026#39;\u0026lt;string\u0026gt;\u0026#39;): epicsEnvSet(\u0026#34;filename\u0026#34;,\u0026#34;ecmcEL3002.cmd\u0026#34;) # ecmcEpicsEnvSetCalc(\u0026#34;result\u0026#34;, \u0026#34;\u0026#39;$(filename)\u0026#39;=\u0026#39;test.script\u0026#39;\u0026#34;) ecmcEpicsEnvSetCalc(\u0026#34;result\u0026#34;, \u0026#34;\u0026#39;ecmcEL3002.cmd\u0026#39;=\u0026#39;test.script\u0026#39;\u0026#34;) epicsEnvShow(\u0026#34;result\u0026#34;) result=0 #### Comparing strings 2 (if-else): # ecmcEpicsEnvSetCalc(\u0026#34;result\u0026#34;, \u0026#34;if(\u0026#39;$(filename)\u0026#39;=\u0026#39;test.script\u0026#39;) {RESULT:=1;}else{RESULT:=0;};\u0026#34;) ecmcEpicsEnvSetCalc(\u0026#34;result\u0026#34;, \u0026#34;if(\u0026#39;ecmcEL3002.cmd\u0026#39;=\u0026#39;test.script\u0026#39;) {RESULT:=1;}else{RESULT:=0;};\u0026#34;) epicsEnvShow(\u0026#34;result\u0026#34;) result=0 ecmcEpicsEnvSetCalcTernary \u0026ldquo;ecmcEpicsEnvSetCalcTernary()\u0026rdquo; is used o evaluate expressions and set EPCIS environment variables to different strings. depending on if the expression evaluates to \u0026ldquo;true\u0026rdquo; or \u0026ldquo;false\u0026rdquo;. Can be useful for:\n Choose different files to load like plc-files, axis configurations, db-files or.. making conditional ecmc settings \u0026hellip;  ecmcEpicsEnvSetCalcTernary -h Test iocsh function \u0026#34;ecmcEpicsEnvSetCalcTernary()\u0026#34; t Use \u0026#34;ecmcEpicsEnvSetCalcTernary(\u0026lt;envVarName\u0026gt;, \u0026lt;expression\u0026gt;, \u0026lt;trueString\u0026gt;, \u0026lt;falseString\u0026gt;)\u0026#34; to evaluate the expression and assign the variable. \u0026lt;envVarName\u0026gt; : EPICS environment variable name. \u0026lt;expression\u0026gt; : Calculation expression (see exprTK for available functionality). Examples: Simple expression:\u0026#34;5.5+${TEST_SCALE}*sin(${TEST_ANGLE}/10)\u0026#34;. Use of \u0026#34;RESULT\u0026#34; variable: \u0026#34;if(${TEST_VAL}\u0026gt;5){RESULT:=100;}else{RESULT:=200;};\u0026#34;. Strings are used within \u0026#39;\u0026lt;str\u0026gt;\u0026#39;: \u0026#34;\u0026#39;test\u0026#39;=\u0026#39;test\u0026#39;\u0026#34;. Note: expression result must be numeric and not string (in this case expression result is 1 =\u0026gt; \u0026lt;envVarName\u0026gt; will be set to \u0026lt;trueString\u0026gt;). \u0026lt;trueString\u0026gt; : String to set \u0026lt;envVarName\u0026gt; if expression (or \u0026#34;RESULT\u0026#34;) evaluates to true. \u0026lt;falseString\u0026gt; : String to set \u0026lt;envVarName\u0026gt; if expression (or \u0026#34;RESULT\u0026#34;) evaluates to false. Examples: ### Simple true false epicsEnvSet(\u0026#34;VALUE\u0026#34;,10) # ecmcEpicsEnvSetCalcTernary(\u0026#34;test_var\u0026#34;, \u0026#34;${VALUE}+2+5/10\u0026#34;,\u0026#34;True\u0026#34;,\u0026#34;False\u0026#34;) ecmcEpicsEnvSetCalcTernary(\u0026#34;test_var\u0026#34;, \u0026#34;10+2+5/10\u0026#34;,\u0026#34;True\u0026#34;,\u0026#34;False\u0026#34;) epicsEnvShow(\u0026#34;test_var\u0026#34;) test_var=True ### Can be used for choosing different files # ecmcEpicsEnvSetCalcTernary(\u0026#34;filename\u0026#34;, \u0026#34;${VALUE}\u0026gt;20\u0026#34;,\u0026#34;./plc_fast.cfg\u0026#34;,\u0026#34;./plc_slow.cfg\u0026#34;) ecmcEpicsEnvSetCalcTernary(\u0026#34;filename\u0026#34;, \u0026#34;10\u0026gt;20\u0026#34;,\u0026#34;./plc_fast.cfg\u0026#34;,\u0026#34;./plc_slow.cfg\u0026#34;) epicsEnvShow(\u0026#34;filename\u0026#34;) filename=./plc_slow.cfg ### Comparing strings 1 (simple): # ecmcEpicsEnvSetCalcTernary(\u0026#34;result\u0026#34;, \u0026#34;\u0026#39;$(filename)\u0026#39;=\u0026#39;./plc_slow.cfg\u0026#39;\u0026#34;,\u0026#34;equal\u0026#34;,\u0026#34;not_equal\u0026#34;) ecmcEpicsEnvSetCalcTernary(\u0026#34;result\u0026#34;, \u0026#34;\u0026#39;./plc_slow.cfg\u0026#39;=\u0026#39;./plc_slow.cfg\u0026#39;\u0026#34;,\u0026#34;equal\u0026#34;,\u0026#34;not_equal\u0026#34;) epicsEnvShow(\u0026#34;result\u0026#34;) result=equal ### Comparing strings 2 (with if-else): # ecmcEpicsEnvSetCalcTernary(\u0026#34;result\u0026#34;, \u0026#34;if(\u0026#39;$(filename)\u0026#39;=\u0026#39;test\u0026#39;) {RESULT:=1;}else{RESULT:=0;};\u0026#34;,\u0026#34;use_this_file.cfg\u0026#34;,\u0026#34;no_use_this_file.cfg\u0026#34;) ecmcEpicsEnvSetCalcTernary(\u0026#34;result\u0026#34;, \u0026#34;if(\u0026#39;./plc_slow.cfg\u0026#39;=\u0026#39;test\u0026#39;) {RESULT:=1;}else{RESULT:=0;};\u0026#34;,\u0026#34;use_this_file.cfg\u0026#34;,\u0026#34;no_use_this_file.cfg\u0026#34;) epicsEnvShow(\u0026#34;result\u0026#34;) result=no_use_this_file.cfg ecmcIf(\u0026lt;expression\u0026gt;,\u0026lt;optional true macro\u0026gt;,\u0026lt;optional false macro\u0026gt;) ecmcIf() set two macros depending on the value of the evaluated expression. If it evaluates to true:\n IF_TRUE=\u0026quot;\u0026quot; Allows execution of a line of code IF_FALSE= \u0026ldquo;#-\u0026rdquo; Block execution of a line of code  If expression evaluates to false:\n IF_TRUE=\u0026quot;#-\u0026quot; Block execution of a line of code IF_FALSE= \u0026quot;\u0026quot; Allows execution of a line of code  Note: These macros are the default names for the macros (but can be changed by assignment of the 2 last params in call to ecmcIf()):\n IF_TRUE for true IF_FALSE for false  ecmcEndIf ecmcEndIf() The ecmcEndIf() command unsets the last used macros (for true and false), if different names are passed as arguments then then these macros are unset (for nested if statements).\nExample of syntax Example 1:\necmcIf(\u0026#34;\u0026lt;expression\u0026gt;\u0026#34;) ${IF_TRUE} # Code to execute if expression eval true #- else ${IF_FALSE} # Code to execute if expression eval false ecmcEndIf() Example 2:\necmcIf(\u0026#34;$(VAL1)=$(VAL2)\u0026#34;) ${IF_TRUE}epicsEnvSet(IS_EQUAL,\u0026#34;1\u0026#34;) #- else ${IF_FALSE}epicsEnvSet(IS_EQUAL,\u0026#34;0\u0026#34;) ecmcEndIf() Note: For nested calls to ecmcIf() and ecmcEndIf() optional macros must be used.\necmcForLoop Useful for:\n Large systems with many similar sub systems Configuring hardware with many PDOs (oversampling)  \u0026#34;ecmcForLoop(\u0026lt;filename\u0026gt;, \u0026lt;macros\u0026gt;, \u0026lt;loopvar\u0026gt;, \u0026lt;from\u0026gt;, \u0026lt;to\u0026gt;, \u0026lt;step\u0026gt;)\u0026#34; to loop execution of file with a changing loop variable. \u0026lt;filename\u0026gt; : Filename to execute in for loop. \u0026lt;macros\u0026gt; : Macros to feed to execution of file. \u0026lt;loopvar : Environment variable to use as index in for loop. \u0026lt;from\u0026gt; : \u0026lt;loopvar\u0026gt; start value. \u0026lt;to\u0026gt; : \u0026lt;loopvar\u0026gt; end value. \u0026lt;step\u0026gt; : Step to increase \u0026lt;loopvar\u0026gt; each loop cycle. Example (\u0026ldquo;ECMC_LOOP_IDX\u0026rdquo; as loop variable):\necmcForLoop(./loopStep.cmd,\u0026#34;\u0026#34;,ECMC_LOOP_IDX,1,5,1) ecmcEpicsEnvSetCalc(\u0026#34;TESTING\u0026#34;,1*10) epicsEnvShow(\u0026#34;TESTING\u0026#34;) TESTING=10 ecmcEpicsEnvSetCalc(\u0026#34;TESTING\u0026#34;,2*10) epicsEnvShow(\u0026#34;TESTING\u0026#34;) TESTING=20 ecmcEpicsEnvSetCalc(\u0026#34;TESTING\u0026#34;,3*10) epicsEnvShow(\u0026#34;TESTING\u0026#34;) TESTING=30 ecmcEpicsEnvSetCalc(\u0026#34;TESTING\u0026#34;,4*10) epicsEnvShow(\u0026#34;TESTING\u0026#34;) TESTING=40 ecmcEpicsEnvSetCalc(\u0026#34;TESTING\u0026#34;,5*10) epicsEnvShow(\u0026#34;TESTING\u0026#34;) TESTING=50 where \u0026ldquo;loopStep.cmd\u0026rdquo; file looks like this (note the use of \u0026ldquo;ECMC_LOOP_IDX\u0026rdquo;):\n#- Commands tp execute in each loop of example ecmcForLoop.script ecmcEpicsEnvSetCalc(\u0026#34;TESTING\u0026#34;,${ECMC_LOOP_IDX}*10) epicsEnvShow(\u0026#34;TESTING\u0026#34;) ecmcFileExist Useful for checking that configuration files really exist and then can be loaded.\necmcFileExist(\u0026lt;filename\u0026gt;, \u0026lt;die\u0026gt;, \u0026lt;check EPICS dirs\u0026gt;, \u0026lt;dirs\u0026gt;)\u0026#34; to check if a file exists. \u0026lt;filename\u0026gt; : Filename to check. \u0026lt;die\u0026gt; : Exit EPICS if file not exist. Optional, defaults to 0. \u0026lt;check EPICS dirs\u0026gt; : Look for files in EPICS_DB_INCLUDE_PATH dirs. Optional, defaults to 0.\\n\u0026#34;); \u0026lt;dirs\u0026gt; : List of dirs to search for file in (separated with \u0026#39;:\u0026#39;). result will be stored in the EPICS environment variable \u0026#34;ECMC_FILE_EXIST_RETURN_VAL\u0026#34; Example:\necmcFileExist(\u0026#34;file_exist.cfg\u0026#34;) epicsEnvShow(ECMC_FILE_EXIST_RETURN_VAL) ECMC_FILE_EXIST_RETURN_VAL=1 ecmcFileExist(\u0026#34;file_not_exist.cfg\u0026#34;,1) Error: File \u0026#34;file_not_exist.cfg\u0026#34; does not exist. ECMC shuts down. ecmcFileExist(\u0026#34;ecmcEK1100.substitutions\u0026#34;,1,1) epicsEnvShow(ECMC_FILE_EXIST_RETURN_VAL) ECMC_FILE_EXIST_RETURN_VAL=1 ecmcFileExist(\u0026#34;ecmcEK1100.substitutions\u0026#34;,0,0,\u0026#34;/home/\u0026#34;) epicsEnvShow(ECMC_FILE_EXIST_RETURN_VAL) ECMC_FILE_EXIST_RETURN_VAL=0 Use return value of ecmcConfig(OrDie): The return value from ecmcConfig(OrDie) is stored in the EPICS environment variable \u0026ldquo;ECMC_CONFIG_RETURN_VAL\u0026rdquo;. This value can be used to make som dynamic configuration. All ASCII configuration commands for ecmcConfig(OrDie) can be used in the same way.\nExample: Read firmware version of an EL7037 stepper drive Note: SDO reads need to be before \u0026ldquo;SetAppMode(1)\u0026rdquo;\necmcConfig \u0026#34;EcReadSdo(${ECMC_SLAVE_NUM},0x100a,0x0,2)\u0026#34; epicsEnvShow(ECMC_CONFIG_RETURN_VAL) ECMC_CONFIG_RETURN_VAL=14640 The variable \u0026ldquo;ECMC_CONFIG_RETURN_VAL\u0026rdquo; then can be used to set record fields, name or alias for instance..\nExample: Read \u0026ldquo;ID\u0026rdquo; PDO from EK1101 (shown in detail in aliasRecordFromPdoData.script) Note: PDO reads need to be after \u0026ldquo;SetAppMode(1)\u0026rdquo; since cyclic value\necmcConfig \u0026#34;ReadEcEntryIDString(${ECMC_SLAVE_NUM},\u0026#34;ID\u0026#34;)\u0026#34; ## This is the value of the EK1101 ID switch epicsEnvShow(ECMC_CONFIG_RETURN_VAL) ECMC_CONFIG_RETURN_VAL=1024 The variable \u0026ldquo;ECMC_CONFIG_RETURN_VAL\u0026rdquo; then can be used to set record fields, name or alias for instance..\nTodo Add docs for:\n ecmcConfigOrDie ecmcConfig ecmcGrepParam ecmcGrepRecord ecmcReport ecmcAsynPortDriverConfigure  "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/manual/knowledgebase/hardware/el5042/","title":"EL5042","tags":[],"description":"","content":"Topics  error/warning Diagnostics Offset LSB Bit [Bit] (0x80p8:17) SSI 9V supply   error/warning/not ready Could be caused by:\n Wrong settings (bit counts, ..), see further below on this page (and also motion/best practice). Bad electrical connection Wrong power supply Defect encoder or EL5042 Long cabling lengths Wrong communication frequency  Always start troubleshooting by checking the error, warning and ready bits and reading the EL5042 manual. Next step is to read the diagnostic SDO bits of the EL5042, see below under heading \u0026ldquo;Diagnostics\u0026rdquo;.\nBad electrical connection The serial communication is handled by two RS422 channels, one for the clock and one for data. These channels can be measured with a scope:\n The clock should output periodic \u0026ldquo;bursts\u0026rdquo; with clock pulses with a short break in between. The bursts should appear in the same rate as the ethercat frame rate (EC_RATE, default 1kHz). And the frequency of the clock pulses should correspond with the setting in your startup script (normally 250kHz..10Mhz depending on configuration) The data channel should return bits in sync with the clock pulses.  Lack of clock or data pulses could be caused by (in order of probability):\n short circuit or error in cabling defect/burt encoder No/wrong power supply defect EL5042 (if lack of clock pulses)  Wrong power supply Make sure the encoder is powered with the correct voltage. Most encoders require 5V, but there are also some that require 9V, 12V or 24V.\nNever apply a higher voltage than the specified operating voltage for the encoder.\n The EL5042 can supply 5V or 9V. The default setting is 5V and in order to change the setting to 9V a special sequence need to be executed (see below and the EL5042 manual).\nThe voltage cannot be different on the two channels. A change to 9V will apply to both channels!\n From EL5042 manual:\n# Setting the encoder supply voltage # Condition: To write 0x8008:12 “Supply Voltage”, the value 0x72657375 (ASCII: “user”) must be set in 0xF008 “Code word”. # # Set the value into index 0x8008:12 “Supply Voltage” (Specification in steps of 0.1 V). # Only the values 50 (5.0 V) and 90 (9.0 V) are permissible. # This setting applies to both channels. # Before switching to 9.0 V make sure that both BiSS encoders support the extended voltage range! # # The encoder supply voltage is set for both channels in object 0x8008:12 # -------------------------------------------------------------------------------------------------------------------------- After the above sequence is executed, the slave must go to INIT state before the new setting is applied. This can be done with the ethercat tool:\nethercat states -m\u0026lt;master_id\u0026gt; -p\u0026lt;slave_id\u0026gt; INIT # then back to preop ethercat rescan After ensuring that the encoder is correctly supplied, then verify the power consumption of the encoder and compare with the specified consumption. If the power consumption does not match, the encoder might be broken or a faulty cabling.\nLong cable lengths Long cable lengths can affect both power supply levels and the serial data channels.\nPower supply:\nLonger cables will normally also result in a higher voltage drops. Especially for 5V encoders this can be an issue. Make sure that the voltage are within the specified range by measuring the voltage level close to the encoder.\nIf the voltage is to low (mainly for 5V encoders):\n Can cabling length be reduced Can cable impedance be reduced (higher area) Add a separate (5V) power supply with possibilities to adjust the voltage level to a slightly higher voltage. Make sure the voltage is not too high at the encoder end.  Serial communication:\nThe serial communication is also affected by the cable length. For long cable lengths a reduction of the clock rate can be needed. The clock rate can be reduced by setting the CLK_FRQ_KHZ macro in the call to applyComponent.cmd (set clock freq. to 500kHz):\n${SCRIPTEXEC} ${ecmccfg_DIR}applyComponent.cmd \u0026#34;COMP=Encoder-RLS-LA11-26bit-BISS-C,CH_ID=1,MACROS=\u0026#39;CLK_FRQ_KHZ=500\u0026#39;\u0026#34; For EL5042 the following rates are available:\n 10 MHz 5 MHz 3.33 MHz 2.5 MHz default for some encoders in ecmccomp 2 MHz 1 MHz Max for SSI and default for some encoders in ecmccomp 500 kHz 250 kHz  NOTE: The closest freq. equal or higher than CLK_FRQ_KHZ will be selected.\nWrong communication frequency In ecmccfg the default frequency for encoders are set to the lowest possible value, 100kHz. Sometimes increaseing the frequence to 1MHz will result in a more stable reading. If possible use ecmccomp instead of ecmccfg for configutration of encoders since, in the ecmccomp repo, the default frequency values are higher and normally more stable.\nSee above for available communications rates.\nDiagnostics The diagnostic data can be read from register Index A0p8 FB BiSS-C Diag data (for Ch.1, p = 0; Ch.2, p = 1):\nThe ecmccfg/utils/read_el5042_diag.sh tool can be used for reading the diagnostics:\nbash read_el5042_diag.sh \u0026lt;master_id\u0026gt; \u0026lt;slave_id\u0026gt; \u0026lt;channel_id\u0026gt; NOTE: The channel id starts at 0. First encoder channel is 0.\nExample: master 1, slave 14, channel 0\n# first login to ecmc server $ bash read_el5042_diag.sh 1 14 0 ######################################################### Reading EL5042 Ch 0 status at master id 1 and slave id 14: Power supply present: 0x01 1 Error: 0x00 0 SDC Error: 0x01 1 WD Error: 0x01 1 Data valid: 0x00 0 Data raw value: 0x0000000000000000 0 ######################################################### Note: The tool ecmccfg/utils/PDO_read can also be used for reading the diagnostics.\nOffset LSB Bit [Bit] (0x80p8:17) When using the LSB offset, the same amount of ones (\u0026ldquo;1\u0026rdquo;) will be shifted in as MSB. Therefore the LSB offset should normally not be used.\n When using the LSB offset setting, the same amount of bits needs to be subtracted from the ST_BITS or MT_BITS\nExample: 26bit RLS, no LSB offset\n${SCRIPTEXEC} ${ecmccfg_DIR}applyComponent.cmd \u0026quot;COMP=Encoder-RLS-LA11-26bit-BISS-C,CH_ID=1,OFF_BITS=0\u0026quot; Example: 26bit RLS with 3 bits offset (ST_BITS=23, OFF_BITS=0)\n#If the offset is needed then the sum of the bit's still need to match the bit-count of the encoder. Example: Offset 3 LSB bits, set ST_BITS=23 (26-3) ${SCRIPTEXEC} ${ecmccfg_DIR}applyComponent.cmd \u0026quot;COMP=Encoder-Generic-BISS-C,CH_ID=1,MACROS=MT_BITS=0,ST_BITS=23,CLK_FRQ_KHZ=1000,OFF_BITS=3\u0026quot; SSI  The entire SSI frame needs to covered in MT_BITS and ST_BITS (also status bits and startup bits), also see \u0026ldquo;Offset LSB Bit\u0026rdquo; above. Enabling status bits by SDO (0x80p8:02) will not work, seems only valid for BISS-C (kind of hints this in manual).  If the total bit count does not match, the READY bit of the EL5042 will be low (and sometimes also error or warning).\n Example: 26bit RLS encoder with 2 status bits (set ST_BITS=28)\n${SCRIPTEXEC} ${ecmccfg_DIR}applyComponent.cmd \u0026quot;COMP=Encoder-Generic-SSI,CH_ID=1,MACROS=MT_BITS=0,ST_BITS=28,CLK_FRQ_KHZ=1000,CODING=0\u0026quot; Some SSI encoders, i.e. Posital kit SSI, also send startup bits. These also needs to be accounted for in the ST_BITS and MT_BITS.\nExample: Posital kit SSI encoder, KCD-S1X3B-1617-IE4F-GRQ\n# Specs: # Single turn bits 17 # Multiturn bits: 16 # Status bits: 2 # Startup bits 8 (zeros) # This then results in: # MT_BITS=16 + 8 = 24 (multi turn bits + startup bits) # ST_BITS=17 + 2 = 19 (single turn bits + status bits) ${SCRIPTEXEC} ${ecmccfg_DIR}applyComponent.cmd \u0026quot;COMP=Encoder-Generic-SSI,CH_ID=1,MACROS=MT_BITS=24,ST_BITS=19\u0026quot; The status bits can then be masked away by:\n Using the LSB offset (set to 2 and reduce ST_BITS to 26), then the status bits are shifted away already in EL5042 hardware. Then you cannot access the status bits (to use from PLC or for interlock) Setting a mask in axis yaml file (encoder.mask: 0xFFFFFFC), in this case the encoder.absBits should not be used because it\u0026rsquo;s automatically calculated by the mask command. Then you can reach the bits in the raw encoder value.  9V supply The EL5042 supports encoder supply of 5V (default) or 9V. The supply voltage is same for both channels. Make sure both encoders can be operated at the selected voltage\n In order to set the voltage to 9V a certain procedure needs to be executed:\n The reset of the slave executed by addSlave.cmd needs to be disabled since it\u0026rsquo;s resets voltage to 5V  epicsEnvSet(ECMC_SLAVE_RESET,false) # Override reset of EL5042 ${SCRIPTEXEC} ${ecmccfg_DIR}addSlave.cmd, \u0026quot;SLAVE_ID=14,HW_DESC=EL5042\u0026quot; SDO 0xF008 0x0 needs to be set to \u0026ldquo;0x72657375\u0026rdquo; (ascii \u0026ldquo;user\u0026rdquo;) SDO 0x8008 0x12 set to the desired voltage level in dV (90dV)  #- To allow change to 9v, 0xF008 must be set to 0x72657375 ecmcConfigOrDie \u0026quot;Cfg.EcAddSdo(${ECMC_EC_SLAVE_NUM},0xF008,0x0,0x72657375,4)\u0026quot; #- Set voltage to 90 (need also to go down to INIT and back, needs to be done manually) ecmcConfigOrDie \u0026quot;Cfg.EcAddSdo(${ECMC_EC_SLAVE_NUM},0x8008,0x12,90,1)\u0026quot; After this change of voltage setting the slave needs to go to INIT state and back to OP. Only needed first time when the 9v is set. This needs to be performed with the ethercat tool:  Example for master 1 and EL5042 at slave position 14:\n# Go to init in order to apply the 9V setting ethercat states -m1 -p14 INIT # Go back to OP ethercat states -m1 -p14 OP Now the EL5042 encoder supply voltage will be 9V. IOC reboot or power cycle of the EL5042 will not change the setting.\nIf the EL5042 is replaced then the above procedure needs to be repeated\n In order to monitor the voltage an analog input card can be used.\nIf old style ecmccfg encoder configuration scripts are used, then they normally set the supply voltage to 5V. This results in that the slave will not go o OP since it conflicts with the 9V setting. Use ecmccomp configurations instead, in ecmccomp the power setting is not set.\n "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/manual/plc_cfg/best_practice/","title":"best practice","tags":[],"description":"","content":"best practice Here you can find some best practice configurations for common use cases.\n Macros MSI include, substitute Printouts Description Common PLC code in ecmccfg/plc_lib Variable declaration  The complete examples with startup files can be found here\nmacros Use of macros makes the code more generic. When loading a PLC file with \u0026ldquo;loadPLCFile.cmd\u0026rdquo;, custom macros can be defined in \u0026ldquo;PLC_MACROS\u0026rdquo;:\n${SCRIPTEXEC} ${ecmccfg_DIR}loadPLCFile.cmd, \u0026#34;FILE=./cfg/main.plc, INC=.:./cfg/, DESC=\u0026#39;Test\u0026#39;, SAMPLE_RATE_MS=1000, PLC_MACROS=\u0026#39;BO_S_ID=${ECMC_EC_SLAVE_NUM}\u0026#39;\u0026#34; NOTE: ECMC_EC_SLAVE_NUM expands to the ID of the last added slave.\nIn addition to the custom macros, a few macros, that are often needed, are predefined:\n SELF_ID : Id of current PLC SELF : plc\u0026lt;SELF_ID\u0026gt; M_ID : EtherCAT master ID M : ec\u0026lt;M_ID\u0026gt;  SELF_ID and SELF example A common use case is that some initiation is needed, could be triggering of a custom homing sequence:\nif(${SELF}.firstscan) { var plc:=${SELF_ID}; ${DBG=#}println(\u0026#39;PLC \u0026#39;,plc,\u0026#39; is starting up\u0026#39;); }; After macro expansion the code would look like this (for PLC id=0,DBG=''):\nif(plc0.firstscan) { var plc:=0; println(\u0026#39;PLC \u0026#39;,plc,\u0026#39; is starting up\u0026#39;); }; M_ID and M example All EtherCAT related information/data is accessible through the pattern \u0026ldquo;ec\u0026lt;master_id\u0026gt;.s\u0026lt;slave_id\u0026gt;.\u0026rdquo;. To allow the same code to be loaded on different masters it\u0026rsquo;s a good idea to use the predefined macros,\u0026ldquo;M\u0026rdquo; and \u0026ldquo;M_ID\u0026rdquo;.\nToggle an output:\n${M}.s${BO_S_ID}.binaryOutput${BO_CH=01}:=not(${M}.s${BO_S_ID}.binaryOutput${BO_CH=01}); ${DBG=#}println(\u0026#39;State: \u0026#39;, ${M}.s${BO_S_ID}.binaryOutput${BO_CH}); After macro expansion with the following macros the code would look like this:\n BO_S_ID = 10 BO_CH = Not defined (defaults to \u0026ldquo;01\u0026rdquo;) DBG = Not defined (defaults to \u0026ldquo;#\u0026quot;)  ec0.s10.binaryOutput01:=not(ec0.s10.binaryOutput01); #println(\u0026#39;State: \u0026#39;, ec0.s10.binaryOutput01); include and substitute Since all PLC files and PLC libs are parsed through MSI the \u0026ldquo;include\u0026rdquo; and \u0026ldquo;substitute\u0026rdquo; commands can be used.\nWhen using the include command, the file location dir of the file must be added in the INC parameter when loading the PLC:\n${SCRIPTEXEC} ${ecmccfg_DIR}loadPLCFile.cmd, \u0026#34;FILE=./cfg/main.plc, INC=.:./cfg/, DESC=\u0026#39;Test\u0026#39;, SAMPLE_RATE_MS=1000, PLC_MACROS=\u0026#39;BO_S_ID=${ECMC_EC_SLAVE_NUM}\u0026#39;\u0026#34; The \u0026ldquo;INC\u0026rdquo; parameter can contain several directories separated with a \u0026ldquo;:\u0026rdquo;, making it possible to include PLC files from several locations/modules.\nexample: Toggle a few outputs As a demo use case let\u0026rsquo;s consider that a few outputs needs to be toggled. NOTE: There are simpler ways to write this specific code but it\u0026rsquo;s used to demo how code can be divided.\nLets first define some code that toggles a bit (toggle_output.plc_inc):\n# Example of simple include file that toggles an binary output ${M}.s${BO_S_ID}.binaryOutput${BO_CH}:=not(${M}.s${BO_S_ID}.binaryOutput${BO_CH}); ${DBG=#}println(\u0026#39;State: \u0026#39;, ${M}.s${BO_S_ID}.binaryOutput${BO_CH}); This code snippet then can be included in a main plc-file by using the \u0026ldquo;include\u0026rdquo; keyword. Each include can then be included with different macros by using the \u0026ldquo;substitute\u0026rdquo; keyword:\nsubstitute \u0026#34;BO_CH=01\u0026#34; include \u0026#34;toggle_output.plc_inc\u0026#34; substitute \u0026#34;BO_CH=02, DBG=\u0026#34; include \u0026#34;toggle_output.plc_inc\u0026#34; The above code would expand to:\nec0.s10.binaryOutput01:=not(ec0.s10.binaryOutput01); #println(\u0026#39;State:\u0026#39;, ec0.s10.binaryOutput01);  ec0.s10.binaryOutput02:=not(ec0.s10.binaryOutput02); println(\u0026#39;State: \u0026#39;, ec0.s10.binaryOutput02); The resulting code will toggle two different outputs, the state of the last output will be printed.\nNOTE: Macros cannot be used in the filename when including a file. Instead the dir should be defined in the INC param when loading the PLC, see above.\nprintouts There are two good ways to handle printouts:\n plc\u0026lt;id\u0026gt;.dbg or ${SELF}.dbg flag: Accessible bit from generic plc panel. Printouts can be switched on/off in runtime. MACROS: Mask priontouts with dbeug macros. IOC needs to be restated with a different MACRO value in order to change state of printouts.  plc\u0026lt;id\u0026gt;.dbg or ${SELF}.dbg The variable plc\u0026lt;id\u0026gt;.dbg or ${SELF}.dbg can be used to turn on and of debug printouts for an PLC:\nif(${SELF}.dbg) { println(\u0026#39;Time: \u0026#39;,ec_get_time()); println(\u0026#39;Time MONO: \u0026#39;,ec_get_time_frm_src(1)); println(\u0026#39;Time REAL: \u0026#39;,ec_get_time_frm_src(0)); }; This allows turning on/off printouts in runtime by writing to the \u0026lt;prefix\u0026gt;PLC\u0026lt;id\u0026gt;-DbgCmd PV which is accessinle in the generic plc panel (can be started from ecmcMain.ui).\nOnly use the plc\u0026lt;id\u0026gt;.dbg variable for dbg purpose. It should always be safe to write to this variable.\n MACROS Adding a DBG macro can be usefull to be able to turn on/off printouts. Typically during commissioning it can be use full to have many printouts but later when system goes into production, it could be a good idea to turn (some) printouts off.\nExample of a printout that can be turned on/off (default off)\n${DBG=#}println(\u0026#39;Value: \u0026#39;, ${M}.s${BO_S_ID}.binaryOutput${BO_CH}); Will result in the below if setting the DBG='' (and some other macros, see above):\nprintln(\u0026#39;Value: \u0026#39;, ec0.s10.binaryOutput01); Description Always add a description when creating a PLC by setting the DESC macro when calling loadPLCFile.cmd.\nExample:\n${SCRIPTEXEC} ${ecmccfg_DIR}loadPLCFile.cmd, \u0026#34;FILE=./cfg/main.plc, INC=.:./cfg/, DESC=\u0026#39;Toggle some bits\u0026#39;, SAMPLE_RATE_MS=1000, PLC_MACROS=\u0026#39;BO_S_ID=${ECMC_EC_SLAVE_NUM}\u0026#39;\u0026#34;  The description can maximum be 40 chars long.\n Common PLC lib In ecmccfg/plc_lib some code snippets are accessible. These are installed in ecmccfg module and can be accesses in ${ecmccfg_DIR}.\nSofar, the following code is accessible:\n Homing of abs encoder with overflow Synchronization kinematics and state machine (master-slave)  Variable declaration By declaring variables the ecmc plc code will be simpler to read. A declaration block needs to be added starting with \u0026ldquo;VAR\u0026rdquo; and ending with \u0026ldquo;END_VAR\u0026rdquo;:\nVAR \u0026lt;declarations\u0026gt; END_VAR \u0026lt;plc code\u0026gt; The declaration needs to comply with the following syntax:\nVAR \u0026lt;var_name\u0026gt; : \u0026lt;address\u0026gt;; END_VAR The following \u0026ldquo;addresses\u0026rdquo; can be used:\n global:  global.\u0026lt;name\u0026gt;   static  static.\u0026lt;name\u0026gt;   ethercat  ec\u0026lt;mid\u0026gt; ec\u0026lt;mid\u0026gt;.s\u0026lt;sid\u0026gt; ec\u0026lt;mid\u0026gt;.s\u0026lt;sid\u0026gt;.\u0026lt;name\u0026gt;   motion:  ax\u0026lt;id\u0026gt; ax\u0026lt;id\u0026gt;.traj ax\u0026lt;id\u0026gt;.enc ax\u0026lt;id\u0026gt;.drv ax\u0026lt;id\u0026gt;.mon ax\u0026lt;id\u0026gt;.traj.\u0026lt;name\u0026gt; ax\u0026lt;id\u0026gt;.enc.\u0026lt;name\u0026gt; ax\u0026lt;id\u0026gt;.drv.\u0026lt;name\u0026gt; ax\u0026lt;id\u0026gt;.mon.\u0026lt;name\u0026gt;   data storage:  ds\u0026lt;id\u0026gt; ds\u0026lt;id\u0026gt;.\u0026lt;name\u0026gt;   constants  \u0026lt;name\u0026gt;    The variables will then be replaced/substituted with the addresses during load time.\nExample of plc file with declaration section and code section:\nVAR // Globals gTest : global.test; // Statics sTest : static.test; // EtherCAT I/0 actPos : ${M}.s${DRV_SID}.positionActual01; mySlave : ${M}.s${DRV_SID}; coolingValveBO : ${M}.s${BO_SID=2}.binaryOutput02; // Axis data targetPos : ax${AX_ID=1}.traj.targetpos; myAxis : ax1; myTraj : ax${AX_ID=1}.traj; // Data storage buffer : ds${DS_ID=0}; // Constants pi : 3.1415; END_VAR coolingValveBO:=not(coolingValveBO); println('mySlave.controlWord: ', mySlave.driveControl${CH=01}); if(myTraj.targetpos\u0026lt;\u0026gt;static.oldTarget) { println('new target: ',myTraj.targetpos ); }; static.oldTarget := myTraj.targetpos; if(gTest+ 1 \u0026gt; 10+sTest+mySlave.positionActual01) { println('actPos:', actPos); }; if(gTest+ 1\u0026gt; 10+mySlave.positionActual01) { println('actPos:', actPos); }; static.pini:=1; println('actPos:', actPos, ' myAxis enc: ', myAxis.enc.actpos+pi); gTest += 1; println('buffer index: ', buffer.index); if(myTraj.setpos\u0026gt;0) { myTraj.setpos+=1; } As an example, the first row of the code section:\ncoolingValveBO:=not(coolingValveBO); will be converted to:\n${M}.s${BO_SID=2}.binaryOutput02:=not(${M}.s${BO_SID=2}.binaryOutput02); and:\nif(gTest+ 1 \u0026gt; 10+sTest+mySlave.positionActual01) { will be converted to:\nif(global.test+ 1 \u0026gt; 10+static.test+${M}.s${DRV_SID}.positionActual01) { "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/manual/general_cfg/ecmc_command_ref/","title":"ecmc command reference","tags":[],"description":"","content":"ecmc command reference  ethercat motion general misc plc  "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/manual/knowledgebase/hardware/el51xx/","title":"EL51xx","tags":[],"description":"","content":"Overview The EL51xx series covers incremental encoder interfaces:\n EL5101: 1 ch, diff rs422, ttl, 1MHz EL5101-0010: 1 ch, diff rs422, 5MHz EL5101-0011: 1 ch, diff rs422, 5MHz, oversampling 100kHz EL5112: 2 ch ABC or 1 ch AB, rs422, 5MHz, PSI standard EL5131: 1 ch, diff rs422, 5MHz, 2 digital outputs for cam/trigger  General Normally, the incremental encoder interfaces do not require any SDO configuration. Therefore, the ecmccomp/applyComponent.cmd, which many times are needed after the ecmccfg/addSlave.cmd, is in most cases not needed.\nAdding the slave Make sure you use the correct slave type when adding the slave. Some of the slaves have the same product id but totally different process data which can result in that the slave will not go into OP mode and ecmc will fail to start and a timeout will occur.\nFor example, the EL5101-0010 and EL5101-0011 has the same product id but very different process data. So, if an EL5101-0011 is added to the configuration but the actual slave connected is an EL5101-0010, the initial product id verification will not catch the miss match. However, later the slave will not go online since the process data is wrong.\nThe issue can be diagnosed by checking the dmesg logs:\n# first login to host (ecmc server) sudo dmesg Configuring the wrong process data will lead to an error message \u0026ldquo;* EtherCAT * Invalid input configuration\u0026rdquo;\nThe solution is to use the correct configuration script.\nEL5101-0010 This is commonly used at PSI (even though the EL5112 should be teh standard choice). For configuration, use the EL5101-0010 configuration script:\n${SCRIPTEXEC} ${ecmccfg_DIR}addSlave.cmd, \u0026quot;SLAVE_ID=16, HW_DESC=EL5101-0010\u0026quot; EL5101-0011 This is an oversampling slave, use the EL5101-0011 configuration script with an optional NELM which defines the levels of oversampling: Example: Add an EL5101-0011, with 100 levels of oversampling:\n${SCRIPTEXEC} ${ecmccfg_DIR}addSlave.cmd, \u0026quot;SLAVE_ID=16, HW_DESC=EL5101-0011, NELM=100\u0026quot; In the above example, for each ethercat frame, an array of 100 elements will be transferred. If the ethercat rate is 1kHz, then the incremental data will be sampled at 100kHz (which also is the maximum rate for this terminal).\nNELM cannot be freely defined, depending on the ethercat rate different NELM values will be accepted. Consult the EL5101-0011 manual for more information. Normally, NELM needs to be an integer value, like 10,20,50, 100.\n EL5112 This is the PSI standard incremental encoder interface. The terminal can be used as one channel if index pulse needs to be connected or two channel if only A and B pulse trains are needed.\nFor 1 channel operation with index pulse, use the EL5112_ABC configuration script and for two channel, the EL5112_AB script:\n# One channel: ${SCRIPTEXEC} ${ecmccfg_DIR}addSlave.cmd, \u0026quot;SLAVE_ID=16, HW_DESC=EL5112_ABC\u0026quot; # Two channel: ${SCRIPTEXEC} ${ecmccfg_DIR}addSlave.cmd, \u0026quot;SLAVE_ID=16, HW_DESC=EL5112_AB\u0026quot; EL5131 This terminal support setting cam/trigger outputs at certain counter values (for predefined time, and direction).\n8 predefined threshold counter values can be entered and configured switch outputs on or off. These thresholds can also be accessed/updated during runtime.\nDepending how the terminal should be used, the following startup scripts exists:\n EL5131: Normal increment encoder operation EL5131_DC: Normal incremental encoder and DC clock (access to timestamps) EL5131_DC_TRG: Incremental encoder, access to timestamps, access to configuration of thresholds for outputs for triggering.  # EL5131: Normal increment encoder operation: ${SCRIPTEXEC} ${ecmccfg_DIR}addSlave.cmd, \u0026quot;SLAVE_ID=16, HW_DESC=EL5131\u0026quot; # EL5131_DC: Normal incremental encoder and DC clock (access to timestamps) ${SCRIPTEXEC} ${ecmccfg_DIR}addSlave.cmd, \u0026quot;SLAVE_ID=16, HW_DESC=EL5131_DC\u0026quot; # EL5131_DC_TRG: Incremental encoder, access to timestamps and configuration of thresholds for outputs/triggering. ${SCRIPTEXEC} ${ecmccfg_DIR}addSlave.cmd, \u0026quot;SLAVE_ID=16, HW_DESC=EL5131_DC\u0026quot; "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/manual/knowledgebase/panel/","title":"panel","tags":[],"description":"","content":"Overview panel For an overview of an ecmc system, the ecmcMain.ui panel is a good starting point. The ecmcMain.ui covers most parts of an ecmc system:\n ecmc_rt thread diagnostics:  Jitter Cycle time   EtherCAT:  Status Lost frames Slave count master Id Links to dedicated sub panels for each slave type.   Links to all configured objects:  motion expert panels PLC objects plugin objects data storage objects    The panel is started with the following syntax:\ncaqtdm -macro \u0026quot;IOC=\u0026lt;ioc_name\u0026gt;\u0026quot; ecmcMain.ui "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/manual/motion_cfg/scaling/","title":"scaling","tags":[],"description":"","content":"By popular demand, the topic scaling will be discusses in closer detail.\necmc has to scaling factors for each joint, firstly the drive scaling, secondly the encoder scaling.\nChanges to the scaling have direct effects on the Kp of the PID-loop. If the drive scaling is changes, make sure to adjust the PID parameters accordingly.\n drive scaling Drive scaling deals with the relation of the drive output (typically a 16- or 32-bit register) to axis velocity. Scaling is similar, but slightly different for stepper drives and servo drives\nstepper motor drives The scaling for the Ex70xx slaves will be explained based on two very common examples.\nsimple linear axis Assumptions:\n 200 full-steps/rev motor lead screw pitch: 5 mm/rev Register 0x8012:05 is set to 1 \u0026ndash;\u0026gt; 2000 full-steps max step rate (default for ECMC, check for other slaves!) velocitySetpoint is in 16-bits.  drive: numerator: 50 # Fastest speed in engineering units (2000 full steps / s --\u0026gt; 10 rev/s * 5 mm/rev --\u0026gt; 50 mm/s) denominator: 32768 # I/O range 2^15, because 16-bit register, half is forward, the other half is backward explanation The denominator is 32768 because the velocitySetpoint is a 16-register for the Beckhoff stepper drives. Thus, half of the full range is reserved for positive (forward) motion, the remaining half for negative (backward) motion. This means that at full output the motor would receive 2000 full-steps per second. It is irrelevant whether the motor can actually spin this fast as this a purely theoretical value! Since we have established that the motor spins at 10 rev/s at full output, the conversion to engineering units is trivial and yields 50 mm/s, based on the lead screw pitch.\nrotational axis Assumptions:\n 400 full-steps/rev motor drive train ratio: 36 deg/rev Register 0x8012:05 is set to 1 \u0026ndash;\u0026gt; 2000 full-steps max step rate (default for ECMC, check for other slaves!) velocitySetpoint is in 16-bits.  drive: numerator: 180 # Fastest speed in engineering units (2000 full steps / s --\u0026gt; 5 rev/s * 36 deg/rev --\u0026gt; 180 deg/s) denominator: 32768 # I/O range 2^15, because 16-bit register, half is forward, the other half is backward explanation At full output, the motor receives 2000 full-steps/s, which results in 5 rev/s due to the higher full-step count of the motor. The drive train ratio is specified as 10 motor revolutions per 360 degree on the output or 36 deg/rev. Therefore, the resulting velocity of the motor in EGUs is 180 deg/s. Please note that this is not the actual maximum velocity, but rather a theoretical scaling factor for the PID-loop.\nservo motor drives This section is based on the Beckhoff servo motor drives (Ex72xx), AX-drives or drives from other vendors might differ. The Ex72xx servo motor drives from Beckhoff use a 32-bit register for the velocity setpoint. Therefore, the denominator takes on a value of 2^31 = 2147483648.\nAs for the numerator, the situation is a bit more complicated. The AM81xx synchronous motors come with different pole counts, most have 3 pole pairs, but some have 4. Naturally, this results in a different scaling for either type. At full output a 3 pole pair motor would spin at 8000 revolutions per second! Respectively, the 4 pole pair motor will assume 6000 rev/s. Since no servo motor will ever reach such speeds and the value is only used for the PID-loop scaling, no difference is noticeable in real life applications. Except when a motor is replaced by a different model with deviating pole pair count.\nThe following example shows a 3 pole pair motor scaled for operation in degrees. Therefore, the numerator equals 8000 rev/s * 360 deg/rev = 2880000 deg/s.\ndrive: numerator: 2880000 # Fastest speed in engineering units (8000 rev/s * 360 deg/rev) denominator: 2147483648 # I/O range 2^31, because 32-bit register, half is forward, the other half is backward encoder scaling This scaling ratio describes the relation of encoder counts and engineering units of the axis.\nUnlike the drive scaling, the encoder scaling is much simpler. It represents merely the relation between the observed counts on the encoder and the displacement of the load.\nclosed-loop Scaling absolute encoders is simple. This example shows a 32-bit encoder with 4096 ticks/mm, for an axis operated in mm.\nencoder: numerator: 1 denominator: 4096 type: 1 # Type: 0=Incremental, 1=Absolute bits: 32 # Total bit count of encoder raw data explanation none, this should be simple enough!\nopen-loop Obviously, for open-loop operation there is no encoder. In this case the internal step counter of the stepper motor drive is used as \u0026ldquo;encoder\u0026rdquo;. In the example below such a case is presented, with an explanation.\nencoder: numerator: 0.125 # 0.125 mm/rev lead screw denominator: 12800 # 200 full-steps/rev with 64 micro-steps/full-step type: 0 # Type: 0=Incremental, 1=Absolute bits: 16 # Total bit count of encoder raw data explanation The internal step counter operates in micro-steps. For most drives this value assumes 64, if uncertain consult the respective manual of the drive. In case of a 200 full-steps/rev motor, the denominator therefore will be set to 200*64=12800. As for the numerator, this is simply the displacement observed for one full motor revolution. As the step counter is incremental, the type: 0 has to be set. The step counter is of type uint16, thus the bits: 16 setting, which is important to handle the over-/underflow.\n"},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/manual/motion_cfg/best_practice/servo/","title":"servo motor (Ex72xx)","tags":[],"description":"","content":"setup  EP7211-0034 servo drive slave Lab test stage (1mm/rev) Motor : AM8111-0F20  scaling Config for scaling in mm, mm/s, mm/s2\nmotor AM8111-XFX0 Data about the motor can be found here: https://infosys.beckhoff.com/english.php?content=../content/1033/am8100/index.html\u0026amp;id=\nImportant for scaling factors in axis.yaml is the motor pole count. For the AM8111-XFX0 motor the pole count is 6.\nencoder scaling Only the encoder integrated encoder is configured in this example. The specification of the encoder for a AM8111-0F20 motor:\nOne Cable Technology for power and feedback: feedback transmission via motor cable, no feedback cable necessary, electronic nameplate, multi-turn, absolute position within 4096 revolutions, 18 bit resolution. However, when connecting to an Ex72xx drive the single turn count will be 20bits and 12bits multi-turn, resulting in a total of 32bits absolute bits.\n encoder.numerator: Travels 1 mm/rev encoder.denominator: Resolution: 1048576 counts (20bits) per = 1mm encoder.absBits: 32 bits (20bits+12bits) encoder.type: Absolute (type 1) encoder.absOffset: Offset to 0 position of linear stage (-1000 in this example)  # The encoder on most motors are 20bit single turn and 12 bit multi-turn (4096 turns) encoder: type: 1 position: ec0.s$(DRV_ID).positionActual01 numerator: 1 denominator: 1048576 bits: 32 absBits: 32 absOffset: -1000 drive scaling Max scale for motors depend on the pole count:\n 6 pole: Max scale is 8000revs/s (in this case 8000mm/s) 8 pole: Max scale is 6000revs/s  This then converts to the following cfgs:\n drive.numerator: Max velo = 8000 revs/s == 8000mm/s drive.denominator: velocity setpoint is 32bit == +-31bit = 2147483648 drive.type: Servo drive, set to 1  drive: numerator: 8000 # mm/s, Max speed is 8000 rev/sec for drive (6 pole motor) denominator: 2147483648 type: 1 # Stepper: 0, DS402: 1 (servos) control: ec0.s$(DRV_ID).driveControl01 status: ec0.s$(DRV_ID).driveStatus01 setpoint: ec0.s$(DRV_ID).velocitySetpoint01 reset: 7 switches In standard setup switches are feed from 24V output, for the lab 4ax motion crate this is not the case. However, the configuration for feeding switches (axis.feedSwitchesOutput) have been added anyway:\naxis: id: ${AX_ID=1} feedSwitchesOutput: ec0.s$(BO_ID).binaryOutput01.0 # Ethercat entry for feed switches "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/manual/motion_cfg/direction/","title":"direction of motion","tags":[],"description":"","content":"The direction of motion can be affected by multiple means. Namely, on the slave level, in the axis scaling or in the motorRecord.\nThe best option is to change the direction of motion on the slave level. The alternatives lead to unintuitive scaling factors or mismatch between ECMC and EPICS.\n EtherCAT slave ecmccfg allows SDOs to set individual SDOs in the startup-script of the IOC or in dedicated config files for slaves. As most slaves have a SDOs to invert the direction of motion or counting, it\u0026rsquo;s only natural to make use of this feature. The benefit of changing the direction on the slave is obvious. All axes move in there natural direction, as given by the machine coordinate system. Limit switches - consequently - are always where they belong, even non-experts can diagnose the device or system. Examples for encoder and drive are given below.\nConsult the respective slave manual for the correct SDO.\n encoder direction In many cases inversion of the encoder value is possible in the ethercat slave. By using INV_DIR macro to applyComponent.cmd, the direction can be changed.\nFor EL5042, example below, the inversion leads to a very high number since the data size is 64bit. Therefore, it\u0026rsquo;s advisable to switch sign in the axis configuration instead.\n # slave 7 {ecmcEL5042} ${SCRIPTEXEC} ${ecmccfg_DIR}addSlave.cmd, \u0026#34;HW_DESC=EL5042\u0026#34; ${SCRIPTEXEC} ${ecmccfg_DIR}applyComponent.cmd \u0026#34;COMP=Encoder-RLS-LA11-26bit-BISS-C,CH_ID=1, MACROS=\u0026#39;INV_DIR=1\u0026#39;\u0026#34; ${SCRIPTEXEC} ${ecmccfg_DIR}applyComponent.cmd \u0026#34;COMP=Encoder-RLS-LA11-26bit-BISS-C,CH_ID=2, MACROS=\u0026#39;INV_DIR=1\u0026#39;\u0026#34; drive direction # slave 18 {ecmcEL7041} ${SCRIPTEXEC} ${ecmccfg_DIR}addSlave.cmd, \u0026#34;HW_DESC=EL7041\u0026#34; ${SCRIPTEXEC} ${ecmccfg_DIR}applyComponent.cmd \u0026#34;COMP=Motor-Generic-2Phase-Stepper, MACROS=\u0026#39;I_MAX_MA=1000, I_STDBY_MA=500, U_NOM_MV=48000, R_COIL_MOHM=1230,INV_DIR=1\u0026#39;\u0026#34; ecmc scaling A negative numerator can be used to change the direction of motion. Refer to the scaling section for details.\nThis will result in negative values for MRES of the motorRecord.\n EPICS motorRecord The epics key of the axis config allows for motorRecord fields to be initialized. By initalizing the DIR field to Neg, the motorRecord will start inverted.\nepics: name: reveredAxis precision: 1 unit: deg motorRecord: enable: yes description: \u0026#34;inverted\u0026#34; fieldInit: \u0026#34;DIR=Neg\u0026#34;  This will affect the motorRecord only, thus ECMC internally is still moving in the wrong direction. You have been warned!\n "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/manual/motion_cfg/modes_csv_csp_csp_pc/","title":"Drive modes CSV, CSP, CSP-PC","tags":[],"description":"","content":"There\u0026rsquo;s three different modes that can can be used in ecmc toghether with most drives:\n CSV: Cyclic Sync. Velocity, (velocity setpoint sent to drive) CSP: Cyclic Sync. Position, (position setpoint sent to drive) CSP-PC: Cyclic Sync. Position with centralized position controller, (position setpoint sent to drive)  Other modes also exist, like Cyclic Sync Torque (torque/current setpoint to drive), which also can be used. However, these modes are not supported by the ecmc axis object. Still these modes can be used from PLC code or from logic in EPICS.\nControl loops The control loops are executed at different locations depending on which mode:\n    Current loop Velocity loop Position loop Comment     CSV drive drive ecmc    CSP drive drive drive ecmc generates trajectory   CSP-PC drive drive drive and ecmc dual position loop    CSV This is the most common mode for small drives like stepper-drives. In CSV the position loop is centralized. That means that any EtherCAT data can be used as feedback (not only a source connected toi the drive directly). This high flexibility is the main reason why this mode is the most common for small drive solutions. A common usecase for CSV:\n Motion stage driven with a open loop stepper motor connected to EL7041 terminal Linear feedback by absolute encoder (BISS-C) connected to EL5042 terminal  ecmccfg configurations normally defaults to CSV with one exception:\n Smaract MCS2 EC. This drive does not support CSV, see \u0026ldquo;Hardware support below\u0026rdquo;  In CSV-mode the centralized position controller is normally a simple P controller (only tuning of kp normally needed). Tuning of the control loops in the drive is sometimes also needed (depending on which hardware).\nCSP In pure CSP-mode, the position loop is executed in the drive, this means that the encoder must be connected directly to the drive. the trajectory is still generated centrally in ecmc.\nCSP is therefore more common for \u0026ldquo;bigger\u0026rdquo; servo drives where the motor are equipped with an encoder or the drive has support for multiple encoders. CSP normally performs better than CSV, since the position loop is closer to hardware, the drawback with CSP is that it is much less flexible than CSV. As a side note, EL7041 does not support CSP, however, EL7062 does, see \u0026ldquo;Hardware support below\u0026rdquo;.\nIn order to configure a drive in CSP or CSP_PC, normally the slave need to be applied with the \u0026ldquo;_CSP\u0026rdquo; suffix:\n${SCRIPTEXEC} ${ecmccfg_DIR}addSlave.cmd, \u0026quot;SLAVE_ID=3,HW_DESC=EL7062_CSP\u0026quot; In CSP, the ecmc position control parameters are not active. Tuning of the control loops in the drive is sometimes also needed (depending on which hardware).\nCSP-PC CSP-PC where PC stands for Position Control, is basically CSP but with the ecmc position loop also enabled. This results in two position control loops, one in the drive and one in ecmc. The idea is that the position loops are working with different encoders. Therefore an configuration for CSP-PC must contain at least 2 encoder (to make sense). For instance the drive position loop could be linked to the open loop counter and the centralized loop could be linked to an linear absolute encoder.\nSee \u0026ldquo;Hardware support below\u0026rdquo; to understand which drives support the different modes.\nIn order to run in CSP-PC the drive must be configured in CSP mode:\naxis: id: ${AXIS_ID=1} # Axis id mode: CSP Additionally the system must know which encoder is connected to the drive, which is configured with the \u0026ldquo;useAsCSPDrvEnc\u0026rdquo; setting. This encoder is used for the position loop in the drive. This could be an any encoder that is available in the drive, example:\n open loop counter absolute rotary encoder from an EL72xx/AM81xx encoder incremental encoder connected to EL7062  encoder: desc: CSP drive encoder ... useAsCSPDrvEnc: 1 # use this encoder as CSP drive encoder ... Finally the encoder for the centralized loop must be defined. This is defined in the normal by adding an encoder that has the encoder.primary bit set. The primary encoder is used for the centralized position loop:\nencoder: desc: Linear encoder type: 1 ... primary: 1 ... In CSP-PC, the ecmc position control loop are active and therefore the ecmc position control parameters needs tuning. Since a position setpoint is sent to the drive, a PI controller is normally needed (both kp and ki needs tuning). Tuning of the control loops in the drive is sometimes also needed (depending on which hardware).\nHardware support This is the current supported modes for some common drives used with ecmc:\n    CSV CSP CSP-PC Comment     Ex704x yes no no    Ex703x yes no no    EL7062 yes yes yes Firmware bug fix needed for CSV..   Ex72xx yes yes yes    EL7411 yes yes yes Not used yet..   MCS2 EC no yes yes    iPOS4808 yes no no     "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/manual/knowledgebase/hardware/el7062/","title":"EL7062","tags":[],"description":"","content":"Topics  error/warning openloop counter jump tuning home on index pulse of incremental encoder  error/warning If the drive is in error/warning state and not possible to enable, see drive refuse to enable.\nThe most common reason for this error is:\n motor is not connected (PSI specific): motor cable in wrong connector (at PSI motor and limits have the same 5pin M12 connector) drive has no motor voltage (PSI specific): EL9227-5500 feeding the I/O bus is not initiated (at first power on the switches on the terminal needs to be engaged)  Openloop counter jump The EL7062 has a firmware bug if configured to run in open loop CSV.\nWhen disabling the amplifier the open loop counter jump to nearest full turn value. Beckhoff works on a fix\u0026hellip;\nUse CSP mode until CSV bug is fixed by Beckhoff\n Tuning Motor might move during tuning sequence\n If tuning is off an autotune sequence can be executed from the hardware expert panel. The auto tuning sequence measures coil resistance and inductance and sets initial values for control loop parameters:\n Coil resistance Coil inductance Current loop proportional gain Current loop integration time Velocity loop proportional gain Velocity loop integration time Position loop proportional gain (used in CSP only)  The autotune process also creates an MACROS string that can be used with ecmccomp to set the parameters at startup.\nRequirements for a sucessful tuning:\n Drive must be in OP mode Drive must not be enabled Drive must have motor power  For more info see Beckhoff docs.\nSometimes further finetuning of the parameters might be needed.\nMotor might move during tuning sequence\n Home on index pulse of incremental encoder The incremental inteface of the EL7062 works in a similar ways as the EL72XX servos and are different compared to the EL5101 interface. For EL7062 the latch functionality is called touchprobes. Each channel of the drive are equipped with two touch probes which can be configured to latch on an digital input or on the index pulse of the incremental encoder. The encoder source of the touchprobes can also be configured as openloop counter or incremental encoder (secondary encoder).\nSDO configs: Configure touch probe to latch on encoder index pulse The following commands can be used (see beckhoff manula for more info):\n# CH1 Set touch probe to latch on index pulse ecmcConfigOrDie \u0026quot;Cfg.EcAddSdo(${ECMC_EC_SLAVE_NUM},0x8001,0x11,5,2)\u0026quot; # CH2 Set touch probe to latch on index pulse ecmcConfigOrDie \u0026quot;Cfg.EcAddSdo(${ECMC_EC_SLAVE_NUM},0x8101,0x11,5,2)\u0026quot; Configure touch probe encoder source # CH1 Set touch probe source 01 to secondary encoder ecmcConfigOrDie \u0026quot;Cfg.EcAddSdo(${ECMC_EC_SLAVE_NUM},0x8001,0x15,1,2)\u0026quot; # CH2 Set touch probe source 01 to secondary encoder ecmcConfigOrDie \u0026quot;Cfg.EcAddSdo(${ECMC_EC_SLAVE_NUM},0x8101,0x15,1,2)\u0026quot; Using ecmcomp These commands are also accessible via the Encoder-Generic-INC component of ecmccomp:\nThe follwoing macros are implemented:\nTP1_POS_SRC : Touchprobe 1 source PRIM: primary encoder (open loop counter) SEC: secondary encoder (incremental encoder) TP2_POS_SRC : Touchprobe 2 source PRIM: primary encoder (open loop counter) SEC: secondary encoder (incremental encoder) TP1_TRG : Touchprobe 1 trigger TPBI: touch probe input 1 INDEX: encoder index pulse TP2_TRG : Touchprobe 2 trigger TPBI: touch probe input 2 INDEX: encoder index pulse Example: ${SCRIPTEXEC} ${ecmccfg_DIR}applyComponent.cmd \u0026quot;COMP=Encoder-Generic-INC, CH_ID=2, MACROS='ST_ENC_RES=4000,TP1_POS_SRC=SEC,TP1_TRG=INDEX'\u0026quot; Arm latch Arming a latch/touchprobe is a bit more complex than when using EL5101 and its done by the touch probe control word (covering both touch probes):\n   bit tp ch desc     0 1 enable touch probe   1 1 enable continous latching   2 1 trig mode B1   3 1 trig mode B2   4 1 latch on positive edge   5 1 latch on negative edge   6 1 reserved   7 1 reserved   8 2 enable touch probe   9 2 enable continous latching   10 2 trig mode B1   11 2 trig mode B2   12 2 latch on positive edge   13 2 latch on negative edge   14 2 reserved   15 2 reserved    The ecmc parameter for accessing the control word is:\n CH1: ec0.s$(ENC_SID).touchProbeControl01 CH2: ec0.s$(ENC_SID).touchProbeControl02  As an example, arming the touchprobe for the following scenario:\n Drive channel 1 Touch probe 1 latching positive edge  would reuqire the follwoing bits in the ec0.s$(ENC_SID).touchProbeControl01 to be set:\n 0: enable 2: trig mode B1 4: latch on positive edge or 0b10101 = 21dec  when setting up homing for an encoder in ecmccfg the latch/touchprobe then needs to be configured in the follwoing way:\nencoder: desc: Inc RS422 numerator: 360 # Scaling numerator example 1 mm/rev denominator: 1048576 # Scaling denominator example 4096 ticks per 360 degree type: 0 # Type: 0=Incremental, 1=Absolute bits: 32 # Total bit count of encoder raw data absBits: 0 # Absolute bit count (for absolute encoders) always least significant part of 'bits' position: ec0.s$(ENC_SID).positionActual${ENC_CH=01}_2 # Ethercat entry for actual position input (encoder) status: ec0.s$(ENC_SID).touchProbeStatus${ENC_CH=01} # mandatory only if 'warning' or 'error' are used control: ec0.s$(ENC_SID).touchProbeControl${ENC_CH=01} primary: True latch: position: ec0.s$(ENC_SID).touchProbePositionPos$(ENC_CH=01)_1 # Link to latched value 1 control: 0 # Bit in encoder control word to arm latch. status: 1 # Bit in encoder status word for latch triggered status. armCmd: 21 # Arm command, 0b10101 for EL7062 touch probes armBits: 5 # Arm command bit size, 5 bits for EL7062 touch probes homing: type: 12 # Homing sequence type position: 0 # Position to reference encoder to velocity: to: 30 # Velocity to cam/sensor (used for some homing seqs) from: 20 # Velocity from cam/sensor (used for some homing seqs) acceleration: 20 # Acceleration during homing deceleration: 100 # Deceleration during homing latchCount: 1 # latch number to ref on (1=ref on first latch) here the follwoing controls the arming of the latch:\n encoder.control: touchprobe control word. encoder.latch.control: start bit in touchprobe control word to write \u0026ldquo;encoder.latch.armBits\u0026rdquo; bits of arm command (encoder.latch.armCmd) encoder.latch.armCmd: Decimal value of bit pattern to arm touch probe encoder.latch.armBits: Bit length of encoder.latch.armCmd to write into encoder.control (starting at bit position encoder.latch.control) and status/result: encoder.latch.status bit of encoder.status word toggles when a new touchprobe latches encoder.latch.position: the latched position  Startup file example require ecmccfg \u0026quot;ENG_MODE=1\u0026quot; ${SCRIPTEXEC} ${ecmccfg_DIR}addSlave.cmd, \u0026quot;SLAVE_ID=3,HW_DESC=EL7062_CSP\u0026quot; ${SCRIPTEXEC} ${ecmccfg_DIR}applyComponent.cmd \u0026quot;COMP=Motor-Generic-2Phase-Stepper, CH_ID=1, MACROS='I_MAX_MA=1000, I_STDBY_MA=100, U_NOM_MV=24000,L_COIL_UH=3050,R_COIL_MOHM=2630'\u0026quot; ${SCRIPTEXEC} ${ecmccfg_DIR}applyComponent.cmd \u0026quot;COMP=Drive-Generic-Ctrl-Params, CH_ID=1, MACROS='I_TI=12,I_KP=58,V_TI=150,V_KP=176,P_KP=10'\u0026quot; # configure touch probe to latch on index pulse of secondary encoder (incremental) ${SCRIPTEXEC} ${ecmccfg_DIR}applyComponent.cmd \u0026quot;COMP=Encoder-Generic-INC, CH_ID=1, MACROS='ST_ENC_RES=4000,TP1_POS_SRC=SEC,TP1_TRG=INDEX'\u0026quot; epicsEnvSet(DRV_SID,${ECMC_EC_SLAVE_NUM}) # Configure axis and open loop encoder ${SCRIPTEXEC} ${ecmccfg_DIR}loadYamlAxis.cmd, \u0026quot;FILE=./cfg/axis.yaml, DEV=${IOC}, AX_NAME=M1, AXIS_ID=1, DRV_SID=${DRV_SID}, ENC_SID=${DRV_SID}, ENC_CH=01\u0026quot; # Configure incremental encoder ${SCRIPTEXEC} ${ecmccfg_DIR}loadYamlEnc.cmd, \u0026quot;FILE=./cfg/enc_inc.yaml, DEV=${IOC}, ENC_SID=${DRV_SID},ENC_CH=02\u0026quot; "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/manual/knowledgebase/hardware/el70x1/","title":"EL70x1","tags":[],"description":"","content":"Topics  error/warning tuning Speed range  error/warning If the drive is in error/warning state and not possible to enable, see drive refuse to enable.\nThe most common reason for this error is:\n motor is not connected (PSI specific): motor cable in wrong connector (at PSI motor and limits have the same 5pin M12 connector) drive has no motor voltage (PSI specific): EL9227-5500 feeding the I/O bus is not initiated (at first power on the switches on the terminal needs to be engaged)  Further information about the error/warning can be read from from the drive\u0026rsquo;s diagnostic register, Index A010 STM Diag data Ch.1:\nThe ecmccfg/utils/read_el70xx_diag.sh tool can be used to read all the diagnostic registers of any ex70xx drive:\nbash read_el70xx_diag.sh \u0026lt;master_id\u0026gt; \u0026lt;slave_id\u0026gt; Example: master 0, slave 3, drive under voltage warning\nbash read_el70xx_diag.sh 0 3 ######################################################### Reading EL70xx status at master id 0 and slave id 3: Saturated: 0x00 0 Over temperature: 0x00 0 Torque overload: 0x00 0 Under voltage: 0x01 1 Over voltage: 0x00 0 Short circuit A: 0x00 0 Short circuit B: 0x00 0 No control power: 0x00 0 Misc error: 0x00 0 ######################################################### Note: The toolecmccfg/utils/PDO_read can also be used for reading the diagnostics.\nunder voltage Use a multimeter to verify that the voltage level corresponds to voltage levels described in the electrical drawings. If the voltage is correct, then the under voltage alarm could be related to wrong setting of nominal drive voltage setting (48V but the drive is powered with 24V).\nThe nominal drive voltage setting can be changed by the U_NOM_MV macro when applying the component (ecmccomp).\nExample: Set nominal voltage to 24V\n${SCRIPTEXEC} ${ecmccfg_DIR}addSlave.cmd, \u0026quot;HW_DESC=EL7041-0052\u0026quot; ${SCRIPTEXEC} ${ecmccfg_DIR}applyComponent.cmd \u0026quot;COMP=Motor-Generic-2Phase-Stepper, MACROS='I_MAX_MA=1000, I_STDBY_MA=500, U_NOM_MV=24000, R_COIL_MOHM=1230'\u0026quot;  For the EL703x drives the nominal voltage must be set to 24V (ecmccomp handles this automatically).\n over voltage Use a multimeter to verify that the voltage level corresponds to voltage levels described in the electrical drawings. If the voltage is correct, then the over voltage alarm could be related to wrong setting of nominal drive voltage setting (24V but the drive is powered with 48V).\nThe nominal drive voltage setting can be changed by the U_NOM_MV macro when applying the component (ecmccomp).\nExample: Set nominal voltage to 48V\n${SCRIPTEXEC} ${ecmccfg_DIR}addSlave.cmd, \u0026quot;HW_DESC=EL7041-0052\u0026quot; ${SCRIPTEXEC} ${ecmccfg_DIR}applyComponent.cmd \u0026quot;COMP=Motor-Generic-2Phase-Stepper, MACROS='I_MAX_MA=1000, I_STDBY_MA=500, U_NOM_MV=48000, R_COIL_MOHM=1230'\u0026quot;  For the EL703x drives the nominal voltage must be set to 24V (ecmccomp handles this automatically).\n No control power This error occurs if the drive has no 24V control voltage on the power bus.\nReasons could be:\n Over current protection terminal (EL92xx) tripped or not enabled, see over current protection. At first start all over current protection terminals are normally disabled and needs enabling before use. No voltage connected to power bus (coupler or over current protection). Other electrical issues (short circuit). Wrong order of slaves, some slaves do not transfer the power bus downstream. If this is the case, then a redesign of the order of the ethercat terminals or addition of a power supply terminal before, EL9410, are needed.  The control voltage can be measured between pin 3 and pin 7 of the EL7041 and should be 24V (see EL7041 documentation on Beckhoff website).\nMisc Error \u0026ldquo;Misc\u0026rdquo; error could be related to wrong wiring of motor, open wires, or defect motor. Investigate by measure resistance of the 2 motor phases:\n Make sure no power on drive Disconnect motor from drive Measure resistance of phase A (A to A/) and Phase B (B to B/). The resistance should correspond roughly to what is specified in the motor data sheet and be approx equal in the 2 phases. Some deviations might occur depening on cabling. Measure resistance between the motor phases (A and B) ground (or machine frame). The resitance should be high, if low the motor widing might be shorted to ground.  Tuning There are normally several control loops in an ecmc system:\n Position loop (centralized in ecmc if CSV), see tuning Velocity loop (in drive) Current loop (in drive)  However, for the EL70x1 drives there\u0026rsquo;s no dedicated velocity loop.\nCurrent loop For most use cases, the default current controller parameters are already well tuned. Sometimes when operating at higher speeds the current loop needs to be tuned.\nThe following parameters can be tuned for a EL70x1 stepper drive:\n 8011:07 Ka factor 8011:08 Kd factor 8011:01 Kp factor 8011:02 Ki factor  8011:07 Ka and 8011:08 Kd factor: 8011:07 Ka factor / 8011:08 Kd factor are “current boosts” during acceleration/deceleration. Default they are set to 100% which is normally is too high for most applications. Start by setting these parameters to 0.\n8011:01 Kp and 8011:02 Ki factor: This is the current loop settings and this is also what affect the performance. The higher you set these registers, the stiffer the control loop. For most applications it is important to keep a ration of 40:1. Default is 400 / 10, if you want a stiffer loop, then change to f ex 800 / 20 and onwards. Increase until the motor misbehaves and go back to a safe setting.\nspeed range The EL704x stepper drives are default setup to a maximum velocity range of +-2000 full-steps/s. The 16bit velocity setpoint that are sent to the drive corresponds to this range. The speed range for the EL704x can however be changed by setting SDO 8012:05:\n0 for 1000 full-steps/second 1 for 2000 full-steps/second (default) 2 for 4000 full-steps/second 3 for 8000 full-steps/second 4 for 16000 full-steps/second 5 for 32000 full-steps/second  When changing the speed range of the drive, also the drive scaling in the axis yaml configuration must be updated, see scaling.\n "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/manual/knowledgebase/hardware/","title":"hardware","tags":[],"description":"","content":"Topics  ELxxxx   EL1xxx   EL5042   EL51xx   EL7062   EL70x1   EL72xx   EL9xxx   Hardware issues    culprit From experience, very few issues are related to the EtherCAT hardware itself. Mostly the cabling, missing power or the actual motor/encoder hardware is to blame.\nEven more likely is human error, such as:\n wrong scaling of the axis writing to the wrong hardware (forgot to select the right slave in the axis config) \u0026hellip;  check the status Before anything is restarted or power cycled, check the status of the system.\nA simple way to get an overview of the entire ecmc system is to start the ecmcMain.ui panel. This panel contains, or links to, almost the entire ecmc IOC:\n thread status EtherCAT master status EtherCAT slaves status (overview of all configured slaves) motion axes (all axes in the system are reachable) PLC:s \u0026hellip;  caqtdm -macro \u0026#34;IOC=\u0026lt;iocname\u0026gt;\u0026#34; ecmcMain.ui Remember, red is not necessarily a bad sign! It can also indicate that certain channels are not connected. Whether those channels should be connected is beyond the scope of this guide.\nNext step is to diagnose from a dedicated shell, or from within the iocsh.\nIf all slaves are in \u0026lsquo;OP\u0026rsquo; state, at least data is exchanged between the hardware and the master.\nrestarting the IOC Blindly restarting the IOC, with only partially working EtherCAT hardware, WILL RESULT IN TOTAL FAILURE OF THE IOC!!!\n Check the hardware BEFORE restarting the IOC!\n"},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/manual/knowledgebase/hardware/el72xx/","title":"EL72xx","tags":[],"description":"","content":"Topics  error/warning  error/warning If the drive is in error/warning state and not possible to enable:\n Missing power supply STO tripped Defect cable Wrong/messey cabling between connector and actual terminal.  Tuning ** Always be prepared to \u0026ldquo;KILL\u0026rdquo; or estop the axes while performing tuning**\n  Make sure scaling factors are correct. Test by setting ecmc position controller parameters to 0 and perform a move. This move will basically be a openloop positioning. Normally still the actual and setpoint track very well during the move, if not, then scaling of drive or encoder is most likely wrong. Check gear ratios. For most applications the defualt values for the current loop and velocity loop is good. For slow motion, running slow, accurate and smooth, it could be beneficial to reduce velocity Kp and Ti in the drive.  Electrical installation Issues Strange issues have occured if the OCT cable shielding is not kept intact until close to the terminal. Issues were ideified when the individual wires been mixed randomly in cable management trays inside a control cabinet. (with OCT connector on outside, then going to terminals, then single wires to EL72xx). This is not a good concept. Keep sheilding of encoder and motor cables also inside crate. The diagnostic buffer of EL72xx showed encoder related error messages.\nOCT cable failure Once identified defect OCT cable. Symptoms was frequent disabling of drive, going to fault state.\n"},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/manual/knowledgebase/hardware/el9xxx/","title":"EL9xxx","tags":[],"description":"","content":"Topics  over current protection passive terminals   over current protection In the standard setup at PSI over current protection modules are used to feed 24V to both the EtherCAT communication bus (E-bus) and the power bus of the EtherCAT slaves. If the over current protection is not enabled then the EtherCAT slaves will not receive power.\nFirst time, (and only first time), a system is in use, the over-current modules needs to be enabled in order to allow current to flow. Enabling is done by push buttons in the LED area of the module. The long horizontal LEDs are in fact buttons that can be used to activate or tripp the over current protection.\nBefore pressing any button, check the electrical drawings and make sure it\u0026rsquo;s safe to power on the system.\n el9221-5000 The EL9221-5000 has one channel and therefore only the top button is needed to be pressed.\nel9227-5500 The EL9227-5500 is a 2 channel module and normally both channels needs to be enabled by pressing both the top and bottom long LED. if only one are pressed it could result in that the power to the communication is fine but the power to the i/o bus is lacking. This can result in strange issues. Both EL9227-5500 and EL9221-5000 have dedicated panels where status of the over current protection can be seen.\npassive terminals Some terminals are passive. Passive terminals are not EtherCAT slaves and do not communicate over EtherCAT (not equipped with EtherCAT slave controller). Passive terminals are normally used to simplify electrical connections (avoiding external terminals). For instance for distributing potential, 24V and 0V, an EL9184 can be used (8Ch 24V and 8Ch 0V).\nThe passive terminals will not show up as an EtherCAT slave when issuing the \u0026ldquo;ethercat slaves\u0026rdquo; command. However, they are normally visible in the electrical drawings. This could result in that the slave id in the electrical drawing is NOT corresponding to the EtherCAT slave index used when configuring ecmc. In worst case this could lead to that the wrong hardware/drive is configured.\nWhen configuring ecmc, make sure the EtherCAT slave index is correct, do not blindly trust the electrical drawings since a passive terminal could introduce an shift in the slave indices.\n "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/manual/general_cfg/best_practice/","title":"best practice","tags":[],"description":"","content":"EtherCAT rate (EC_RATE) The default EtherCAT frame rate in ecmc is set to 1kHz. For most applications this is however not needed and can therefore be reduced. A reduced EtherCAT rate reduces the load on the controller. In general, a good value for the frame rate is in the range 100Hz to 1kHz. For motion systems, a frame rate of 100Hz..500Hz is normally enough. Rates outside the 100Hz..1kHz range is normally not a good idea, and some slaves might not support it. However, in special cases both lower and higher rates might be possible and required.\nExample: Set rate to 500Hz\nrequire ecmccfg \u0026quot;EC_RATE=500\u0026quot; ... For more information see the chapter startup.cmd.\nAs a comparison, TwinCAT default EtherCAT rates are:\n 100Hz for PLC 500Hz for motion  See host/ecmc_server for more information.\nThe EPICS PVs will update at a lower rate than the ethercat master rate. See PVProcessingRate.md for more information.\n ecmc server setup  If possible, make sure the native igb ethercat driver is used.  For more information see:\n https://git.psi.ch/motion/ecmc_server_cfg ecmc_server for more information.  "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/manual/knowledgebase/hardware/hardware_issues/","title":"Hardware issues","tags":[],"description":"","content":"Hardware List of hardware issues at PSI:\n   Date Type Description     03.06.25 Cable OCT cable failure. Motor enable lost frequently, error bit on drives set.    "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/manual/motion_cfg/homing/","title":"homing","tags":[],"description":"","content":"homing The following sequences are available:\nECMC_SEQ_HOME_NOT_VALID = 0, ECMC_SEQ_HOME_LOW_LIM = 1, ECMC_SEQ_HOME_HIGH_LIM = 2, ECMC_SEQ_HOME_LOW_LIM_HOME = 3, ECMC_SEQ_HOME_HIGH_LIM_HOME = 4, ECMC_SEQ_HOME_LOW_LIM_HOME_HOME = 5, ECMC_SEQ_HOME_HIGH_LIM_HOME_HOME = 6, ECMC_SEQ_HOME_BWD_HOME = 7, ECMC_SEQ_HOME_FWD_HOME = 8, ECMC_SEQ_HOME_BWD_HOME_HOME = 9, ECMC_SEQ_HOME_FWD_HOME_HOME = 10, ECMC_SEQ_HOME_LOW_LIM_INDEX = 11, ECMC_SEQ_HOME_HIGH_LIM_INDEX = 12, ECMC_SEQ_HOME_SET_POS = 15, ECMC_SEQ_HOME_LOW_LIM_SINGLE_TURN_ABS = 21, ECMC_SEQ_HOME_HIGH_LIM_SINGLE_TURN_ABS = 22, ECMC_SEQ_HOME_SET_POS_2 = 25, ECMC_SEQ_HOME_TRIGG_EXTERN = 26, Additionally, for homing of absolute encoder with ONE overflow in the range, please check here\nECMC_SEQ_HOME_NOT_VALID = 0 Not a valid homing sequence, can be used if encoder is absolute.\nECMC_SEQ_HOME_LOW_LIM = 1,  Axis moves backward until low limit switch and stops Axis moves forward until edge detected in limit switch signal. Position is latched. Axis stops Homing is performed. ECMC_HOME_POS will be the new position at the position latched in step 2.  ECMC_SEQ_HOME_HIGH_LIM = 2,  Axis moves forward until high limit switch and stops Axis moves backward until edge detected in limit switch signal. Position is latched. Axis stops Homing is performed. ECMC_HOME_POS will be the new position at the position latched in step 2.  ECMC_SEQ_HOME_LOW_LIM_HOME = 3,  Axis moves backward until low limit switch and stops Axis moves forward until edge detected in home switch signal. Position is latched. Axis stops Homing is performed. ECMC_HOME_POS will be the new position at the position latched in step 2.  ECMC_SEQ_HOME_HIGH_LIM_HOME = 4,  Axis moves forward until high limit switch and stops Axis moves backward until edge detected in home switch signal. Position is latched. Axis stops Homing is performed. ECMC_HOME_POS will be the new position at the position latched in step 2.  ECMC_SEQ_HOME_LOW_LIM_HOME_HOME = 5,  Axis moves backward until low limit switch and stops Axis moves forward until edge detected in home switch signal. Position is latched. Axis continues until second edge of home sensor. Motion is stopped. Axis moves backward until edge of home sensor. Position is latched. Homing is performed. ECMC_HOME_POS will be the new position at the center point of the two latched positions in step 2 and 4.  ECMC_SEQ_HOME_HIGH_LIM_HOME_HOME = 6,  Axis moves forward until low limit switch and stops Axis moves backward until edge detected in home switch signal. Position is latched. Axis continues until second edge of home sensor. Motion is stopped. Axis moves forward until edge of home sensor. Position is latched. Homing is performed. ECMC_HOME_POS will be the new position at the center point of the two latched positions in step 2 and 4.  ECMC_SEQ_HOME_BWD_HOME = 7,  Axis moves backward until positive edge detected in home switch signal. Position is latched. (polarity of home sensor can be changed) Axis stops Homing is performed. ECMC_HOME_POS will be the new position at the position latched in step 1.  ECMC_SEQ_HOME_FWD_HOME = 8,  Axis moves forward until positive edge detected in home switch signal. Position is latched. (polarity of home sensor can be changed) Axis stops Homing is performed. ECMC_HOME_POS will be the new position at the position latched in step 1.  ECMC_SEQ_HOME_BWD_HOME_HOME = 9,  Axis moves backward until positive edge detected in limit switch signal. Position is latched. (polarity of home sensor can be changed) Axis contiues to move until a negative edge of the home sensor is detected. Axis stops. Axis moves forward until positive edge detected in limit switch signal. Position is latched. (polarity of home sensor can be changed) Homing is performed. ECMC_HOME_POS will be the new position at the center point of the two latched positions in step 2 and 4.  ECMC_SEQ_HOME_FWD_HOME_HOME = 10,  Axis moves forward until positive edge detected in limit switch signal. Position is latched. (polarity of home sensor can be changed) Axis contiues to move until a negative edge of the home sensor is detected. Axis stops. Axis moves backward until positive edge detected in limit switch signal. Position is latched. (polarity of home sensor can be changed) Homing is performed. ECMC_HOME_POS will be the new position at the center point of the two latched positions in step 2 and 4.  ECMC_SEQ_HOME_LOW_LIM_INDEX = 11,  Axis moves backward until low limit switch and stops Axis moves forward until the predefined index signals (ECMC_HOME_LATCH_COUNT_OFFSET)from the encoder is encountered. Position is latched at the desired index position. Axis stops Homing is performed. ECMC_HOME_POS will be the new position at the position latched in step 2.  Some additional parameters need to be defined for this homing sequence should work (Example for el5101 ):\nepicsEnvSet(\u0026quot;ECMC_EC_ENC_LATCHPOS\u0026quot;, \u0026quot;ec0.s3.encoderLatchPostion01\u0026quot;) # Ethercat entry for latch position (only valid for home seq 11,12) epicsEnvSet(\u0026quot;ECMC_EC_ENC_LATCH_CONTROL\u0026quot;, \u0026quot;ec0.s3.encoderControl01.0\u0026quot;) # Ethercat entry for latch control (only valid for home seq 11,12) epicsEnvSet(\u0026quot;ECMC_EC_ENC_LATCH_STATUS\u0026quot;, \u0026quot;ec0.s3.encoderStatus01.0\u0026quot;) # Ethercat entry for latch status (only valid for home seq 11,12) epicsEnvSet(\u0026quot;ECMC_HOME_LATCH_COUNT_OFFSET\u0026quot;,\u0026quot;2\u0026quot;) # Number of latch/over/under-flow for home (home seq 11,12,21,22) yaml-based EL51xx:\nencoder: position: ec$(MASTER_ID).s$(ENC_SID).positionActual$(ENC_CHAN) type: 0 # Type (0=Incremental, 1=Absolute) numerator: -3.1415926 # denominator: 118000 # bits: 32 # Total bit count of encoder raw data primary: 0 control: 'ec$(MASTER_ID).s$(ENC_SID).encoderControl$(ENC_CHAN)' status: 'ec$(MASTER_ID).s$(ENC_SID).encoderStatus$(ENC_CHAN)' position: 0 latch: position: 'ec$(MASTER_ID).s$(ENC_SID).encoderLatchPostion$(ENC_CHAN)' # Link to latched value. Used for some homing seqs control: 0 # Bit in encoder control word to arm latch. Used for some homing seqs status: 0 # Bit in encoder status word for latch triggered status. Used for some homing seqs homing: type: 11 # low limit, encoder index latchCount: 1 # latch number to ref on (1=ref on first latch) Backround to the cfgs (control and status word for latching)\n bit 0 of control word is: 0x7000:01 - Enable latch on index bit 0 of status word is: 0x6000:01 - Latch occured  ECMC_SEQ_HOME_HIGH_LIM_INDEX = 12,  Axis moves forward until high limit switch and stops Axis moves backward until the predefined index signals (ECMC_HOME_LATCH_COUNT_OFFSET) from the encoder is encountered. Position is latched at the desired index position. Axis stops Homing is performed. ECMC_HOME_POS will be the new position at the position latched in step 2.  Some additional parameters need to be defined for this homing sequence should work (Example for el5101 ):\nepicsEnvSet(\u0026quot;ECMC_EC_ENC_LATCHPOS\u0026quot;, \u0026quot;ec0.s3.encoderLatchPostion01\u0026quot;) # Ethercat entry for latch position (only valid for home seq 11,12) epicsEnvSet(\u0026quot;ECMC_EC_ENC_LATCH_CONTROL\u0026quot;, \u0026quot;ec0.s3.encoderControl01.0\u0026quot;) # Ethercat entry for latch control (only valid for home seq 11,12) epicsEnvSet(\u0026quot;ECMC_EC_ENC_LATCH_STATUS\u0026quot;, \u0026quot;ec0.s3.encoderStatus01.0\u0026quot;) # Ethercat entry for latch status (only valid for home seq 11,12) epicsEnvSet(\u0026quot;ECMC_HOME_LATCH_COUNT_OFFSET\u0026quot;,\u0026quot;2\u0026quot;) # Number of latch/over/under-flow for home (home seq 11,12,21,22) yaml-based EL51xx:\nencoder: position: ec$(MASTER_ID).s$(ENC_SID).positionActual$(ENC_CHAN) type: 0 # Type (0=Incremental, 1=Absolute) numerator: -3.1415926 # denominator: 118000 # bits: 32 # Total bit count of encoder raw data primary: 0 control: 'ec$(MASTER_ID).s$(ENC_SID).encoderControl$(ENC_CHAN)' status: 'ec$(MASTER_ID).s$(ENC_SID).encoderStatus$(ENC_CHAN)' position: 0 latch: position: 'ec$(MASTER_ID).s$(ENC_SID).encoderLatchPostion$(ENC_CHAN)' # Link to latched value. Used for some homing seqs control: 0 # Bit in encoder control word to arm latch. Used for some homing seqs status: 0 # Bit in encoder status word for latch triggered status. Used for some homing seqs homing: type: 12 # high limit, encoder index latchCount: 1 # latch number to ref on (1=ref on first latch) Backround to the cfgs (control and status word for latching)\n bit 0 of control word is: 0x7000:01 - Enable latch on index bit 0 of status word is: 0x6000:01 - Latch occured  ECMC_SEQ_HOME_SET_POS = 15, (setPosition) Sequence 15 is resereved for save/restore functionality.\nUse ECMC_SEQ_HOME_SET_POS_2 instead (same but not blocked by motor record).\nHowever the sequence 15 can be triggered like the following:\n# Turn off amplifier caput IOC_TEST:Axis1.CNEN 0 # Homing using seq 15 (cannot be triggered from HOMR/HOMF since blocked in motor record) caput IOC_TEST:Axis1.FOFF 1 caput IOC_TEST:Axis1.SET 1 caput IOC_TEST:Axis1.VAL \u0026lt;new position value\u0026gt; caput IOC_TEST:Axis1.FOFF 0 caput IOC_TEST:Axis1.SET 0 ECMC_SEQ_HOME_LOW_LIM_SINGLE_TURN_ABS = 21, Indented use for resolvers (single turn absolute). Similar to seq 11 and 12.\n Axis moves backward until low limit switch and stops Axis moves forward until limit switch change state Axis stops Homing is performed. The multi-turn bits will be homed to the value of ECMC_HOME_POS also considering a offset of turns defined in ECMC_HOME_LATCH_COUNT_OFFSET.  Some additional parameters are important for this homing sequence should work (example):\nepicsEnvSet(\u0026quot;ECMC_ENC_BITS\u0026quot; \u0026quot;25\u0026quot;) # Total bit count of encoder raw data epicsEnvSet(\u0026quot;ECMC_ENC_ABS_BITS\u0026quot;, \u0026quot;12\u0026quot;) # Absolute bit count (for absolute encoders) always least significant part of ECMC_ENC_BITS epicsEnvSet(\u0026quot;ECMC_HOME_LATCH_COUNT_OFFSET\u0026quot;,\u0026quot;2\u0026quot;) # Number of over/under-flow for home (home seq 11,12,21,22) ECMC_SEQ_HOME_HIGH_LIM_SINGLE_TURN_ABS = 22,  Axis moves forward until high limit switch and stops Axis moves backward until limit switch change state Axis stops Homing is performed. The multi turn bits will be homed to the value of ECMC_HOME_POS also considering a offset of turns defined in ECMC_HOME_LATCH_COUNT_OFFSET.  Note: Only the multi turn bits are updated!\nSome additional parameters are important for this homing sequence should work (example):\nepicsEnvSet(\u0026quot;ECMC_ENC_BITS\u0026quot; \u0026quot;25\u0026quot;) # Total bit count of encoder raw data epicsEnvSet(\u0026quot;ECMC_ENC_ABS_BITS\u0026quot;, \u0026quot;12\u0026quot;) # Absolute bit count (for absolute encoders) always least significant part of ECMC_ENC_BITS epicsEnvSet(\u0026quot;ECMC_HOME_LATCH_COUNT_OFFSET\u0026quot;,\u0026quot;2\u0026quot;) # Number of over/under-flow for home (home seq 11,12,21,22) ECMC_SEQ_HOME_SET_POS_2 = 25, (setPosition) Sequence 25 is the same as 15 but not blocked by motor record. The sequence will just set a new position of the encoder without any movement.\nECMC_SEQ_HOME_TRIGG_EXTERN = 26 Trigger external homing sequence in drive.\n Optional: set drive mode to homing (and wait for mode read-back) Set trigg of homing (bit) Wait for homing ready (bit). Reference the ecmc encoder object on rising edge of the homing ready bit Optional: Change drive mode back to motion (and wait for mode read-back) Optional: Init post move if configured  Currently used for smaract: smaracat example In this example also the drive modes is automatically handled by ecmc.\nsetting polarity of home sensor For some of the sequences it could be useful to change the polarity of the home sensor. That can be done with the following command:\n\u0026quot;Cfg.SetAxisMonHomeSwitchPolarity(int axisIndex, int polarity)\u0026quot;; # polarity==0 is NC (default) # polarity==1 is NO Homing of absolute encoder with ONE overflow in the range ALWAYS adjust the absolute encoder so that no overflows occur within the motion range if possible. However, for some situations it might be hard to adjust the encoder and then a special homing needs to be performed. No dedicated homing seq exists for this in ecmc but it can be handled in plc code (needs ecmc 9.6.2).\nExample:\n/* PLC code to home an axis with an absolute encoder which has ONE overflow in the range If actual encoder value is higher than ${THRESHOLD} it will be referenced to current actual position - ${RANGE}. NOTE: Make sure the default axis encoder scaling offset is made correct for the lower part of the raw values. macros: AX_ID : ID of axis ENC_ID : ID of encoder (starts from 1) THRESHOLD : Threshold to identify overflow (in EGU) RANGE : The total range of the encoder both multi turn and single turn (in EGU) DBG : Printout debug messages set to empty (DBG='') */ if(${SELF}.firstscan) { var plc:=${SELF_ID}; ${DBG=#}println('PLC ',plc,' Initiating homing seq for abs. encoder with overflow'); }; if(mc_get_enc_ready(${AX_ID=1},${ENC_ID=1}) and not(static.encoderHomed)) { ${DBG=#}println('Checking if homing encoder is needed'); /* Set the new position if needed */ if(mc_get_act_pos(${AX_ID=1},${ENC_ID=1}) \u0026gt; ${THRESHOLD=0}) { ${DBG=#}println('Homing encoder to: ', mc_get_act_pos(${AX_ID=1},${ENC_ID=1})-${RANGE=0}); mc_set_act_pos(${AX_ID=1},${ENC_ID=1},mc_get_act_pos(${AX_ID=1},${ENC_ID=1})-${RANGE=0}); } else { ${DBG=#}println('Homing not needed!'); }; static.encoderHomed${AX_ID=1}_${ENC_ID=1}:=1; } /* Do not allow power on axis if encoder is not homed*/ if(not(static.encoderHomed${AX_ID=1}_${ENC_ID=1})) { ${DBG=#}println('Waiting for encoder ready and homing...') mc_power(${AX_ID=1},0); }; The code is accessible in file here. The file is installed with ecmccfg and can be loaded from in ecmccfg_DIR.\n${SCRIPTEXEC} ${ecmccfg_DIR}loadPLCFile.cmd, \u0026quot;FILE=${ecmccfg_DIR}home_abs_enc_overflow.plc_inc, SAMPLE_RATE_MS=1000, PLC_MACROS='DBG='\u0026quot; The file can also be included in another plc file.\nExample: main.plc\n# macros here or in PLC_MACROS in call to loadPLCFile.cmd: substitute(AX_ID=1,ENC_ID=1,RANGE=360,THRESHOLD=240) include \u0026quot;home_abs_enc_overflow.plc_inc\u0026quot; Load the file with include dir:\n${SCRIPTEXEC} ${ecmccfg_DIR}loadPLCFile.cmd, \u0026quot;FILE=./cfg/main.plc, INC=${ecmccfg_DIR}, SAMPLE_RATE_MS=1000, PLC_MACROS='DBG='\u0026quot; "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/manual/motion_cfg/axisplc/","title":"PLC","tags":[],"description":"","content":"Introduction Each axis can have a native PLC. This PLC can be e.g. used for interlocking or synchronization. The axis PLC is part of the yaml config. The code can be provided inline or in a separate file.\ninline plc: enable: yes externalCommands: yes code: - ax3.enc.actpos:=(ax1.enc.actpos+ax2.enc.actpos)/2 filter: velocity: enable: yes size: 100 trajectory: enable: yes size: 100 file plc: enable: yes externalCommands: yes file: cfg/heave.plc filter: velocity: enable: yes size: 100 trajectory: enable: yes size: 100 This is the respective plc file\nax${AXIS_NO}.enc.actpos:=(ax{{ var.ty1 }}.enc.actpos+ax{{ var.ty2 }}.enc.actpos)/2; Note the mixed use to MACROs ${AXIS_NO} and local variables {{ var.ty1 }} to boost flexibility.\n"},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/manual/motion_cfg/best_practice/","title":"best practice","tags":[],"description":"","content":"best Practice Here you can find some best practice configurations for common use cases. The complete examples with startup files can be found here\nstepper and BISS-C Example closed loop configurations for stepper and linear BISS-C encoder:\n EL7041-0052 and EL5042 (CSV) EL7062_CSP and EL5042. NOTE, this is CSP, with ecmc position loop enabled (EL7062 has firmware bug in CSV) The complete examples with startup files can be found here  servo An example configuration of a Ex72xx servo drive with AM8xxx motor. The complete example with startup file can be found here\n"},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/manual/general_cfg/pvprocessingrate/","title":"PV Processing Rate","tags":[],"description":"","content":"PV Processing Rate: Normally the the EPICS PVs will update at a lower rate than the EtherCAT master rate. However it\u0026rsquo;s possible to configure the system so that the records update at a custom rate (integer of the EtherCAT rate).\nECMC_SAMPLE_RATE_MS Macro The PV sampling rate is controlled by the global ECMC_SAMPLE_RATE_MS macro. The Macro can be set with the following wrapper:\n${SCRIPTEXEC} ${ecmccfg_DIR}setRecordUpdateRate.cmd \u0026quot;RATE_MS=1\u0026quot; All records loaded after \u0026ldquo;setRecordUpdateRate.cmd\u0026rdquo; is issued will be updated with the new rate.\nThe rate can be restored with:\n${SCRIPTEXEC} ${ecmccfg_DIR}restoreRecordUpdateRate.cmd All records loaded after \u0026ldquo;restoreRecordUpdateRate.cmd\u0026rdquo; is issued will be updated with the default rate.\nT_SMP_MS Another alternative is to use the MACROS macro when adding a slave. In this case the T_SMP_MS macro should be set:\n${SCRIPTEXEC} ${ecmccfg_DIR}addSlave.cmd, \u0026quot;SLAVE_ID=12,HW_DESC=EL7031,MACROS='T_SMP_MS=1'\u0026quot; Triggering of processing in epics layer For triggering processing with forward links in the EPICS layer a dedicated named ${P}:MCU-Updated can be used. In order to set the FLNK and processing rate the \u0026ldquo;setProcHook.cmd\u0026rdquo; should be used. The command takes two optional macros:\n PROC_HOOK: The PV that should be triggered, defaults to '' T_SMP_HOOK_MS: Sample rate of the MCU-Updated PV, defaults to EtherCAT rate (if this script is called, otherwise default is same as default for other records).  ${SCRIPTEXEC} ${ecmccfg_DIR}setProcHook.cmd \u0026quot;PROC_HOOK=TEST:TRIGG.PROC,T_SMP_HOOK_MS=1\u0026quot; "},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/motion/ecmc_axis_sync_unset/","title":"","tags":[],"description":"","content":""},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/motion/ecmc_axis_unset/","title":"","tags":[],"description":"","content":""},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/motion/ecmc_enc_unset/","title":"","tags":[],"description":"","content":""},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/motion/ecmc_virt_axis_unset/","title":"","tags":[],"description":"","content":""},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/scripts/empty/","title":"","tags":[],"description":"","content":""},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/scripts/setprochook/","title":"","tags":[],"description":"","content":""},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/startup/","title":"","tags":[],"description":"","content":""},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/source/utils/ecmcel1259_0x120000_ch8_ev5/","title":"","tags":[],"description":"","content":""},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/categories/","title":"Categories","tags":[],"description":"","content":""},{"uri":"https://paulscherrerinstitute.github.io/ecmccfg/tags/","title":"Tags","tags":[],"description":"","content":""}]